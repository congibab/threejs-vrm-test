/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/jeelizFaceExpressions.module.js":
/*!*********************************************!*\
  !*** ./lib/jeelizFaceExpressions.module.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/* eslint-disable */\nfunction da(){this.ya=!1;this.ca=null;this.Qd=void 0;this.ba=1;this.Mc=this.he=0;this.ua=null}function fa(a){if(a.ya)throw new TypeError(\"Generator is already running\");a.ya=!0}da.prototype.za=function(a){this.Qd=a};da.prototype.Ba=function(a){this.ua={we:a,Ue:!0};this.ba=this.he||this.Mc};da.prototype.return=function(a){this.ua={return:a};this.ba=this.Mc};function ma(a){this.o=new da;this.jf=a}\nma.prototype.za=function(a){fa(this.o);if(this.o.ca)return pa(this,this.o.ca.next,a,this.o.za);this.o.za(a);return ra(this)};function ua(a,c){fa(a.o);var e=a.o.ca;if(e)return pa(a,\"return\"in e?e[\"return\"]:function(l){return{value:l,done:!0}},c,a.o.return);a.o.return(c);return ra(a)}ma.prototype.Ba=function(a){fa(this.o);if(this.o.ca)return pa(this,this.o.ca[\"throw\"],a,this.o.za);this.o.Ba(a);return ra(this)};\nfunction pa(a,c,e,l){try{var q=c.call(a.o.ca,e);if(!(q instanceof Object))throw new TypeError(\"Iterator result \"+q+\" is not an object\");if(!q.done)return a.o.ya=!1,q;var p=q.value}catch(n){return a.o.ca=null,a.o.Ba(n),ra(a)}a.o.ca=null;l.call(a.o,p);return ra(a)}\nfunction ra(a){for(;a.o.ba;)try{var c=a.jf(a.o);if(c)return a.o.ya=!1,{value:c.value,done:!1}}catch(e){a.o.Qd=void 0,a.o.Ba(e)}a.o.ya=!1;if(a.o.ua){c=a.o.ua;a.o.ua=null;if(c.Ue)throw c.we;return{value:c.return,done:!0}}return{value:void 0,done:!0}}function va(a){this.next=function(c){return a.za(c)};this.throw=function(c){return a.Ba(c)};this.return=function(c){return ua(a,c)};this[Symbol.iterator]=function(){return this}}\nfunction Ba(a){function c(l){return a.next(l)}function e(l){return a.throw(l)}return new Promise(function(l,q){function p(n){n.done?l(n.value):Promise.resolve(n.value).then(c,e).then(p,q)}p(a.next())})}function Da(a){var c=new XMLHttpRequest;c.open(\"GET\",b.tc+b.neuralNetworkPath,!0);c.withCredentials=!1;c.onreadystatechange=function(){4!==c.readyState||200!==c.status&&0!==c.status||a(c.responseText)};c.send()}\nfunction Ea(a,c){if(0===c||\"object\"!==typeof a)return a;a=Object.assign({},a);c=void 0===c||-1===c?-1:c-1;for(var e in a)a[e]=Ea(a[e],c);return a}function Ia(a,c,e){return Math.min(Math.max((e-a)/(c-a),0),1)}\nfunction Ja(a){switch(a){case \"relu\":return\"gl_FragColor=max(vec4(0.,0.,0.,0.),gl_FragColor);\";case \"elu\":return\"gl_FragColor=mix(exp(-abs(gl_FragColor))-vec4(1.,1.,1.,1.),gl_FragColor,step(0.,gl_FragColor));\";case \"elu01\":return\"gl_FragColor=mix(0.1*exp(-abs(gl_FragColor))-vec4(0.1,0.1,0.1,0.1),gl_FragColor,step(0.,gl_FragColor));\";case \"arctan\":return\"gl_FragColor=atan(3.14159265359*texture2D(u0,vUV))/3.14159265359;\";case \"copy\":return\"\";default:return!1}}\nfunction Ka(a,c){var e=c%8;return a[(c-e)/8]>>7-e&1}\nfunction Oa(a){var c=JSON.parse(a);a=c.ne;var e=c.nf,l=c.n;var q=\"undefined\"===typeof btoa?Buffer.from(c.data,\"base64\").toString(\"latin1\"):atob(c.data);var p=q.length;c=new Uint8Array(p);for(var n=0;n<p;++n)c[n]=q.charCodeAt(n);q=new Float32Array(l);p=new Float32Array(e);n=a+e+1;for(var r=0;r<l;++r){for(var h=n*r,v=0===Ka(c,h)?1:-1,A=h+1,D=1,f=0,t=A+a-1;t>=A;--t)f+=D*Ka(c,t),D*=2;A=f;h=h+1+a;D=p.length;f=0;for(t=h;t<h+D;++t)p[f]=Ka(c,t),++f;for(D=h=0;D<e;++D)h+=p[D]*Math.pow(2,-D-1);q[r]=0===h&&0===\nA?0:v*(1+h)*Math.pow(2,1+A-Math.pow(2,a-1))}return q}\nvar I=function(){function a(u,d,z){d=u.createShader(d);u.shaderSource(d,z);u.compileShader(d);return u.getShaderParameter(d,u.COMPILE_STATUS)?d:!1}function c(u,d,z){d=a(u,u.VERTEX_SHADER,d);z=a(u,u.FRAGMENT_SHADER,z);u===F&&n.push(d,z);var G=u.createProgram();u.attachShader(G,d);u.attachShader(G,z);u.linkProgram(G);return G}function e(u,d){d.B=d.B?!0:!1;if(!d.B){void 0===d.Ca&&(d.Ca=\"precision lowp float;attribute vec2 a0;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=a0*.5+vec2(.5,.5);}\");void 0===\nd.Ga&&(d.Ga=[\"a0\"]);void 0===d.va&&(d.va=[2]);if(void 0===d.precision||\"highp\"===d.precision)d.precision=D;d.id=v++;void 0!==d.Ed&&(d.Ed.forEach(function(G,N){d.h=d.h.replace(G,d.gb[N])}),d.Ed.splice(0));d.oc=0;d.va.forEach(function(G){d.oc+=4*G});d.ha=c(u,d.Ca,\"precision \"+d.precision+\" float;\\n\"+d.h);d.v={};d.i.forEach(function(G){d.v[G]=u.getUniformLocation(d.ha,G)});d.attributes={};d.wa=[];d.Ga.forEach(function(G){var N=u.getAttribLocation(d.ha,G);d.attributes[G]=N;d.wa.push(N)});if(d.j){u.useProgram(d.ha);\nh=d;r=d.id;for(var z in d.j)u.uniform1i(d.v[z],d.j[z])}d.ga=!0}}function l(u){Pa.Cf(P);r!==u.id&&(P.N(),r=u.id,h=u,F.useProgram(u.ha),u.wa.forEach(function(d){0!==d&&F.enableVertexAttribArray(d)}))}function q(u,d,z){e(u,d,z);u.useProgram(d.ha);u.enableVertexAttribArray(0);r=-1;return h=d}function p(){return{h:\"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}\",i:[\"u1\"],j:{u1:0}}}var n=[],r=-1,h=null,v=0,A=!1,D=\"highp\",f=[\"u1\"],t=[\"u0\"],w={u1:0},k={u0:0},m={u1:0,u2:1},\nJ={u3:0},H={s0:p(),s1:{h:\"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}\",i:f,j:w,precision:\"lowp\"},s2:{h:\"uniform sampler2D u1,u2;varying vec2 vv0;void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a*b;}\",i:[\"u1\",\"u2\"],j:m},s3:{h:\"uniform sampler2D u1;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a.r*f;}\",i:f,j:w},s4:{h:\"uniform sampler2D u1,u2;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a.a*b.r*f;}\",\ni:[\"u1\",\"u2\"],j:m},s5:{h:\"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(1.-vv0.x,vv0.y));}\",i:f,j:w},s6:{h:\"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(vv0.x,1.-vv0.y));}\",i:f,j:w},s7:{h:\"uniform sampler2D u0;uniform float u4;varying vec2 vv0;void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=a*u4;}\",i:[\"u0\",\"u4\"],j:k},s8:{h:\"uniform sampler2D u0;uniform float u4;varying vec2 vv0;const vec4 f=vec4(.25,.25,.25,.25),g=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);float b=dot(a*u4,f);gl_FragColor=b*g;}\",\ni:[\"u0\",\"u4\"],j:k},s9:{h:\"uniform sampler2D u1;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){float a=.25*dot(e,texture2D(u1,vv0));gl_FragColor=a*e;}\",i:f,j:w},s10:{h:\"uniform sampler2D u1,u5;uniform float u6;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u5,vv0);gl_FragColor=mix(b,a,u6*f);}\",i:[\"u1\",\"u5\",\"u6\"],j:{u1:0,u5:1}},s11:{h:\"uniform sampler2D u1;uniform vec2 u7;varying vec2 vv0;void main(){gl_FragColor=.25*(texture2D(u1,vv0+u7)+texture2D(u1,vv0+u7*vec2(1.,-1.))+texture2D(u1,vv0+u7*vec2(-1.,-1.))+texture2D(u1,vv0+u7*vec2(-1.,1.)));}\",\ni:[\"u1\",\"u7\"],j:w},s12:{h:\"uniform sampler2D u1;uniform vec4 u8;varying vec2 vv0;float g(float a,float b){a=floor(a)+.5;return floor(a/exp2(b));}float h(float a,float b){return floor(a*exp2(b)+.5);}float i(float a,float b){return mod(a,h(1.,b));}float e(float c,float a,float b){a=floor(a+.5),b=floor(b+.5);return i(g(c,a),b-a);}vec4 j(float a){if(a==0.)return vec4(0.,0.,0.,0.);float k=128.*step(a,0.);a=abs(a);float c=floor(log2(a)),l=c+127.,b=(a/exp2(c)-1.)*8388608.,d=l/2.,m=fract(d)*2.,n=floor(d),o=e(b,0.,8.),p=e(b,8.,16.),q=m*128.+e(b,16.,23.),r=k+n;return vec4(o,p,q,r)/255.;}void main(){float a=dot(texture2D(u1,vv0),u8);gl_FragColor=j(a);}\",\ni:[\"u1\",\"u8\"],j:w},s13:{h:\"uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=e/(e+exp(-a));gl_FragColor=b;}\",i:t,j:k,B:!0},s14:{h:\"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(0.,0.,0.,0.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=max(f,a);}\",i:t,j:k},s15:{h:\"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=mix(exp(-abs(a))-f,a,step(0.,a));}\",i:t,j:k},\ns16:{h:\"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=exp(-abs(a))-f;gl_FragColor=mix(.1*b,a,step(0.,a));}\",i:t,j:k},s17:{h:\"uniform sampler2D u0,u6,u9;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),c=texture2D(u6,vv0),d=texture2D(u9,vv0),b=a/d;gl_FragColor=c*mix(exp(-abs(b))-f,b,step(0.,a));}\",i:[\"u0\",\"u6\",\"u9\"],j:{u0:0,u6:1,u9:2},B:!0},s18:{h:\"uniform sampler2D u0;const float e=3.141593;varying vec2 vv0;void main(){gl_FragColor=atan(e*texture2D(u0,vv0))/e;}\",\ni:t,j:k},s19:{h:\"uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=log(f+a);gl_FragColor=b;}\",i:t,j:k,B:!0},s20:{h:\"uniform sampler2D u0,u10;uniform float u11;const vec2 e=vec2(.5,.5);const float f=1e-5;const vec4 g=vec4(1.,1.,1.,1.),i=vec4(0.,0.,0.,0.);varying vec2 vv0;void main(){vec4 a=texture2D(u10,e);float b=u11*u11;vec4 c=max(b*a,f*g);gl_FragColor=texture2D(u0,vv0)/c;}\",i:[\"u0\",\"u10\",\"u11\"],j:{u0:0,u10:1},B:!0},s21:{h:\"uniform sampler2D u1;uniform vec2 u12;varying vec2 vv0;void main(){float a=u12.x*u12.y;vec2 b=floor(vv0*a)/a,c=fract(vv0*a),d=floor(b*u12.y),f=floor(u12.x*fract(b*u12.y)),g=(f*u12.y+d)/a;gl_FragColor=texture2D(u1,g+c/a);}\",\ni:[\"u1\",\"u12\"],j:w},s22:{h:\"uniform sampler2D u13,u14,u15;varying vec2 vv0;void main(){vec4 a=texture2D(u15,vv0);vec2 b=a.rg,c=a.ba;vec4 d=texture2D(u13,b),f=texture2D(u14,c);gl_FragColor=d*f;}\",i:[\"u13\",\"u14\",\"u15\"],j:{u14:0,u13:1,u15:2},B:!0},s23:{h:\"uniform float u16;uniform sampler2D u13,u14;varying vec2 vv0;void main(){vec2 a=fract(vv0*u16);vec4 b=texture2D(u13,vv0),c=texture2D(u14,a);gl_FragColor=b*c;}\",i:[\"u14\",\"u13\",\"u16\"],j:{u14:0,u13:1}},s24:{h:\"uniform float u16;uniform sampler2D u13,u14,u17,u18,u19,u20;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.),g=vec4(1e-3,1e-3,1e-3,1e-3);void main(){vec2 h=vv0*u16,l=floor(h),c=h-l;vec4 m=texture2D(u13,vv0),d=texture2D(u14,c),a=texture2D(u20,vv0);a=a*255.;vec4 n=texture2D(u17,c),o=texture2D(u18,c),p=texture2D(u19,c),i=step(-g,-a),b=e-i,j=b*step(-e-g,-a);b*=e-j;vec4 k=b*step(-2.*e-g,-a);b*=e-k;vec4 q=b;d=i*d+j*n+k*o+q*p,gl_FragColor=m*d;}\",\ni:\"u13 u14 u16 u20 u17 u18 u19\".split(\" \"),j:{u14:0,u13:1,u20:3,u17:4,u18:5,u19:6},B:!0},s25:{h:\"uniform sampler2D u13,u14,u21;uniform float u16,u22,u23,u24;varying vec2 vv0;const vec2 j=vec2(1.,1.);void main(){vec2 a=floor(u22*vv0),b=u22*vv0-a;float c=u16/u22;vec2 d=floor(b*c),f=b*c-d,g=(a+f)/u22;float k=u22*u24/u16;vec2 l=k*d,h=(l+f*u23)/u24,i=step(h,j);vec4 m=texture2D(u13,g),n=texture2D(u14,h),o=m*n*i.x*i.y,p=texture2D(u21,g);gl_FragColor=o*u23*u23+p;}\",i:\"u13 u14 u16 u22 u23 u24 u21\".split(\" \"),\nj:{u14:0,u13:1,u21:2}},s26:{h:\"uniform sampler2D u13,u14;varying vec2 vv0;void main(){vec4 a=texture2D(u13,vv0),b=texture2D(u14,vv0);gl_FragColor=a*b;}\",i:[\"u13\",\"u14\"],j:{u14:0,u13:1},B:!0},s27:{h:\"uniform sampler2D u1,u21;uniform float u25;varying vec2 vv0;void main(){gl_FragColor=texture2D(u21,vv0)+u25*texture2D(u1,vv0);}\",i:[\"u1\",\"u21\",\"u25\"],j:{u1:0,u21:1}},s28:{h:\"varying vec2 vv0;uniform sampler2D u1;const vec4 f=vec4(1.,1.,1.,1.),g=vec4(.299,.587,.114,0.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=dot(a,g)*f;}\",\ni:f,j:w,precision:\"lowp\"},s29:{h:\"varying vec2 vv0;uniform sampler2D u1;uniform float u26;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u26)).rgb,c=texture2D(u1,vv0+vec2(u26,u26)).rgb,d=texture2D(u1,vv0+vec2(u26,0.)).rgb;gl_FragColor=vec4(dot(a,f),dot(b,f),dot(c,f),dot(d,f));}\",i:[\"u1\",\"u26\"],j:w,precision:\"lowp\"},s30:{h:\"varying vec2 vv0;uniform sampler2D u1;uniform float u26;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u26)).rgb,c=texture2D(u1,vv0+vec2(u26,u26)).rgb,d=texture2D(u1,vv0+vec2(u26,0.)).rgb;gl_FragColor=vec4(a.r,b.g,c.b,dot(d,f));}\",\ni:[\"u1\",\"u26\"],j:w,precision:\"lowp\"},s31:{h:\"varying vec2 vv0;uniform sampler2D u1,u2;uniform float u27;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=vec4(0.);a-=texture2D(u1,vec2(vv0.x-u27,vv0.y-u27))*1.,a-=texture2D(u1,vec2(vv0.x-u27,vv0.y))*2.,a-=texture2D(u1,vec2(vv0.x-u27,vv0.y+u27))*1.,a+=texture2D(u1,vec2(vv0.x+u27,vv0.y-u27))*1.,a+=texture2D(u1,vec2(vv0.x+u27,vv0.y))*2.,a+=texture2D(u1,vec2(vv0.x+u27,vv0.y+u27))*1.;vec4 b=vec4(0.);b-=texture2D(u1,vec2(vv0.x-u27,vv0.y-u27))*1.,b-=texture2D(u1,vec2(vv0.x,vv0.y-u27))*2.,b-=texture2D(u1,vec2(vv0.x+u27,vv0.y-u27))*1.,b+=texture2D(u1,vec2(vv0.x-u27,vv0.y+u27))*1.,b+=texture2D(u1,vec2(vv0.x,vv0.y+u27))*2.,b+=texture2D(u1,vec2(vv0.x+u27,vv0.y+u27))*1.;vec3 c=sqrt(a.rgb*a.rgb+b.rgb*b.rgb);vec4 e=vec4(c,texture2D(u1,vv0).a),g=texture2D(u2,vv0);gl_FragColor=g.a*e.r*f;}\",\ni:[\"u1\",\"u2\",\"u27\"],j:m,B:!0},s32:{h:\"varying vec2 vv0;uniform sampler2D u1,u2;uniform float u27;const vec4 j=vec4(1.,1.,1.,1.);const vec2 k=vec2(1.,1.);void main(){float h=0.;vec2 l=k*u27,a,b;float c,d,i=0.;for(float e=-4.;e<=4.;e+=1.)for(float f=-4.;f<=4.;f+=1.)a=vec2(e,f),c=length(a)/2.,d=exp(-c*c),b=vv0+l*a,h+=d*texture2D(u1,b).r,i+=d;vec4 m=texture2D(u2,vv0);gl_FragColor=m.a*(texture2D(u1,b).r-h/i)*j;}\",i:[\"u1\",\"u2\",\"u27\"],j:m,B:!0},s33:{h:\"uniform sampler2D u3;uniform vec2 u7;varying vec2 vv0;vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}const vec2 g=vec2(.5,.5),h=vec2(1.,0.),i=vec2(0.,1.);void main(){vec2 a=vv0-u7*g;vec4 b=texture2D(u3,a),c=texture2D(u3,a+u7*h),d=texture2D(u3,a+u7*i),j=texture2D(u3,a+u7),k=e(b,c),l=e(d,j);gl_FragColor=e(k,l);}\",\ni:[\"u3\",\"u7\"],j:J},s34:{h:\"uniform sampler2D u3;uniform vec2 u7;varying vec2 vv0;const vec2 k=vec2(1.,0.),l=vec2(0.,1.),m=vec2(2.,0.),n=vec2(0.,2.);vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}vec4 f(vec2 a){vec4 b=texture2D(u3,a),c=texture2D(u3,a+u7*k),d=texture2D(u3,a+u7*l),g=texture2D(u3,a+u7),h=e(b,c),i=e(d,g);return e(h,i);}void main(){vec2 a=vv0+u7*vec2(-.55,-1.05);vec4 b=f(a),c=f(a+u7*m),d=f(a+u7*2.),g=f(a+u7*n),h=e(b,c),i=e(d,g);gl_FragColor=e(h,i);}\",i:[\"u3\",\"u7\"],j:J,B:!0},\ns35:{h:\"uniform sampler2D u1;varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a*a;}\",i:[\"u1\"],j:w,precision:\"lowp\",B:!0},s36:{h:\"uniform sampler2D u1;uniform vec2 u7;varying vec2 vv0;const float e=15444.;void main(){vec4 a=1001./e*texture2D(u1,vv0-3.*u7)+2002./e*texture2D(u1,vv0-2.*u7)+3003./e*texture2D(u1,vv0-u7)+3432./e*texture2D(u1,vv0)+3003./e*texture2D(u1,vv0+u7)+2002./e*texture2D(u1,vv0+2.*u7)+1001./e*texture2D(u1,vv0+3.*u7);gl_FragColor=a;}\",i:[\"u7\",\"u1\"],j:w,precision:\"lowp\",\nB:!0},s37:{h:\"uniform sampler2D u1,u10,u28;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);const float g=.1;void main(){vec4 a=texture2D(u10,vv0),b=texture2D(u28,vv0),c=texture2D(u1,vv0),d=max(f*g,b-a*a),h=sqrt(d);gl_FragColor=(c-a)/h;}\",i:[\"u1\",\"u10\",\"u28\"],j:{u1:0,u10:1,u28:2},B:!0}},Q={s38:{h:\"uniform float u16,u29;uniform sampler2D u13,u14,u21;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-5,1e-5);void main(){vec4 sum=texture2D(u21,vv0);float toSparsity=1.1111;vec2 uvFrom,uvWeight,xyPatch=ZERO2,eps2=EPS2/u16,xyTo=floor(vv0*u16+eps2);float weightSize=toSparsity*u16;vec2 halfFromSparsity=ONE2*(toSparsity-1.)/2.;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.)xyPatch.y=patch_y,uvFrom=(xyTo+HALF2+u29*(xyPatch-halfFromSparsity))/u16,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),uvWeight=(xyTo*toSparsity+xyPatch+HALF2)/weightSize,sum+=texture2D(u13,uvWeight)*texture2D(u14,uvFrom);}gl_FragColor=sum,gl_FragColor*=2.2222;}\",\ni:[\"u16\",\"u13\",\"u14\",\"u21\",\"u29\"],gb:[\"1.1111\",\"gl_FragColor\\\\*=2.2222;\"]},s39:{h:\"uniform float u16,u29,u24;uniform sampler2D u13,u14,u21;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-4,1e-4);void main(){vec4 sum=texture2D(u21,vv0);float fromSparsity=1.1111,shrinkFactor=3.3333;vec2 uvFrom,uvWeight,xyFrom,xyPatchTo,xyPatch=ZERO2,xyShrink=ZERO2,eps2=EPS2/u24,xyTo=floor(vv0*u16+eps2);float weightSize=fromSparsity*u24;vec2 halfFromSparsity=ONE2*(fromSparsity-1.)/2.;float toSparsity=weightSize/u16;vec2 xyFrom0=xyTo*shrinkFactor;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.){xyPatch.y=patch_y;for(float shrink_x=0.;shrink_x<3.3333;shrink_x+=1.){xyShrink.x=shrink_x;for(float shrink_y=0.;shrink_y<3.3333;shrink_y+=1.)xyShrink.y=shrink_y,xyFrom=xyFrom0+xyShrink+shrinkFactor*u29*(xyPatch-halfFromSparsity),uvFrom=(xyFrom+HALF2)/u24,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),xyPatchTo=xyPatch*shrinkFactor+xyShrink,uvWeight=(xyTo*toSparsity+xyPatchTo+HALF2)/weightSize,sum+=texture2D(u13,uvWeight)*texture2D(u14,uvFrom);}}}gl_FragColor=sum,gl_FragColor*=2.2222;}\",\ni:\"u16 u24 u13 u14 u21 u29\".split(\" \"),gb:[\"1.1111\",\"gl_FragColor\\\\*=2.2222;\",\"3.3333\"]}},y=null,K=null,P={Za:function(){return A},s:function(){if(!A){y=Ea(H,2);K=Ea(Q,2);D=\"highp\";for(var u in y)e(F,y[u],u);I.set(\"s0\");F.enableVertexAttribArray(0);A=!0}},wc:function(u){u.forEach(function(d){P.vc(d)})},vc:function(u){y[u.id]=u;e(F,u,u.id)},Wc:function(u,d,z){d||(d=u);y[d]=Object.create(K[u]);y[d].We=!0;K[u].gb&&K[u].gb.forEach(function(G,N){y[d].h=y[d].h.replace(new RegExp(G,\"g\"),z[N])});e(F,y[d],\nd)},set:function(u){var d=y[u];d.B&&(d.B=!1,e(F,d,u));l(d)},Aa:function(u){return q(u,p(),\"s40\")},dc:function(u){return q(u,{h:\"void main(){gl_FragColor=vec4(.5,.5,.5,.5);}\",i:[],precision:\"highp\"},\"s41\")},xe:function(u){return\"undefined\"===typeof y[u]?!1:y[u].ga},N:function(){-1!==r&&(r=-1,h.wa.forEach(function(u){0!==u&&F.disableVertexAttribArray(u)}))},fc:function(){var u=0;h.wa.forEach(function(d,z){z=h.va[z];F.vertexAttribPointer(d,z,F.FLOAT,!1,h.oc,u);u+=4*z})},bg:function(){F.enableVertexAttribArray(0)},\nhb:function(){P.ib(F)},ib:function(u){u.vertexAttribPointer(h.wa[0],2,u.FLOAT,!1,8,0)},Hg:function(u,d){F.uniform1i(h.v[u],d)},L:function(u,d){F.uniform1f(h.v[u],d)},ia:function(u,d,z){F.uniform2f(h.v[u],d,z)},Ig:function(u,d){F.uniform2fv(h.v[u],d)},Hd:function(u,d){F.uniform3fv(h.v[u],d)},Jg:function(u,d,z,G){F.uniform3f(h.v[u],d,z,G)},Kg:function(u,d,z,G,N){F.uniform4f(h.v[u],d,z,G,N)},ec:function(u,d){F.uniform4fv(h.v[u],d)},Lg:function(u,d){F.uniformMatrix2fv(h.v[u],!1,d)},Mg:function(u,d){F.uniformMatrix3fv(h.v[u],\n!1,d)},Ng:function(u,d){F.uniformMatrix4fv(h.v[u],!1,d)},I:function(u,d){P.set(u);d.forEach(function(z){switch(z.type){case \"4f\":F.uniform4fv(h.v[z.name],z.value);break;case \"3f\":F.uniform3fv(h.v[z.name],z.value);break;case \"2f\":F.uniform2fv(h.v[z.name],z.value);break;case \"1f\":F.uniform1f(h.v[z.name],z.value);break;case \"1i\":F.uniform1i(h.v[z.name],z.value);break;case \"mat2\":F.uniformMatrix2fv(h.v[z.name],!1,z.value);break;case \"mat3\":F.uniformMatrix3fv(h.v[z.name],!1,z.value);break;case \"mat4\":F.uniformMatrix4fv(h.v[z.name],\n!1,z.value)}})},mg:function(){return\"lowp\"},m:function(){F.disableVertexAttribArray(0);P.N();for(var u in y){var d=y[u];d.ga&&(d.ga=!1,F.deleteProgram(d.ha));d.We&&delete y[u]}n.forEach(function(z){F.deleteShader(z)});n.splice(0);v=0;A=!1;h=null;r=-1}};return P}(),F=null,Ta=function(){function a(f){console.log(\"ERROR in ContextFF: \",f);return!1}function c(f){function t(){Qa.m();Ra.reset();k.getExtension(\"WEBGL_lose_context\").loseContext()}if(navigator.userAgent&&-1!==navigator.userAgent.indexOf(\"forceWebGL1\"))return!1;\nvar w=document.createElement(\"canvas\");w.setAttribute(\"width\",5);w.setAttribute(\"height\",5);var k=null;try{k=w.getContext(\"webgl2\",f)}catch(m){return!1}if(!k)return!1;e(k);Ra.Ec(k);f=Ra.zb(k);if(!f.Z&&!f.$)return t(),!1;f=Qa.Bc(k,f);t();return f?!0:!1}function e(f){f.clearColor(0,0,0,0);f.disable(f.DEPTH_TEST);f.disable(f.BLEND);f.disable(f.DITHER);f.disable(f.STENCIL_TEST);f.disable(f.CULL_FACE);f.GENERATE_MIPMAP_HINT&&f.hint(f.GENERATE_MIPMAP_HINT,f.FASTEST);f.disable(f.SAMPLE_ALPHA_TO_COVERAGE);\nf.disable(f.SAMPLE_COVERAGE);f.depthFunc(f.LEQUAL);f.clearDepth(1)}var l=null,q=null,p=null,n=null,r=!0,h=null,v=null,A=[],D={A:function(){return l.width},J:function(){return l.height},Pa:function(){return l},eg:function(){return F},aa:function(){return r},flush:function(){F.flush()},Ce:function(){h||(h=new Uint8Array(l.width*l.height*4));F.readPixels(0,0,l.width,l.height,F.RGBA,F.UNSIGNED_BYTE,h);return h},gg:function(){return l.toDataURL(\"image/jpeg\")},hg:function(){Sa.M();q||(q=document.createElement(\"canvas\"),\np=q.getContext(\"2d\"));q.width=l.width;q.height=l.height;for(var f=D.Ce(),t=p.createImageData(q.width,q.height),w=q.width,k=q.height,m=t.data,J=0;J<k;++J)for(var H=k-J-1,Q=0;Q<w;++Q){var y=4*(J*w+Q),K=4*(H*w+Q);m[y]=f[K];m[y+1]=f[K+1];m[y+2]=f[K+2];m[y+3]=f[K+3]}p.putImageData(t,0,0);return q.toDataURL(\"image/png\")},fg:function(f){!q&&f&&(q=document.createElement(\"canvas\"),p=q.getContext(\"2d\"));var t=f?q:document.createElement(\"canvas\");t.width=l.width;t.height=l.height;(f?p:t.getContext(\"2d\")).drawImage(l,\n0,0);return t},s:function(f){f.me&&!f.yb?l=document.getElementById(f.me):f.yb&&(l=f.yb);l||(l=document.createElement(\"canvas\"));l.width=f&&void 0!==f.width?f.width:512;l.height=f&&void 0!==f.height?f.height:512;\"undefined\"===typeof f&&(f={});void 0===f.premultipliedAlpha&&(f.premultipliedAlpha=!1);void 0===f.Lb&&(f.Lb=!0);void 0===f.antialias&&(f.antialias=!1);if(F)r=F instanceof WebGL2RenderingContext;else{r=!0;var t={antialias:f.antialias,alpha:!0,preserveDrawingBuffer:!0,premultipliedAlpha:f.premultipliedAlpha,\nstencil:!1,depth:f.Lb};navigator&&navigator.userAgent&&-1!==navigator.userAgent.indexOf(\"noAntialiasing\")&&(t.antialias=!1);var w=c(t);!w&&t.antialias&&(t.antialias=!1,w=c(t));w&&(F=l.getContext(\"webgl2\",t));F?r=!0:((F=l.getContext(\"webgl\",t))||(F=l.getContext(\"experimental-webgl\",t)),r=!1)}if(!F)return a(\"WebGL1 and 2 are not enabled\");(n=F.getExtension(\"WEBGL_lose_context\"))&&f.od&&(v=f.od,l.addEventListener(\"webglcontextlost\",v,!1));if(!Ra.s())return a(\"Not enough GL capabilities\");e(F);I.s();\nS.s();if(!Qa.Bc(F,Ra.Ae()))return a(\"Cannot filter float textures\");A.forEach(function(k){k(F)});A.splice(0);return!0},Uf:function(){return new Promise(function(f){F?f(F):A.push(f)})},m:function(){F&&(Ra.m(),I.m(),Qa.m());n&&v&&(l.removeEventListener(\"webglcontextlost\",v,!1),n=v=null);F=h=p=q=l=null;A.splice(0)}};return D}(),Pa=function(){function a(){null===c&&(\"undefined\"!==typeof I?c=I:\"undefined\"!==typeof JEShaders&&(c=JEShaders))}var c=null;a();return{reset:function(){c=null},Cf:function(e){c!==\ne&&(c&&c.N(),c=e)},Za:function(){return c.Za()},hb:function(){return c.hb()},ib:function(e){return c.ib(e)},fc:function(){return c.fc()},N:function(){return c.N()},set:function(e){return c.set(e)},Aa:function(e){a();return c.Aa(e)},dc:function(e){a();return c.dc(e)}}}(),T=function(){function a(g){F.bindTexture(F.TEXTURE_2D,g)}function c(g){d[0]=g;g=z[0];var C=g>>16&32768,M=g>>12&2047,R=g>>23&255;return 103>R?C:142<R?C|31744|((255==R?0:1)&&g&8388607):113>R?(M|=2048,C|(M>>114-R)+(M>>113-R&1)):C=(C|\nR-112<<10|M>>1)+(M&1)}function e(g){var C=new Uint16Array(g.length);g.forEach(function(M,R){C[R]=c(M)});return C}function l(){if(null!==G.Ib)return G.Ib;var g=p(e([.5,.5,.5,.5]));return null===g?!0:G.Ib=g}function q(){if(null!==G.Jb)return G.Jb;var g=p(new Uint8Array([127,127,127,127]));return null===g?!0:G.Jb=g}function p(g){if(!Pa.Za()||!k)return null;var C=null,M=Math.sqrt(g.length/4);try{var R=F.getError();if(\"FUCKING_BIG_ERROR\"===R)return!1;C=N.instance({isFloat:!1,G:!0,array:g,width:M});R=F.getError();\nif(R!==F.NO_ERROR)return!1}catch(ca){return!1}Sa.M();F.viewport(0,0,M,M);F.clearColor(0,0,0,0);F.clear(F.COLOR_BUFFER_BIT);Pa.set(\"s0\");C.zc(0);S.l(!0,!0);g=4*M*M;R=new Uint8Array(g);F.readPixels(0,0,M,M,F.RGBA,F.UNSIGNED_BYTE,R);M=!0;for(var ba=0;ba<g;++ba)M=M&&3>Math.abs(R[ba]-127);C.remove();Sa.Y();return M}var n=0,r=null,h=0,v=null,A=null,D=null,f=null,t=null,w=null,k=!1,m=[],J={isFloat:!1,isPot:!0,isLinear:!1,isMipmap:!1,isAnisotropicFiltering:!1,isMirrorX:!1,isMirrorY:!1,isSrgb:!1,isKeepArray:!1,\nisFlipY:null,width:0,height:0,url:null,array:null,data:null,C:null,Sc:null,Ve:!1,G:!1,fa:null,bb:4,Sb:0},H=!1,Q=null,y=null,K=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],P=!1,u=!1,d=new Float32Array(1),z=new Int32Array(d.buffer),G={Ib:null,Jb:null},N={s:function(){k||(t=[F.RGBA,null,F.RGBA,F.RGBA],w=[F.RGBA,null,F.RGBA,F.RGBA],r=[F.TEXTURE0,F.TEXTURE1,F.TEXTURE2,F.TEXTURE3,F.TEXTURE4,F.TEXTURE5,F.TEXTURE6,F.TEXTURE7],P=\"undefined\"!==typeof JEContext,u=\"undefined\"!==typeof Ra,P&&JEContext.Ag()&&r.push(F.TEXTURE8,\nF.TEXTURE9),v=[-1,-1,-1,-1,-1,-1,-1,-1],f=[F.UNSIGNED_BYTE,F.FLOAT,F.FLOAT],k=!0)},Pe:function(){if(!A){for(var g=new Float32Array(16384),C=0;16384>C;++C)g[C]=2*Math.random()-1;A={random:N.instance({isFloat:!0,isPot:!0,array:g,width:64}),Nd:N.instance({isFloat:!1,isPot:!0,width:1,array:new Uint8Array([0,0,0,0])})}}N.Mf()},sg:function(){return A.Nd},Mf:function(){f[1]=Ra.Db(F)},Af:function(){w=t=[F.RGBA,F.RGBA,F.RGBA,F.RGBA]},yd:function(g){I.set(\"s1\");Sa.M();var C=g.A(),M=g.J();F.viewport(0,0,C,M);\ng.g(0);S.l(!1,!1)},rf:function(g,C){N.yd(g);F.readPixels(0,0,g.A(),g.J(),F.RGBA,F.UNSIGNED_BYTE,C)},sf:function(g,C){N.yd(g);return Ra.cc(0,0,g.A(),g.J(),C)},Lc:function(g,C,M,R,ba,ca,Y){g.activeTexture(g.TEXTURE0);var x=g.createTexture();g.bindTexture(g.TEXTURE_2D,x);ba=ba instanceof Float32Array?ba:new Float32Array(ba);g.texParameteri(g.TEXTURE_2D,g.TEXTURE_WRAP_S,g.CLAMP_TO_EDGE);g.texParameteri(g.TEXTURE_2D,g.TEXTURE_WRAP_T,g.CLAMP_TO_EDGE);g.texParameteri(g.TEXTURE_2D,g.TEXTURE_MAG_FILTER,g.NEAREST);\ng.texParameteri(g.TEXTURE_2D,g.TEXTURE_MIN_FILTER,g.NEAREST);g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL,ca);g.texImage2D(g.TEXTURE_2D,0,g.RGBA,M,R,0,g.RGBA,g.FLOAT,ba);g.bindTexture(g.TEXTURE_2D,null);g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL,!1);Y&&(Sa.Y(),I.Aa(g));g.viewport(0,0,M,R);g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,C,0);g.bindTexture(g.TEXTURE_2D,x);Y?S.l(!0,!0):S.Na(g);g.deleteTexture(x);k&&(v[0]=-1,D=null,n=0)},tb:function(g){g!==n&&(F.activeTexture(r[g]),n=g)},instance:function(g){function C(){U=\nvoid 0!==x.C.videoWidth?x.C.videoWidth:x.C.width;W=void 0!==x.C.videoHeight?x.C.videoHeight:x.C.height}function M(E){var V=F.getError();if(\"FUCKING_BIG_ERROR\"===V)return!1;F.texImage2D(F.TEXTURE_2D,0,ka,ha,ia,E);V=F.getError();V!==F.NO_ERROR&&ha!==F.RGBA&&(ha=F.RGBA,F.texImage2D(F.TEXTURE_2D,0,ka,ha,ia,E));return!0}function R(){if(!Ya){a(na);sa&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,sa);x.isPot?(F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_S,x.isMirrorX?F.MIRRORED_REPEAT:F.REPEAT),F.texParameteri(F.TEXTURE_2D,\nF.TEXTURE_WRAP_T,x.isMirrorY?F.MIRRORED_REPEAT:F.REPEAT)):(F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE));x.isAnisotropicFiltering&&\"undefined\"!==typeof JESETTINGS&&F.texParameterf(F.TEXTURE_2D,JEContext.jg().TEXTURE_MAX_ANISOTROPY_EXT,JESETTINGS.Qf);F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MAG_FILTER,x.isLinear?F.LINEAR:F.NEAREST);x.isLinear?F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,x.isMipmap&&!za?F.NEAREST_MIPMAP_LINEAR:\nF.LINEAR):F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,x.isMipmap&&!za?F.NEAREST_MIPMAP_NEAREST:F.NEAREST);ha=t[x.bb-1];ka=w[x.bb-1];ia=f[B];if(Ra.aa()){var E=Ra.De();ha===F.RGBA&&ia===F.FLOAT?x.isMipmap||x.isLinear?ka=Qa.Fe(F):Ra.Cc()?E&&(ka=E):ka=F.RGBA16F||F.RGBA:ha===F.RGB&&ia===F.FLOAT&&E&&(ka=E,ha=F.RGBA)}if(x.G&&!x.isFloat||x.isFloat&&x.isMipmap&&Qa.Ze())ka=Ra.Ee(),ia=Ra.Db(F);x.Sb&&(La=x.Sb);x.isSrgb&&4===x.bb&&(ha=JEContext.qg());if(x.C)M(x.C);else if(x.url)M(ya);else if(oa){E=oa;try{\"FUCKING_BIG_ERROR\"!==\nF.getError()&&(F.texImage2D(F.TEXTURE_2D,0,ka,U,W,0,ha,ia,E),F.getError()!==F.NO_ERROR&&(F.texImage2D(F.TEXTURE_2D,0,ka,U,W,0,ha,ia,null),F.getError()!==F.NO_ERROR&&F.texImage2D(F.TEXTURE_2D,0,F.RGBA,U,W,0,F.RGBA,F.UNSIGNED_BYTE,null)))}catch(Hb){F.texImage2D(F.TEXTURE_2D,0,ka,U,W,0,ha,ia,null)}x.isKeepArray||(oa=null)}else E=F.getError(),\"FUCKING_BIG_ERROR\"!==E&&(F.texImage2D(F.TEXTURE_2D,0,ka,U,W,0,ha,ia,null),E=F.getError(),E!==F.NO_ERROR&&(ha=F.RGBA,x.G&&ia!==F.FLOAT&&(ia=F.FLOAT,F.texImage2D(F.TEXTURE_2D,\n0,ka,U,W,0,ha,ia,null))));if(x.isMipmap)if(!za&&ea)ea.Cb(),Ma=!0;else if(za){E=Math.log2(Math.min(U,W));Ca=Array(1+E);Ca[0]=na;for(var V=1;V<=E;++V){var la=Math.pow(2,V),Z=U/la;la=W/la;var Aa=F.createTexture();a(Aa);F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,F.NEAREST);F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MAG_FILTER,F.NEAREST);F.texImage2D(F.TEXTURE_2D,0,ka,Z,la,0,ha,ia,null);a(null);Ca[V]=Aa}Ma=!0}a(null);v[n]=-1;sa&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!1);Fa=!0;x.fa&&ea&&(x.fa(ea),x.fa=\nnull)}}function ba(){for(var E=U*W,V=2*E,la=3*E,Z=0;Z<E;++Z)qa[0][Z]=Ga[Z],qa[1][Z]=Ga[Z+E],qa[2][Z]=Ga[Z+V],qa[3][Z]=Ga[Z+la]}function ca(){var E=U*W*4;wa=[new Uint8Array(E),new Uint8Array(E),new Uint8Array(E),new Uint8Array(E)];qa=[new Float32Array(wa[0].buffer),new Float32Array(wa[1].buffer),new Float32Array(wa[2].buffer),new Float32Array(wa[3].buffer)];Na=new Uint8Array(4*E);Ga=new Float32Array(Na.buffer);Ha=!0}function Y(){xa.vb=new Uint8Array(U*W*4);xa.Nc=new Float32Array(xa.buffer);xa.U=!0}\nvar x=Object.assign({},J,g),ja=h++;null===x.isFlipY&&(x.isFlipY=x.url||x.array?!0:!1);x.data&&(x.array=\"string\"===typeof x.data?Oa(x.data):x.isFloat?new Float32Array(x.data):new Uint8Array(x.data),x.isFlipY=!1);var B=0,L=x.C?!0:!1,aa=null,O=null,ta=!1,Ua=null;x.G=x.G||x.isFloat;x.G&&(B=1);!x.Ve&&x.isFloat&&u&&!Ra.Cc()&&(x.isFloat=!1);x.isFloat&&(B=2);x.isAnisotropicFiltering&&P&&!JEContext.vg()&&(x.isAnisotropicFiltering=!1);var na=x.Sc||F.createTexture(),ya=null,oa=!1,U=0,W=0,Fa=!1,Ya=!1,Ha=!1,qa=\nnull,wa=null,Na=null,Ga=null,ka=null,ha=null,ia=null,sa=x.isFlipY,qb=(g=x.G&&x.isMipmap)&&Qa.de(),za=g&&qb?!0:!1,Ca=null,La=-1,Ma=!1,xa={U:!1,vb:null,Nc:null};x.width&&(U=x.width,W=x.height?x.height:U);var ea={get:function(){return na},A:function(){return U},J:function(){return W},tg:function(){return x.url},wg:function(){return x.isFloat},yg:function(){return x.G},zg:function(){return x.isLinear},Cb:function(){F.generateMipmap(F.TEXTURE_2D)},be:function(E,V){za?(E||(E=ea.Qc()),N.tb(V),a(Ca[E]),v[V]=\n-1):ea.g(V)},Qc:function(){-1===La&&(La=Math.log(U)/Math.log(2));return La},ze:function(E){if(za){E||(E=ea.Qc());I.set(\"s11\");N.tb(0);for(var V=U,la=W,Z=1;Z<=E;++Z)V/=2,la/=2,I.ia(\"u7\",.25/V,.25/la),F.viewport(0,0,V,la),a(Ca[Z-1]),F.framebufferTexture2D(Sa.Ra(),F.COLOR_ATTACHMENT0,F.TEXTURE_2D,Ca[Z],0),S.l(!1,1===Z);v[0]=-1}else ea.Cb()},Gg:function(E){(L=!(Array.isArray(E)||E.constructor===Float32Array||E.constructor===Uint8Array))?(oa=null,x.C=E,C()):oa=E},g:function(E){if(!Fa)return!1;N.tb(E);\nif(v[E]===ja)return!1;a(na);v[E]=ja;return!0},zc:function(E){F.activeTexture(r[E]);n=E;a(na);v[E]=ja},u:function(){D=ea;F.framebufferTexture2D(Sa.Ra(),F.COLOR_ATTACHMENT0,F.TEXTURE_2D,na,0)},R:function(){D=ea;F.viewport(0,0,U,W);F.framebufferTexture2D(Sa.Ra(),F.COLOR_ATTACHMENT0,F.TEXTURE_2D,na,0)},nc:N.nc,resize:function(E,V){U=E;W=V;R()},clone:function(E){E=N.instance({width:U,height:W,G:x.G,isFloat:x.isFloat,isLinear:x.isLinear,isMirrorY:x.isMirrorY,isFlipY:E?!sa:sa,isPot:x.isPot});Pa.set(\"s0\");\nSa.Y();E.u();F.viewport(0,0,U,W);ea.g(0);S.l(!0,!0);return E},Df:function(){F.viewport(0,0,U,W)},remove:function(){F.deleteTexture(na);Ya=!0;m.splice(m.indexOf(ea),1);ea=null},refresh:function(){ea.zc(0);sa&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!0);L?F.texImage2D(F.TEXTURE_2D,0,ka,ha,ia,x.C):F.texImage2D(F.TEXTURE_2D,0,ka,U,W,0,ha,ia,oa);sa&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!1)},bc:function(){Ha||ca();F.readPixels(0,0,U,4*W,F.RGBA,F.UNSIGNED_BYTE,Na);ba();return qa},mf:function(){Ha||ca();return Ra.cc(0,\n0,U,4*W,Na).then(function(){ba();return qa})},qf:function(){xa.U||Y();F.readPixels(0,0,U,W,F.RGBA,F.UNSIGNED_BYTE,xa.vb);return xa.Nc},pf:function(){xa.U||Y();return Ra.cc(0,0,U,W,xa.vb)},Ab:function(E){Sa.M();I.set(\"s12\");ea.g(0);if(E)F.viewport(0,0,U,W),I.ec(\"u8\",.25,.25,.25,.25),S.l(!1,!0);else for(E=0;4>E;++E)F.viewport(0,W*E,U,W),I.ec(\"u8\",K[E]),S.l(!1,0===E)},Qg:function(E){var V=ia===f[0]&&!q();a(na);sa&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!0);V?(ta||(aa=document.createElement(\"canvas\"),aa.width=\nU,aa.height=W,O=aa.getContext(\"2d\"),Ua=O.createImageData(U,W),ta=!0),Ua.data.set(E),O.putImageData(Ua,0,0),F.texImage2D(F.TEXTURE_2D,0,ka,ha,ia,aa)):F.texImage2D(F.TEXTURE_2D,0,ka,U,W,0,ha,ia,E);v[n]=ja;sa&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!1)},Rg:function(E,V){a(na);V&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!0);F.texImage2D(F.TEXTURE_2D,0,ka,ha,ia,E);v[n]=ja;V&&F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,!1)},Eg:function(E,V){var la=U*W,Z=4*la;E=x.G?E?\"RGBE\":\"JSON\":\"RGBA\";V&&(E=V);V=Ra.aa()&&!1;var Aa=null;\nswitch(E){case \"RGBE\":Aa=\"s42\";break;case \"JSON\":Aa=V?\"s0\":\"s12\";break;case \"RGBA\":case \"RGBAARRAY\":Aa=\"s6\"}Ha||(\"RGBA\"===E||\"RGBE\"===E||\"RGBAARRAY\"===E?(wa=new Uint8Array(Z),Ha=!0):\"JSON\"!==E||V||ca());Sa.M();I.set(Aa);ea.g(0);Z=null;if(\"RGBA\"===E||\"RGBE\"===E||\"RGBAARRAY\"===E){F.viewport(0,0,U,W);S.l(!0,!0);F.readPixels(0,0,U,W,F.RGBA,F.UNSIGNED_BYTE,wa);if(\"RGBAARRAY\"===E)return{data:wa};H||(Q=document.createElement(\"canvas\"),y=Q.getContext(\"2d\"),H=!0);Q.width=U;Q.height=W;la=y.createImageData(U,\nW);la.data.set(wa);y.putImageData(la,0,0);Z=Q.toDataURL(\"image/png\")}else if(\"JSON\"===E)if(V)Z=new Float32Array(la),F.viewport(0,0,U,W),S.l(!0,!0),F.readPixels(0,0,U,W,F.RGBA,F.FLOAT,Z);else{for(Z=0;4>Z;++Z)F.viewport(0,W*Z,U,W),I.ec(\"u8\",K[Z]),S.l(!Z,!Z);ea.bc();Z=Array(la);for(V=0;V<la;++V)Z[4*V]=qa[0][V],Z[4*V+1]=qa[1][V],Z[4*V+2]=qa[2][V],Z[4*V+3]=qa[3][V]}return{format:E,data:Z,width:U,height:W,isMirrorY:x.isMirrorY,isFlipY:\"RGBA\"===E?x.isFlipY:!x.isFlipY}}};x.isMipmap&&!za&&Fa&&!Ma&&(ea.Cb(),\nMa=!0);if(x.url)a(na),F.texImage2D(F.TEXTURE_2D,0,F.RGBA,1,1,0,F.RGBA,F.UNSIGNED_BYTE,null),ya=new Image,ya.Zf=\"Anonymous\",ya.crossOrigin=\"Anonymous\",ya.src=x.url,ya.onload=function(){U=ya.width;W=ya.height;R()};else if(x.C){var Za=function(){C();U?R():setTimeout(Za,1)};Za()}else x.array?(x.G&&!x.isFloat?x.array instanceof Uint16Array?(oa=x.array,R()):l()?(oa=e(x.array),R()):(R(),N.Lc(F,na,ea.A(),ea.J(),x.array,sa,!0)):(oa=x.isFloat?x.array instanceof Float32Array?x.array:new Float32Array(x.array):\nx.array instanceof Uint8Array?x.array:new Uint8Array(x.array),R()),x.isKeepArray||(oa&&oa!==x.array&&(oa=null),delete x.array)):x.Sc?Fa=!0:R();ea.pg=ea.A;x.fa&&Fa&&(x.fa(ea),x.fa=null);m.push(ea);return ea},M:function(g){g!==n&&(F.activeTexture(r[g]),n=g);v[g]=-1;a(null)},Tf:function(g){A.random.g(g)},nc:function(){D=null;F.framebufferTexture2D(Sa.Ra(),F.COLOR_ATTACHMENT0,F.TEXTURE_2D,null,0)},reset:function(){0!==n&&F.activeTexture(r[0]);for(var g=0;g<r.length;++g)v[g]=-1;n=-1},Dg:function(){n=-1},\nIf:function(){for(var g=0;g<r.length;++g)N.M(g)},Oc:function(){A&&(A.random.remove(),A.Nd.remove())},Pg:function(g,C){if(\"RGBA\"===g.format||\"RGBE\"===g.format){var M=new Image;M.src=g.data;M.onload=function(){N.instance({isMirrorY:g.isMirrorY,isFlipY:g.isFlipY,isFloat:!1,C:M,fa:function(R){if(\"RGBA\"===g.format)C(R);else{var ba=g.width,ca=g.height,Y=N.instance({isMirrorY:g.isMirrorY,isFloat:!0,width:ba,height:ca,isFlipY:g.isFlipY});Sa.Y();F.viewport(0,0,ba,ca);I.set(\"s43\");Y.u();R.g(0);S.l(!0,!0);N.M(0);\nC(Y);F.flush();setTimeout(R.remove,50)}}})}}else\"JSON\"===g.format?C(N.instance({isFloat:!0,isFlipY:g.isFlipY,width:g.width,height:g.height,array:new Float32Array(g.data)})):C(!1)},ie:e,m:function(){D&&(Sa.Y(),N.nc(),Sa.M());N.If();m.slice(0).forEach(function(g){g.remove()});m.splice(0);k=!1;h=0;\"undefined\"!==typeof Qa&&Qa.m();A=null}};return N}(),Va={instance:function(a){var c=[T.instance(a),T.instance(a)],e=[c[1],c[0]],l=e,q={Gd:function(p){l[1].u();l[0].g(p);q.Kd()},Fg:function(p){l[1].R();l[0].g(p);\nq.Kd()},Kd:function(){l=l===c?e:c},refresh:function(){l[0].refresh();l[1].refresh()},g:function(p){l[0].g(p)},Sf:function(p){l[1].g(p)},Ie:function(){return l[0]},ng:function(){return l[1]},remove:function(){l[0].remove();l[1].remove();l=null}};return q}},S=function(){function a(h){var v={X:null,F:null};v.X=h.createBuffer();h.bindBuffer(h.ARRAY_BUFFER,v.X);h.bufferData(h.ARRAY_BUFFER,new Float32Array([-1,-1,3,-1,-1,3]),h.STATIC_DRAW);v.F=h.createBuffer();h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,v.F);h.bufferData(h.ELEMENT_ARRAY_BUFFER,\nnew Uint16Array([0,1,2]),h.STATIC_DRAW);return v}var c=null,e=0,l=!1,q=[],p=-2,n=-2,r={reset:function(){n=p=-2},s:function(){l||(c=a(F),r.ub(),l=!0)},instance:function(h){var v=e++,A=h.F?h.F.length:0,D=\"undefined\"===typeof h.mode?F.STATIC_DRAW:h.mode,f=F.createBuffer();F.bindBuffer(F.ARRAY_BUFFER,f);F.bufferData(F.ARRAY_BUFFER,h.X instanceof Float32Array?h.X:new Float32Array(h.X),D);p=v;var t=null,w=null,k=null;if(h.F){t=F.createBuffer();F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,t);var m=null;65536>h.F.length?\n(m=Uint16Array,w=F.UNSIGNED_SHORT,k=2):(m=Uint32Array,w=F.UNSIGNED_INT,k=4);m=h.F instanceof m?h.F:new m(h.F);F.bufferData(F.ELEMENT_ARRAY_BUFFER,m,D);n=v}var J={ce:function(H){p!==v&&(F.bindBuffer(F.ARRAY_BUFFER,f),p=v);H&&Pa.fc()},$d:function(){n!==v&&(F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,t),n=v)},bind:function(H){J.ce(H);J.$d()},$f:function(){F.drawElements(F.TRIANGLES,A,w,0)},ag:function(H,Q){F.drawElements(F.TRIANGLES,H,w,Q*k)},remove:function(){F.deleteBuffer(f);h.F&&F.deleteBuffer(t);J=null}};\nq.push(J);return J},ub:function(){-1!==p&&(F.bindBuffer(F.ARRAY_BUFFER,c.X),p=-1);-1!==n&&(F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,c.F),n=-1)},l:function(h,v){h&&S.ub();v&&Pa.hb();F.drawElements(F.TRIANGLES,3,F.UNSIGNED_SHORT,0)},Na:function(h){h=h||F;var v=a(h);h.bindBuffer(h.ARRAY_BUFFER,v.X);h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,v.F);Pa.ib(h);h.clear(h.COLOR_BUFFER_BIT);h.drawElements(h.TRIANGLES,3,h.UNSIGNED_SHORT,0);h.flush();h.bindBuffer(h.ARRAY_BUFFER,null);h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,null);\nh.deleteBuffer(v.X);h.deleteBuffer(v.F);r.reset();l&&(r.ub(),Pa.hb())},Oc:function(){var h=F,v=c;h.deleteBuffer(v.X);h.deleteBuffer(v.F)},m:function(){r.Oc();q.forEach(function(h){h.remove()});F.bindBuffer(F.ARRAY_BUFFER,null);F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,null);r.reset();l=!1;q.splice(0);e=0}};return r}(),Sa=function(){var a=null,c=null,e=null,l=!1,q=[],p={D:-2,Kc:1},n={Za:function(){return l},s:function(){if(!l){a=F.createFramebuffer();var r=Ra.aa();c=r&&F.DRAW_FRAMEBUFFER?F.DRAW_FRAMEBUFFER:\nF.FRAMEBUFFER;e=r&&F.READ_FRAMEBUFFER?F.READ_FRAMEBUFFER:F.FRAMEBUFFER;l=!0}},kg:function(){return c},Ge:function(){return e},Ra:function(){return F.FRAMEBUFFER},og:function(){return p},dg:function(){return a},instance:function(r){void 0===r.$c&&(r.$c=!1);var h=r.ra?r.ra:null,v=r.width,A=void 0!==r.height?r.height:r.width,D=a,f=null,t=!1,w=!1,k=0;h&&(v=v?v:h.A(),A=A?A:h.J());var m={Fd:function(){t||(D=F.createFramebuffer(),t=!0,k=p.Kc++)},Vd:function(){m.Fd();m.u();f=F.createRenderbuffer();F.bindRenderbuffer(F.RENDERBUFFER,\nf);F.renderbufferStorage(F.RENDERBUFFER,F.DEPTH_COMPONENT16,v,A);F.framebufferRenderbuffer(c,F.DEPTH_ATTACHMENT,F.RENDERBUFFER,f);F.clearDepth(1)},bind:function(J,H){k!==p.D&&(F.bindFramebuffer(c,D),p.D=k);h&&h.u();H&&F.viewport(0,0,v,A);J&&F.clear(F.COLOR_BUFFER_BIT|F.DEPTH_BUFFER_BIT)},Rf:function(){k!==p.D&&(F.bindFramebuffer(c,D),p.D=k)},clear:function(){F.clear(F.COLOR_BUFFER_BIT|F.DEPTH_BUFFER_BIT)},Xf:function(){F.clear(F.COLOR_BUFFER_BIT)},Yf:function(){F.clear(F.DEPTH_BUFFER_BIT)},Df:function(){F.viewport(0,\n0,v,A)},u:function(){k!==p.D&&(F.bindFramebuffer(c,D),p.D=k)},rtt:function(J){h=J;p.D!==k&&(F.bindFramebuffer(F.FRAMEBUFFER,D),p.D=k);J.u()},M:function(){F.bindFramebuffer(c,null);p.D=-1},resize:function(J,H){v=J;A=H;f&&(F.bindRenderbuffer(F.RENDERBUFFER,f),F.renderbufferStorage(F.RENDERBUFFER,F.DEPTH_COMPONENT16,v,A))},remove:function(){D===a||w||(F.bindFramebuffer(c,D),F.framebufferTexture2D(c,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,null,0),f&&F.framebufferRenderbuffer(c,F.DEPTH_ATTACHMENT,F.RENDERBUFFER,\nnull),F.bindFramebuffer(c,null),F.deleteFramebuffer(D),f&&F.deleteRenderbuffer(f));w=!0}};r.$c&&m.Vd();q.push(m);return m},M:function(){F.bindFramebuffer(c,null);p.D=-1},Jf:function(){F.bindFramebuffer(c,null);F.clear(F.COLOR_BUFFER_BIT|F.DEPTH_BUFFER_BIT);F.viewport(0,0,Ra.A(),Ra.J());p.D=-1},reset:function(){p.D=-2},Y:function(){0!==p.D&&(F.bindFramebuffer(c,a),p.D=0)},clear:function(){F.viewport(0,0,Ra.A(),Ra.J());F.clear(F.COLOR_BUFFER_BIT)},m:function(){n.M();q.forEach(function(r){r.remove()});\nnull!==a&&(F.deleteFramebuffer(a),a=null);n.reset();l=!1;q.splice(0);p.Kc=1}};return n}(),Ra=function(){function a(){l=\"undefined\"===typeof Ta?JEContext:Ta;q=!0}function c(k,m){for(var J=0;J<k.length;++J){var H=m.getExtension(k[J]);if(H)return H}return null}function e(){null!==f.mb&&(clearInterval(f.mb),f.mb=null);f.xa=!1}var l=null,q=!1,p={ad:!1,ic:null,jc:null,dd:!1,Ye:!1,kc:null,ed:!1,lc:null,bd:!1,wb:null,Se:!1,xb:null,Te:!1},n=null,r={Z:!0,$:!0,Bb:!0,xd:!1},h=null,v=!0,A=null,D=null,f={xa:!1,\nma:null,Va:null,Gb:-1,S:null,mb:null},t=\"undefined\"===typeof window?{}:window,w={s:function(){if(q)return!0;w.reset();q||a();var k=F;if(!n.ad){n.ic=w.Hc(k);t.GL_EXT_FLOAT=n.ic;n.dd=n.ic?!0:!1;if(n.dd||w.aa())n.jc=w.Ic(k),n.Ye=n.jc?!0:!1,t.GL_EXT_FLOATLINEAR=n.jc;n.ad=!0}if(!n.bd){n.kc=w.La(k);n.kc&&(n.ed=!0,t.GL_EXT_HALFFLOAT=n.kc);if(n.ed||w.aa())n.lc=w.Jc(k),t.GL_EXT_HALFFLOATLINEAR=n.lc;n.ug=n.lc?!0:!1;n.bd=!0}n.wb=w.Fc(k);n.Se=n.wb?!0:!1;t.GL_EXT_COLORBUFFERFLOAT=n.wb;n.xb=w.Gc(k);n.Te=n.xb?!0:\n!1;t.GL_EXT_COLORBUFFERHALFFLOAT=n.xb;Sa.s();T.s();if(!w.pe())return!1;S.s();T.Pe();return!0},reset:function(){n=Object.assign({},p);h=Object.assign({},r)},A:function(){q||a();return l.A()},J:function(){q||a();return l.J()},aa:function(){q||a();return l.aa()},Ec:function(k){w.Fc(k);w.Gc(k);w.Hc(k);w.Ic(k);w.La(k);w.Jc(k)},Fc:c.bind(null,[\"EXT_color_buffer_float\",\"WEBGL_color_buffer_float\",\"OES_color_buffer_float\"]),Gc:c.bind(null,[\"EXT_color_buffer_half_float\",\"WEBGL_color_buffer_half_float\",\"OES_color_buffer_half_float\"]),\nHc:c.bind(null,[\"OES_texture_float\",\"MOZ_OES_texture_float\",\"WEBKIT_OES_texture_float\"]),Ic:c.bind(null,[\"OES_texture_float_linear\",\"MOZ_OES_texture_float_linear\",\"WEBKIT_OES_texture_float_linear\"]),La:c.bind(null,[\"OES_texture_half_float\",\"MOZ_OES_texture_half_float\",\"WEBKIT_OES_texture_half_float\"]),Jc:c.bind(null,[\"OES_texture_half_float_linear\",\"MOZ_OES_texture_half_float_linear\",\"WEBKIT_OES_texture_half_float_linear\"]),Db:function(k){var m=w.La(k);return m&&m.HALF_FLOAT_OES?m.HALF_FLOAT_OES:\nk.HALF_FLOAT||k.FLOAT},De:function(){return D||F.RGBA32F||F.RGBA},Ee:function(){return A||F.RGBA16F||F.RGBA},Ae:function(){return h},Cc:function(){return h.Z},Wf:function(){return h.$},Vf:function(){return h.Bb},ee:function(){return h.xd&&v},Md:function(k){v=k;!k&&f.xa&&(F.deleteSync(f.Va),F.bindBuffer(f.S,null),f.xa=!1)},kb:function(k,m,J){function H(){k.bindTexture(k.TEXTURE_2D,null);k.bindFramebuffer(Q,null);k.deleteTexture(P);k.deleteFramebuffer(K)}var Q=k.FRAMEBUFFER,y=k.NEAREST,K=k.createFramebuffer();\nk.bindFramebuffer(Q,K);var P=k.createTexture();k.activeTexture(k.TEXTURE0);k.bindTexture(k.TEXTURE_2D,P);k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL,!1);k.texParameteri(k.TEXTURE_2D,k.TEXTURE_WRAP_S,k.CLAMP_TO_EDGE);k.texParameteri(k.TEXTURE_2D,k.TEXTURE_WRAP_T,k.CLAMP_TO_EDGE);k.texParameteri(k.TEXTURE_2D,k.TEXTURE_MAG_FILTER,y);k.texParameteri(k.TEXTURE_2D,k.TEXTURE_MIN_FILTER,y);k.texImage2D(k.TEXTURE_2D,0,m,3,3,0,k.RGBA,J,null);k.framebufferTexture2D(k.FRAMEBUFFER,k.COLOR_ATTACHMENT0,k.TEXTURE_2D,P,0);\nif(k.checkFramebufferStatus(k.READ_FRAMEBUFFER||k.FRAMEBUFFER)!==k.FRAMEBUFFER_COMPLETE)return H(),!1;Pa.dc(k);k.clearColor(0,0,0,0);k.viewport(0,0,3,3);k.disable(k.DEPTH_TEST);k.clear(k.COLOR_BUFFER_BIT);S.Na(k);k.bindFramebuffer(Q,null);Pa.Aa(k);k.activeTexture(k.TEXTURE0);k.bindTexture(k.TEXTURE_2D,P);S.Na(k);m=new Uint8Array(36);k.readPixels(0,0,3,3,k.RGBA,k.UNSIGNED_BYTE,m);H();for(J=0;36>J;++J)if(3!==J%4&&3<Math.abs(m[J]-127))return!1;return!0},zb:function(k){var m={Z:!1,$:!1};k.disable(k.BLEND);\nk.clearColor(0,0,0,0);k.clear(k.COLOR_BUFFER_BIT);k.RGBA32F&&w.kb(k,k.RGBA32F,k.FLOAT)&&(m.Z=!0,D=k.RGBA32F);!m.Z&&w.kb(k,k.RGBA,k.FLOAT)&&(m.Z=!0,D=k.RGBA);var J=w.Db(k);A=null;k.RGBA16F&&w.kb(k,k.RGBA16F,J)&&(m.$=!0,A=k.RGBA16F);!m.$&&w.kb(k,k.RGBA,J)&&(m.$=!0,A=k.RGBA);return m},qe:function(){var k=Sa.instance({width:2});k.Fd();var m=T.instance({width:2,isFloat:!0,bb:3});k.u();m.u();F.flush();F.checkFramebufferStatus(Sa.Ge())!==F.FRAMEBUFFER_COMPLETE?(T.Af(),h.Bb=!1):h.Bb=!0;k.remove();m.remove()},\nre:function(){var k=!1;w.aa()&&(k=\"PIXEL_PACK_BUFFER STREAM_READ SYNC_GPU_COMMANDS_COMPLETE WAIT_FAILED fenceSync deleteSync createBuffer\".split(\" \").every(function(m){return\"undefined\"!==typeof F[m]}));h.xd=k},pe:function(){var k=w.zb(F);Object.assign(h,k);if(!h.Z&&!h.$)return!1;w.qe();w.re();return!0},cc:function(k,m,J,H,Q){if(!w.ee())return F.readPixels(k,m,J,H,F.RGBA,F.UNSIGNED_BYTE,Q),Promise.resolve(Q);null===f.ma&&(f.S=F.PIXEL_PACK_BUFFER,f.ma=F.createBuffer(),f.Gb=-1);F.bindBuffer(f.S,f.ma);\nQ.byteLength!==f.Gb&&(F.bufferData(f.S,Q.byteLength,F.STREAM_READ),f.Gb=Q.byteLength);F.readPixels(k,m,J,H,F.RGBA,F.UNSIGNED_BYTE,0);f.Va=F.fenceSync(F.SYNC_GPU_COMMANDS_COMPLETE,0);F.flush();return new Promise(function(y,K){function P(){if(!f.xa)return e(),K(),!1;switch(F.clientWaitSync(f.Va,0,0)){case F.TIMEOUT_EXPIRED:case F.WAIT_FAILED:return!1;default:return e(),F.deleteSync(f.Va),F.getBufferSubData(f.S,0,Q),F.bindBuffer(f.S,null),y(Q),!0}}e();f.xa=!0;P()||(f.mb=setInterval(P,0))})},m:function(){e();\nT.m();Sa.m();S.m();null!==f.ma&&(F.deleteBuffer(f.ma),f.ma=null);Pa.reset();q=!1}};return w}(),Qa=function(){function a(K,P,u,d){m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,d?m.NEAREST_MIPMAP_NEAREST:m.LINEAR);var z=null;if(null!==u)try{z=m.getError();if(\"FUCKING_BIG_ERROR\"===z)return!1;m.texImage2D(m.TEXTURE_2D,0,K,4,4,0,m.RGBA,P,u);z=m.getError();if(z!==m.NO_ERROR)return!1}catch(G){return!1}d&&m.generateMipmap(m.TEXTURE_2D);m.clear(m.COLOR_BUFFER_BIT);S.Na(m);z=m.getError();if(\"FUCKING_BIG_ERROR\"===\nz)return!1;m.readPixels(0,0,2,2,m.RGBA,m.UNSIGNED_BYTE,A);z=m.getError();z===m.INVALID_OPERATION&&\"undefined\"!==typeof m.PIXEL_PACK_BUFFER&&(m.bindBuffer(m.PIXEL_PACK_BUFFER,null),m.readPixels(0,0,2,2,m.RGBA,m.UNSIGNED_BYTE,A),z=m.getError());if(z!==m.NO_ERROR)return!1;u=!0;for(d=0;16>d;++d)u=u&&4>Math.abs(A[d]-127);u&&(h.qd=P,h.Zc=K);return u}function c(K,P){return J.Z&&a(K,m.FLOAT,new Float32Array(D),P)?(r=n.uc,!0):!1}function e(K,P,u){if(!J.$)return!1;var d=T.ie(D),z=Ra.La(m);if(z&&z.HALF_FLOAT_OES&&\na(K,z.HALF_FLOAT_OES,d,P)||m.HALF_FLOAT&&a(K,m.HALF_FLOAT,d,P))return r=n.ta,!0;d=new Float32Array(D);if(a(K,m.FLOAT,d,P))return r=n.ta,!0;m.bindTexture(m.TEXTURE_2D,u);m.texImage2D(m.TEXTURE_2D,0,m.RGBA,2,2,0,m.RGBA,m.UNSIGNED_BYTE,null);m.bindFramebuffer(h.Ja,y);T.Lc(m,u,2,2,d,!1,!1);m.bindFramebuffer(h.Ja,null);m.bindTexture(m.TEXTURE_2D,u);return a(K,null,null,P)?(r=n.ta,!0):!1}function l(K,P,u){v=!0;if(e(K,!0,u)||c(P,!0))return!0;v=!1;return e(K,!1,u)||c(P,!1)?!0:!1}function q(K){if(r===n.N){m=\nK||F;r=n.RGBA8;v=!0;Ra.Ec(m);J||(J=Ra.zb(m));Sa.reset();y=m.createFramebuffer();h.Ja=m.DRAW_FRAMEBUFFER||m.FRAMEBUFFER;m.bindFramebuffer(h.Ja,null);m.clearColor(0,0,0,0);m.viewport(0,0,2,2);I.N();H=I.Aa(m);K=m.createTexture();m.activeTexture(m.TEXTURE0);m.bindTexture(m.TEXTURE_2D,K);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,m.REPEAT);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,m.REPEAT);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST);Q=K;var P=K=m.RGBA,u=m.RGBA16F,d=m.RGBA32F;d&&\n(K=d);u&&(P=u);if((u||d)&&l(P,K,Q))return p(),!0;K=P=m.RGBA;if(l(P,K,Q))return p(),!0;r=n.RGBA8;p();return!1}}function p(){m.deleteProgram(H.ha);m.deleteTexture(Q);Q=H=null}for(var n={N:-1,uc:3,ta:2,RGBA8:0},r=n.N,h={qd:null,Zc:null,Ja:null},v=!0,A=new Uint8Array(16),D=Array(64),f=0;4>f;++f)for(var t=0;4>t;++t){var w=0===(t+f)%2?1:0,k=4*f+t;D[4*k]=w;D[4*k+1]=w;D[4*k+2]=w;D[4*k+3]=w}var m=null,J=null,H=null,Q=null,y=null;return{de:function(K){q(K);return v},Bc:function(K,P){r===n.N&&(typeof(\"undefined\"!==\nP)&&(J=P),q(K));return r!==n.RGBA8},xg:function(K){q(K);return r===n.uc},Ze:function(K){q(K);return r===n.ta},lg:function(K){q(K);return h.qd},Fe:function(K){q(K);return h.Zc},m:function(){m=null;v=!0;r=n.N;J=null}}}(),Wa={instance:function(a){var c=T.instance(a.alpha),e=T.instance(a.beta);return{te:function(){c.g(1);e.g(2)}}}},ab={instance:function(a){var c=null,e=!1,l=!1,q=null,p=!1,n=!1,r=null,h=\"undefined\"===typeof a.preprocessing?!1:a.preprocessing,v=\"undefined\"===typeof a.preprocessingSize?\na.size:a.preprocessingSize;a.mask&&(e=!0,b&&void 0!==b.Zd&&(a.mask=b.Zd+a.mask),c=T.instance({isFloat:!1,url:a.mask}));var A=!1;a.customInputShader&&(A=\"s44\",I.vc({name:\"_\",id:A,h:a.customInputShader,Og:[\"uSource\"],precision:\"lowp\"}),I.I(A,[{type:\"1i\",name:\"_\",value:0}]));switch(h){case \"sobel\":r=\"s31\";p=!0;break;case \"meanNormalization\":r=\"s32\";p=!0;break;case \"grayScale\":r=\"s28\";p=!1;break;case \"grayScaleTilt\":r=\"s29\";n=!0;p=!1;break;case \"rgbGrayTilt\":r=\"s30\";n=!0;p=!1;break;case \"copy\":r=A?A:\n\"s0\";break;case \"inputLightRegulation\":r=A?A:\"s28\";q=Xa.instance({Yc:v,pd:a.size,md:a.nBlurPass,Ya:!1});l=!0;break;case \"inputMix0\":r=\"none\";q=$a.instance({ka:v,Pd:a.varianceMin,Ac:a.blurKernelSizePx,Ya:!1});l=!0;break;case \"direct\":case \"none\":r=\"abort\";break;default:r=\"s3\"}n&&I.I(r,[{name:\"u26\",type:\"1f\",value:a.tilt}]);e&&(r+=\"Mask\");var D=T.instance({isFloat:!1,isPot:!1,width:a.size}),f={A:function(){return v},Eb:function(){return f.A()},Me:function(){return l?q.Fb():D},K:function(t){Sa.Y();\"abort\"!==\nr&&(\"none\"!==r&&(I.set(r),p&&I.L(\"u27\",1/a.size),D.R(),e&&c.g(1),S.l(!1,!1),D.g(0),t=D),l&&q.process(t))},m:function(){D.remove();e&&c.remove()}};return f}},gb={instance:function(a){function c(g){q.forEach(function(C,M){p[M][0]=g[0][C];p[M][1]=g[1][C];p[M][2]=g[2][C];p[M][3]=g[3][C]});return p}\"undefined\"===typeof a.normalize&&(a.normalize=!1);var e={input:null,Ha:null,Kb:null,W:null,cb:null,Zb:null,$b:null},l=null,q=[],p=[],n=!1,r=null,h=!0,v=-1,A=a.isReorganize?a.isReorganize:!1,D=a.kernelsCount?\n!0:!1,f=a.dynPelu?Wa.instance(a.dynPelu):!1,t=f?!0:!1,w={isEnabled:!1};a.Xe?(a.sparsity=\"undefined\"!==typeof a.sparsity?a.sparsity:a.fb.Eb(),h=!1):\"full\"===a.connectivityUp&&(a.sparsity=a.fb.Eb());var k={elu:\"s15\",elu01:\"s16\",relu:\"s14\",arctan:\"s18\",sigmoid:\"s13\",copy:\"s0\",softplus:\"s19\",dynPelu:\"s17\"}[a.activation],m=a.sparsity*a.sparsity,J=!1,H=a.size,Q=\"\";if(a.maxPooling){switch(a.maxPooling.size){case 2:Q=\"s33\";break;case 4:Q=\"s34\"}J=!0;H/=a.maxPooling.size;e.Zb=T.instance({isFloat:!0,isPot:!1,\nwidth:H})}var y=void 0!==a.df&&a.df?!0:!1,K=null,P=null,u=null;if(y){K=\"s45\"+a.index.toString();I.Wc(\"s45\",K,[((a.normalization.n-1)/2).toFixed(1)]);I.I(K,[{type:\"1i\",name:\"u1\",value:0},{type:\"2f\",name:\"u7\",value:[1/a.size,1/a.size]},{type:\"1f\",name:\"u6\",value:a.normalization.alpha},{type:\"1f\",name:\"u9\",value:a.normalization.beta},{type:\"1f\",name:\"u30\",value:a.normalization.k}]);var d={isFloat:!0,isPot:!0,width:a.size};P=T.instance(d);u=T.instance(d)}var z=-1,G=null;h&&(e.W=T.instance({isFloat:!0,\nisPot:!1,width:a.size}));e.Ha=T.instance(a.bias);var N={A:function(){return a.size},Eb:function(){return H},Pc:function(){return a.classesCount},ae:function(g){l.g(g)},hf:function(){a.remap&&a.remap.isEnabled&&(w={isEnabled:!0,$e:T.instance({isFloat:!1,isFlipY:!1,array:new Uint8Array(a.remap.maskTexture.data),width:a.remap.maskTexture.width,isPot:!1}),ab:a.remap.layers.map(function(g){return a.parent.Je(g)}),depth:a.remap.depth})},Bf:function(){switch(a.connectivityUp){case \"direct\":G=bb.instance(a.connectivity);\nbreak;case \"square\":G=cb.instance(a.connectivity);break;case \"squareFast\":G=db.instance(a.connectivity,a.activation);break;case \"full\":G=eb.instance(a.connectivity);break;case \"conv\":v=a.kernelsCount,G=fb.instance(a.connectivity),A&&(e.cb=T.instance({width:H,isFloat:!0,isFlipY:!1,isPot:!1}))}if(G.qa){var g=a.size*a.sparsity;z=Math.log(g/a.size)/Math.log(2);e.input=T.instance({isMipmap:!0,isFloat:!0,isPot:!0,width:g,Sb:z});e.Kb=T.instance({isFloat:!0,isPot:!0,width:a.size})}},K:function(g,C){l=g;G.qa?\n(e.input.R(),D&&e.Ha.g(2),G.K(w),e.input.g(0),e.input.ze(z),e.Kb.R(),D?I.set(\"s0\"):(I.set(\"s27\"),I.L(\"u25\",m),e.Ha.g(1)),e.input.be(z,0),S.l(!1,!1),I.set(k),y?P.u():e.W.u(),e.Kb.g(0),t&&f.te(),S.l(!1,!1)):(e.W.R(),e.Ha.g(1),G.K());y&&(I.set(K),u.u(),P.g(0),S.l(!1,!1),I.set(\"s46\"),I.L(\"u6\",1),e.W.u(),u.g(1),S.l(!1,!1));if(h)return J?(e.Zb.R(),e.W.g(0),I.set(Q),I.ia(\"u7\",1/a.size,1/a.size),S.l(!1,!1),C=e.Zb):C=e.W,C.g(0),A&&(e.cb.u(),I.set(\"s21\"),I.ia(\"u12\",v,H/v),S.l(!1,!1),C=e.cb,e.cb.g(0)),C;var M=\ne.W;a.normalize&&(I.set(\"gpuRawAvg\"===n?\"s8\":\"s7\"),I.L(\"u4\",1/a.size),e.$b.R(),e.W.g(0),S.l(!1,!1),M=e.$b);g=null;switch(n){case \"cpuRGBA2Float\":M.Ab(!1);C?g=N.kf(M).then(r):(M=N.lf(M),r(M));break;case \"cpuMeanFloat\":M.Ab(!0);C?g=M.pf().then(r):(M=M.qf(),r(M));break;case \"gpuRawAvg\":case \"gpuRaw\":M.g(0);case \"none\":null!==r&&r(M)}C&&null===g&&(g=Promise.resolve());return g},je:function(g){g&&(n=g.ac||\"none\",r=g.Yb||null);e.W=T.instance({isFloat:!0,isPot:!0,isMipmap:!1,width:a.size});g=\"undefined\"!==\ntypeof a.classesCount&&a.classesCount?a.classesCount:a.size*a.size;for(var C=0,M=0,R=0;C<g;++C)q.push(M+(a.size-1-R)*a.size),p.push([-1,-1,-1,-1]),++M,M===a.size&&(M=0,++R);a.normalize&&(e.$b=T.instance({isFloat:!0,isPot:!0,width:a.size}))},kf:function(g){return g.mf().then(c)},lf:function(g){g=g.bc();c(g);return p},m:function(){for(var g in e){var C=e[g];C&&C.remove()}G&&(G.m(),G=null)}};a.fb&&N.Bf(a.fb);return N}};\nfunction hb(a){var c=null,e=null,l=null,q=0;this.s=function(p){this.zf(p.ab);l.je({ac:p.ac,Yb:p.Yb})};this.Je=function(p){return c[p]};this.zf=function(p){var n=null;q=p.length;c=p.map(function(r,h){r=Object.assign({},r,{index:h,parent:this,fb:n,Xe:h===q-1});return n=h=0===h?ab.instance(r):gb.instance(r)});e=c[0];l=c[q-1];c.forEach(function(r,h){0!==h&&r.hf()})};this.K=function(p){var n=p;c.forEach(function(r){n=r.K(n,!1)});return n};this.He=function(){return e.A()};this.Ne=function(){return l.A()};\nthis.Fb=function(){return l.Me()};this.Pc=function(){return l.Pc()};this.m=function(){c&&(c.forEach(function(p){p.m()}),l=e=c=null,q=0)};\"undefined\"!==typeof a&&this.s(a)}\nvar bb={instance:function(a){var c=T.instance(a.weights);return{qa:!0,Qa:function(){return 1},m:function(){c.remove()},Oe:function(){return c},K:function(){I.set(\"s26\");c.g(1);S.l(!1,!1)}}}},eb={instance:function(a){var c=a.fromLayerSize,e=T.instance(a.weights);return{qa:!0,Qa:function(){return c},m:function(){e.remove()},K:function(l){if(l.isEnabled){I.set(\"s24\");l.$e.g(3);var q,p=Math.min(l.ab.length,l.depth);for(q=0;q<p;++q)l.ab[q].ae(4+q)}else I.set(\"s23\");I.L(\"u16\",a.toLayerSize);e.g(1);S.l(!1,\n!1)}}}},cb={instance:function(a){for(var c=a.fromLayerSize,e=a.toLayerSize,l=a.toSparsity,q=l*e,p=q/c,n=c/e,r=0,h=0,v=0,A=Array(l*e*l*e*4),D=Array(l*e*l*e*4),f=Array(c*c),t=0;t<f.length;++t)f[t]=0;t=Math.floor(l/2);for(var w=.5/e,k=.5/c,m=.5/q,J=0;J<e;++J)for(var H=Math.round(J*n),Q=0;Q<e;++Q){var y=Math.round(Q*n),K=J/e,P=Q/e;K+=w;P+=w;for(var u=0;u<l;++u){var d=H+u-t;0>d&&(d+=c);d>=c&&(d-=c);for(var z=0;z<l;++z){var G=r/q,N=h/q,g=y+z-t;0>g&&(g+=c);g>=c&&(g-=c);var C=d/c,M=g/c;N=1-N-1/q;C+=k;M+=\nk;G+=m;N+=m;var R=J*l+u,ba=Q*l+z;ba=e*l-ba-1;R=ba*e*l+R;A[4*R]=G;A[4*R+1]=N;A[4*R+2]=C;A[4*R+3]=M;M=f[g*c+d]++;R=M%p;C=d*p+R;g=g*p+(M-R)/p;g=c*p-1-g;g=g*c*p+C;D[4*g]=G;D[4*g+1]=N;D[4*g+2]=K;D[4*g+3]=P;++r>=q&&(r=0,++h);++v}}}f=null;var ca=T.instance(a.weights);delete a.weights.data;var Y=T.instance({width:q,isFloat:!0,array:new Float32Array(D),isPot:!0});D=null;var x=T.instance({width:q,isFloat:!0,array:new Float32Array(A),isPot:!0});A=null;return{qa:!0,Qa:function(){return p},m:function(){Y.remove();\nx.remove();ca.remove()},K:function(){I.set(\"s22\");ca.g(1);x.g(2);S.l(!1,!1)}}}},fb={instance:function(a){var c=a.kernelsCount,e=a.toSparsity,l=e*a.toLayerSize/a.fromLayerSize,q=T.instance(a.weights);return{qa:!0,Qa:function(){return l},rg:function(){return e},Oe:function(){return q},m:function(){q.remove()},K:function(){I.set(\"s25\");I.L(\"u22\",c);I.L(\"u23\",e);I.L(\"u16\",a.toLayerSize);I.L(\"u24\",a.fromLayerSize);q.g(1);S.l(!1,!1)}}}},db={instance:function(a,c){var e=a.fromLayerSize,l=a.toLayerSize,q=\na.toSparsity,p=a.stride?a.stride:1,n=q*l/e,r=l<e,h=e/l,v=T.instance(a.weights),A=\"s47\"+[e.toString(),l.toString(),q.toString(),p.toString(),c].join(\"_\");I.xe(A)||(a=Ja(c),l=[{type:\"1f\",name:\"u16\",value:l},{type:\"1f\",name:\"u29\",value:p}],r&&l.push({type:\"1f\",name:\"u24\",value:e}),e=[(r?n:q).toFixed(1),a],r&&e.push(h.toFixed(1)),I.Wc(r?\"s39\":\"s38\",A,e),I.I(A,l.concat([{type:\"1i\",name:\"u14\",value:0},{type:\"1i\",name:\"u21\",value:1},{type:\"1i\",name:\"u13\",value:3}])));return{qa:!1,Qa:function(){return n},\nm:function(){v.remove()},K:function(){I.set(A);v.g(3);S.l(!1,!1)}}}},Xa={instance:function(a){var c=a.md?a.md:3,e=a.Yc?a.Yc:64,l=a.pd?a.pd:64,q=a.Ya?!0:!1;a={isFloat:!1,width:e,isPot:!1,isFlipY:!1};var p=T.instance(a),n=T.instance(a),r=T.instance(a),h=T.instance(a),v=T.instance({isFloat:!0,width:l,isPot:!1,isFlipY:!1}),A=1/e;return{process:function(D){I.set(\"s35\");h.u();S.l(q,!1);I.set(\"s36\");for(var f=0;f<c;++f)p.u(),I.ia(\"u7\",A,0),S.l(q,!1),r.u(),h.g(0),S.l(q,!1),n.u(),p.g(0),I.ia(\"u7\",0,A),S.l(q,\n!1),h.u(),r.g(0),S.l(q,!1),f!==c-1&&n.g(0);I.set(\"s37\");v.u();D.g(0);n.g(1);h.g(2);S.l(q,!1);v.g(0)},Fb:function(){return v}}}},$a={instance:function(a){function c(v){return T.instance({isFloat:v,width:e.ka,isPot:!1,isFlipY:!1})}var e=Object.assign({Pd:.1,Ac:9,ka:128,Ya:!1},a),l=c(!1),q=[c(!1),c(!1),c(!1)],p=[c(!1),c(!1),c(!1)],n=c(!0),r=[l,p[0],p[1]];a=\"uniform sampler2D u1;const float e=1.1111,g=2.2222;uniform vec2 u31;varying vec2 vv0;void main(){float b=0.,c=0.;for(float a=-e;a<=e;a+=1.){vec2 i=u31*a,j=vv0+i*g;float d=1.2*a/e,f=exp(-d*d);b+=f*texture2D(u1,j).r,c+=f;}b/=c,gl_FragColor=vec4(b,0.,0.,1.);}\".replace(\"1.1111\",\nMath.round((e.Ac-1)/2).toFixed(2)).replace(\"2.2222\",(1/e.ka).toFixed(6));var h={u1:0};I.wc([{id:\"s49\",name:\"_\",h:\"uniform sampler2D u1;varying vec2 vv0;const vec3 f=vec3(.2126,.7152,.0722),g=vec3(1.,1.,1.);void main(){vec3 b=texture2D(u1,vv0).rgb;float a=dot(b,f);gl_FragColor=vec4(a,a,a,a);}\",j:h,i:[\"u1\"],precision:\"lowp\"},{id:\"s50\",name:\"_\",h:a,j:h,i:[\"u1\",\"u31\"],precision:\"lowp\"},{id:\"s51\",name:\"_\",h:\"uniform sampler2D u32,u33,u34,u35;const float f=1.1111;const vec3 g=vec3(1.,1.,1.);varying vec2 vv0;void main(){vec3 a=texture2D(u32,vv0).rgb;float c=texture2D(u33,vv0).r,d=texture2D(u34,vv0).r,h=texture2D(u35,vv0).r,i=a.r*a.r;vec3 b=vec3(c,d,h),j=max(g*f,abs(i-b*b)),k=sqrt(j);gl_FragColor=vec4(a.r,(a-b)/k);}\".replace(\"1.1111\",\ne.Pd.toFixed(4)),j:{u32:0,u33:1,u34:2,u35:3},i:[\"u32\",\"u33\",\"u34\",\"u35\"],precision:\"highp\"}]);return{process:function(){I.set(\"s49\");l.R();S.l(e.Ya,!1);I.set(\"s50\");for(var v=0;3>v;++v)I.ia(\"u31\",1,0),q[v].u(),r[v].g(0),S.l(!1,!1),I.ia(\"u31\",0,1),p[v].u(),q[v].g(0),S.l(!1,!1);I.set(\"s51\");n.u();l.g(0);p[0].g(1);p[1].g(2);p[2].g(3);S.l(!1,!1);n.g(0)},Fb:function(){return n}}}};function ib(a,c){a[c]=!0;a.setAttribute(c,\"true\")}\nfunction jb(){return/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream}function kb(){var a=navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);return a&&a.length&&2<a.length?[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3]||0,10)]:[0,0,0]}function lb(){var a=navigator.userAgent.toLowerCase();return-1!==a.indexOf(\"safari\")&&-1===a.indexOf(\"chrome\")?!0:!1}function mb(){return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?!0:!1}\nfunction nb(a){if(!a)return a;var c=null;if(a.video){var e=function(l){return l&&\"object\"===typeof l?Object.assign({},l):l};c={};\"undefined\"!==typeof a.video.width&&(c.width=e(a.video.width));\"undefined\"!==typeof a.video.height&&(c.height=e(a.video.height));\"undefined\"!==typeof a.video.facingMode&&(c.facingMode=e(a.video.facingMode))}c={audio:a.audio,video:c};\"undefined\"!==typeof a.deviceId&&pb(c,a.deviceId);return c}\nfunction pb(a,c){c&&(a.video=a.video||{},a.video.deviceId={exact:c},a.video.facingMode&&delete a.video.facingMode)}function rb(a){var c=a.video.width;a.video.width=a.video.height;a.video.height=c;return a}\nfunction sb(a){function c(f){return[480,576,640,648,720,768,800,960,1080,1152,1280,1366,1920].sort(function(t,w){return Math.abs(t-f)-Math.abs(w-f)})}function e(f){var t=nb(a);f=f(t);q.push(f);l(f)}function l(f){if(f.video&&f.video.facingMode&&f.video.facingMode.exact){var t=f.video.facingMode.exact;f=nb(f);delete f.video.facingMode.exact;f.video.facingMode.ideal=t;q.push(f)}}var q=[];if(!a||!a.video)return q;l(a);if(a.video.width&&a.video.height){if(a.video.width.ideal&&a.video.height.ideal){var p=\nc(a.video.width.ideal).slice(0,3),n=c(a.video.height.ideal).slice(0,3),r={},h=0;for(r.ea=void 0;h<p.length;r={ea:r.ea},++h){r.ea=p[h];var v={},A=0;for(v.da=void 0;A<n.length;v={da:v.da},++A)if(v.da=n[A],r.ea!==a.video.width.ideal||v.da!==a.video.height.ideal){var D=Math.max(r.ea,v.da)/Math.min(r.ea,v.da);D<4/3-.1||D>16/9+.1||e(function(f,t){return function(w){w.video.width.ideal=f.ea;w.video.height.ideal=t.da;return w}}(r,v))}}}e(function(f){return rb(f)})}a.video.width&&a.video.height&&(a.video.width.ideal&&\na.video.height.ideal&&e(function(f){delete f.video.width.ideal;delete f.video.height.ideal;return f}),e(function(f){delete f.video.width;delete f.video.height;return f}));a.video.facingMode&&(e(function(f){delete f.video.facingMode;return f}),a.video.width&&a.video.height&&e(function(f){rb(f);delete f.video.facingMode;return f}));q.push({audio:a.audio,video:!0});return q}\nfunction tb(a){try{var c=window.matchMedia(\"(orientation: portrait)\").matches?!0:!1}catch(l){c=window.innerHeight>window.innerWidth}if(c&&a&&a.video){c=a.video.width;var e=a.video.height;c&&e&&c.ideal&&e.ideal&&c.ideal>e.ideal&&(a.video.height=c,a.video.width=e)}}\nfunction ub(a){a.volume=0;ib(a,\"muted\");if(lb()){if(1===a.volume){var c=function(){a.volume=0;window.removeEventListener(\"mousemove\",c,!1);window.removeEventListener(\"touchstart\",c,!1)};window.addEventListener(\"mousemove\",c,!1);window.addEventListener(\"touchstart\",c,!1)}setTimeout(function(){a.volume=0;ib(a,\"muted\")},5)}}\nfunction vb(a,c,e,l){function q(n){p||(p=!0,e(n))}var p=!1;navigator.mediaDevices.getUserMedia(l).then(function(n){function r(){setTimeout(function(){if(a.currentTime){var v=a.videoWidth,A=a.videoHeight;if(0===v||0===A)q(\"VIDEO_NULLSIZE\");else{v&&(a.style.width=v.toString()+\"px\");A&&(a.style.height=A.toString()+\"px\");v={fe:null,Ef:null,af:null};try{var D=n.getVideoTracks()[0];D&&(v.af=D,v.fe=D.getCapabilities(),v.Ef=D.getSettings())}catch(f){}lb()||jb()?a.parentNode&&null!==a.parentNode?(p||c(a,n,\nv),setTimeout(function(){a.play()},100)):(document.body.appendChild(a),ub(a),p||c(a,n,v),setTimeout(function(){a.style.transform=\"scale(0.0001,0.0001)\";a.style.position=\"fixed\";a.style.bottom=\"0px\";a.style.right=\"0px\";ub(a);setTimeout(function(){a.play()},100)},80)):p||c(a,n,v)}}else q(\"VIDEO_NOTSTARTED\")},700)}function h(){a.removeEventListener(\"loadeddata\",h,!1);var v=a.play();ub(a);\"undefined\"===typeof v?r():v.then(function(){r()}).catch(function(){q(\"VIDEO_PLAYPROMISEREJECTED\")})}\"undefined\"!==\ntypeof a.srcObject?a.srcObject=n:(a.src=window.URL.createObjectURL(n),a.videoStream=n);ub(a);a.addEventListener(\"loadeddata\",h,!1)}).catch(function(n){q(n)})}\nfunction wb(a,c,e){var l=mb()?document.createElement(\"video\"):!1;if(l)if(mb()){if(e&&e.video){if(jb()){var q=kb();0!==q[0]&&(12>q[0]||12===q[0]&&2>q[1])&&tb(e)}e.video.width&&e.video.width.ideal&&(l.style.width=e.video.width.ideal+\"px\");e.video.height&&e.video.height.ideal&&(l.style.height=e.video.height.ideal+\"px\")}ib(l,\"autoplay\");ib(l,\"playsinline\");e&&e.audio?l.volume=0:ib(l,\"muted\");vb(l,a,function(){function p(r){if(0===r.length)c(\"INVALID_FALLBACKCONSTRAINTS\");else{var h=r.shift();vb(l,a,function(){p(r)},\nh)}}var n=sb(e);p(n)},e)}else c&&c(\"MEDIASTREAMAPI_NOTFOUND\");else c&&c(\"VIDEO_NOTPROVIDED\")}\nvar xb=function(){function a(t,w,k,m,J,H){if(H===J.length)m();else{switch(J[H]){case \"D\":t();break;case \"S\":w().then(function(){f.Ld();a(t,w,k,m,J,++H)}).catch(m);return;case \"R\":k()}a(t,w,k,m,J,++H)}}var c={n:5,Ub:1,kd:0,Oa:[35,49],Ka:[2,200],k:.7,Lf:200,gf:.05},e=-1,l=null,q=-1,p=-1,n=0,r=-1,h=-1,v=0,A=0,D=c.Ka[1],f={Ke:function(){switch(e){case -1:return-1;case 0:return h+l.kd;case 1:return v}},Be:function(t){return Math.pow(Math.min(Math.max(r,0),l.n-1)/(l.n-1),t||1)},s:function(t){l=Object.assign({},\nc,t);r=h=l.Ub;e=0;f.reset()},Ld:function(t){t=(\"undefined\"===typeof t?Date.now():t)||0;var w=Math.min(Math.max(t-A,l.Ka[0]),l.Ka[1]);D=w;A=t;var k=-1===q?0:l.k;q=Math.min(Math.max(1E3/w,5),120)*(1-k)+q*k;t-p>l.Lf&&5<++n&&(w=l.k,r=r*(1-w)+(q<l.Oa[0]?h-1:q>l.Oa[1]?h+1:h)*w,Math.abs(r-h)>1-l.gf&&(w=Math.min(Math.max(Math.round(r),0),l.n-1),w!==h&&(r=h=w,q=(l.Oa[1]-l.Oa[0])/2)),p=t)},zd:function(t,w,k,m,J){a(t,w,k,m,J,0)},yf:function(t){v=t;e=1},Kf:function(){e=0;f.reset()},reset:function(){D=c.Ka[1];\np=q=-1;n=0},ig:function(){return D}};return f}(),yb=function(){var a={nd:4,eb:[1.5,1.5,2],ja:[.1,.1,.1],Bd:1,ka:-1,Hb:-1,Gf:2,ff:1,Dd:!0,ve:.8},c=null,e=[],l=0,q=[.5,.5,1];return{s:function(p){c=Object.assign({},a,p);e.splice(0);p=c.eb[0]*c.ja[0];var n=c.eb[1]*c.ja[1],r=1/(1+c.eb[2]*c.ja[2]),h=c.Bd*Math.min(c.ka,c.Hb),v=h/c.ka;h/=c.Hb;var A=.5*c.ve;A*=A;for(var D=0;D<c.nd;++D){var f=Math.pow(r,D),t=v*f,w=h*f;f=t*p;var k=w*n,m=t/2;w/=2;for(var J=1+(1-m-m)/f,H=1+(1-w-w)/k,Q=0;Q<H;++Q)for(var y=w+Q*\nk,K=y-.5,P=0;P<J;++P){var u=m+P*f,d=u-.5;d*d+K*K>A||e.push([u,y,t*c.ff])}}c.Dd&&e.sort(function(z,G){var N=z[0]-.5;z=z[1]-.5;var g=G[0]-.5;G=G[1]-.5;return N*N+z*z-(g*g+G*G)})},get:function(){var p=e.length;if(0===p)return q;l>=p&&(l=0);var n=e[Math.floor(l)];l=(l+1/c.Gf)%p;return n}}}(),zb=function(){function a(){e(k+t.Tb);m.port.postMessage(\"DONE\")}function c(){var d=t.O;y.isEnabled&&(d=Math.max(d,y.O));Q.Fa=0===d?window.requestAnimationFrame(e):window.requestAnimationFrame(l)}function e(d){H.na&&\nnull!==w&&(d-=k,d=Math.min(Math.max(d,t.Dc[0]),t.Dc[1]),k+=d,p(),y.isEnabled&&y.U&&H.V&&k-y.Pb>t.sc&&(v(),y.Pb=k),w(k))}function l(d){H.na&&(Q.timeout=window.setTimeout(e.bind(null,d),t.O))}function q(){w=null;H.na=!1;p()}function p(){Q.Fa&&(window.cancelAnimationFrame(Q.Fa),Q.Fa=null);Q.timeout&&(window.clearTimeout(Q.timeout),Q.timeout=null)}function n(d){d&&!H.V?(H.V=!0,J&&xb.Kf(),m.port.postMessage(\"STOP\"),Ra.Md(!0),c()):!d&&H.V&&(H.V=!1,J&&xb.yf(1),Ra.Md(!1),m.port.postMessage(\"START\"))}function r(d){d.target.hidden?\nP():K()}function h(d,z,G){z=d.createShader(z);d.shaderSource(z,G);d.compileShader(z);return z}function v(){y.U=!1;var d=y.Sa,z=y.Ta,G=y.Ua,N=y.S;d.uniform1f(y.Tc,Math.random());y.oa?z.beginQueryEXT(N,G):d.beginQuery(N,G);d.drawElements(d.POINTS,1,d.UNSIGNED_SHORT,0);y.oa?z.endQueryEXT(N):d.endQuery(N);d.flush();D().then(function(g){g=t.Sd*t.qc*1E3/g;y.nb=(y.nb+1)%t.sa;y.Rb[y.nb]=g;if(++y.fd>t.sa){y.$a.set(y.Rb);y.$a.sort();g=y.$a[Math.floor(t.sa/2)];y.Ma=Math.max(y.Ma,g);var C;for(C=0;C<y.mc&&!(g>\ny.Ma*(1-(t.rc[C]+t.Td*(C>=y.lb?1:-1))));++C)C===y.mc-1&&++C;C!==y.lb&&(console.log(\"THERMAL THROTTLING LEVEL = \"+C.toString()),y.lb=C,y.O=0===C?0:t.Rd[C-1],t.pc&&t.pc(C))}y.U=!0}).catch(function(){y.U=!0})}function A(d){var z=y.Sa,G=y.Ta,N=y.Ua;N=y.oa?G.cg(N,G.QUERY_RESULT_AVAILABLE_EXT):z.getQueryParameter(N,z.QUERY_RESULT_AVAILABLE);z=z.getParameter(G.GPU_DISJOINT_EXT);N?d(!z):setTimeout(A.bind(null,d),.1)}function D(){return new Promise(function(d,z){A(function(G){if(G){G=y.Sa;var N=y.Ta,g=y.Ua;\nG=y.oa?N.getQueryObjectEXT(g,N.QUERY_RESULT_EXT):G.getQueryParameter(g,G.QUERY_RESULT);d(G)}else z()})})}var f={cd:!0,Dc:[1,200],Tb:20,O:0,Ud:!1,qc:50,Sd:240,sc:3E3,sa:3,rc:[.2,.35,.5],Td:.05,Rd:[8,20,40],pc:null},t=null,w=null,k=0,m=null,J=!1,H={ga:!1,V:!0,Ob:!1,Nb:!1,Mb:!1,na:!1},Q={Fa:null,timeout:null},y={isEnabled:!1,U:!1,Sa:null,Ta:null,Ua:null,S:null,Tc:null,oa:!0,lb:0,mc:0,O:0,Pb:0,fd:0,Rb:null,$a:null,nb:0,Ma:0},K=n.bind(null,!0),P=n.bind(null,!1),u={s:function(d){t=Object.assign(f,d);Object.assign(H,\n{V:!0,ga:!0,na:!1});if(t.Ud){d=document.createElement(\"canvas\");d.setAttribute(\"width\",\"1\");d.setAttribute(\"height\",\"1\");var z={antialias:!1};d=d.getContext(\"webgl2\",z)||d.getContext(\"webgl\",z);if(z=d.getExtension(\"EXT_disjoint_timer_query\")||d.getExtension(\"EXT_disjoint_timer_query_webgl2\")){y.Sa=d;y.Ta=z;y.isEnabled=!0;y.oa=z.beginQueryEXT?!0:!1;var G=h(d,d.VERTEX_SHADER,\"attribute vec4 a0;void main(){gl_Position=a0;}\"),N=h(d,d.FRAGMENT_SHADER,\"precision lowp float;uniform float u36;void main(){vec4 a=u36*vec4(1.,2.,3.,4.);for(int b=0;b<666;b+=1)a=cos(a);gl_FragColor=a;}\".replace(\"666\",\nt.qc.toString())),g=d.createProgram();d.attachShader(g,G);d.attachShader(g,N);d.linkProgram(g);G=d.getAttribLocation(g,\"a0\");y.Tc=d.getUniformLocation(g,\"u36\");d.useProgram(g);d.enableVertexAttribArray(G);g=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,g);d.bufferData(d.ARRAY_BUFFER,new Float32Array([.5,.5,0,1]),d.STATIC_DRAW);d.vertexAttribPointer(G,4,d.FLOAT,!1,16,0);g=d.createBuffer();d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,g);d.bufferData(d.ELEMENT_ARRAY_BUFFER,new Uint16Array([0]),d.STATIC_DRAW);\nd.disable(d.DEPTH_TEST);d.disable(d.DITHER);d.disable(d.STENCIL_TEST);d.viewport(0,0,1,1);g=y.oa?z.createQueryEXT():d.createQuery();y.Ua=g;y.S=z.TIME_ELAPSED_EXT||d.TIME_ELAPSED;y.lb=0;y.mc=t.rc.length;y.O=0;y.Pb=-t.sc;y.Rb=new Float32Array(t.sa);y.$a=new Float32Array(t.sa);y.Ma=0;y.nb=0;y.fd=0;y.U=!0}}if(t.cd){d=!1;try{if(\"undefined\"===typeof SharedWorker){var C=URL.createObjectURL(new Blob([\"let handler = null;\\n      self.addEventListener('message', function(e){\\n        if (handler !== null){\\n          clearTimeout(handler);\\n          handler = null;\\n        }\\n        switch (e.data) {\\n          case 'START':\\n          case 'DONE':\\n            handler = setTimeout(function(){\\n              self.postMessage('TICK');\\n            }, \"+\nt.Tb.toString()+\");\\n            break;\\n          case 'STOP':\\n            break;\\n        };\\n      }, false);\"],{type:\"text/javascript\"})),M=new Worker(C);M.addEventListener(\"message\",a);m={rd:M,port:M};H.Ob=!0}else{var R=URL.createObjectURL(new Blob([\"let handler = null;\\n      onconnect = function(e) {\\n        const port = e.ports[0];\\n        port.addEventListener('message', function(e) {\\n          \\n          if (handler !== null){\\n            clearTimeout(handler);\\n            handler = null;\\n          }\\n          switch (e.data) {\\n            case 'START':\\n            case 'DONE':\\n              handler = setTimeout(function(){\\n                port.postMessage('TICK');\\n              }, \"+\nt.Tb.toString()+\");\\n              break;\\n            case 'STOP':\\n              break;\\n          };\\n          \\n        });\\n        \\n        port.start();\\n      } // end onconnect()\"],{type:\"text/javascript\"})),ba=new SharedWorker(R);ba.port.start();ba.port.addEventListener(\"message\",a);m={rd:ba,port:ba.port};H.Nb=!0}d=!0}catch(ca){}d&&(\"onvisibilitychange\"in document?document.addEventListener(\"visibilitychange\",r):(window.addEventListener(\"blur\",P),window.addEventListener(\"focus\",K)),H.Mb=\n!0)}J=\"undefined\"!==typeof xb},m:function(){q();H.Mb&&(\"onvisibilitychange\"in document?document.removeEventListener(\"visibilitychange\",r):(window.removeEventListener(\"blur\",P),window.removeEventListener(\"focus\",K)),H.Mb=!1);H.Nb?(m.port.close(),H.Nb=!1):H.Ob&&(m.rd.terminate(),H.Ob=!1);Object.assign(H,{V:!0,ga:!1,na:!1});w=null},Bg:function(){return H.V},update:function(d){Object.assign(t,d)},zd:function(d){H.ga||u.s({});p();H.na=!0;w=d;H.V&&c()},stop:q};return u}(),Ab=function(){var a=0,c=null,e=\nnull,l=null,q=null;return{s:function(p,n){a=p.length;c=n;e=p;l=new Float32Array(a);q=new Float32Array(a)},Le:function(){return q},Ff:function(p,n,r){p.forEach(function(h,v){var A=Math.min(1,e[v]*r*(n+.33*(1-n)));h=A*h+(1-A)*l[v];l[v]=h;h=c[v](h);h=Math.min(Math.max(h,0),1);q[v]=h})}}}(),X={VERSION:\"1.2.9\",la:[],rb:!1,sb:!1,qb:!1,Ea:!0,Da:!1,ready:!1,initialized:!1},Bb={facingMode:\"user\",idealWidth:800,idealHeight:600,minWidth:240,maxWidth:1280,minHeight:240,maxHeight:1280,isAudio:!0},b={neuralNetworkPath:\"jeelizFaceExpressionsNNC.json\",\ntc:\"../../\",O:0,width:512,height:512,Hf:30,Cd:[.6,5.8],ja:[.06,.08,.15],xf:.7,vf:2,wf:[2,2,2],threshold:.7,ue:.08,ye:.02,Xd:[.03,1],Pf:20,Re:!1,pb:[2,7],H:{Uc:[3,7],quality:[0,6],position:[0,7],rotation:[5,7]},Wb:11,ld:1,bf:1,xc:[.1,.01],tf:[.4,-.7,-.4],uf:[.3,0,0],se:!1,Yd:.001,yc:[Math.PI/10,Math.PI/6],td:[.1,.4],ud:[.009,.02],vd:[.02,.04],Vb:5,Vc:.05,Wd:[.2,.2,.15,.15,.15,.15,1,.2,.15,.15,.2],cf:[Ia.bind(null,.1,.7),Ia.bind(null,.1,.7),Ia.bind(null,0,.4),Ia.bind(null,0,.4),Ia.bind(null,.05,.6),\nIa.bind(null,.05,.6),Ia.bind(null,.02,.3),Ia.bind(null,.3,.5),Ia.bind(null,.7,.8),Ia.bind(null,.7,.8),Ia.bind(null,.15,.5)]};X.get_nMorphs=function(){return b.Wb};var Cb=null,Db=null,Eb=null,Fb=[];\nfunction Gb(){function a(){1===++M&&(Ab.s(b.Wd,b.cf),c(),X.ready=!0,X.la.forEach(function(B){B()}),X.la.splice(0,X.la.length),e(),M=0)}function c(){H=new Float32Array(b.Wb);Q=new Float32Array(b.Wb);y=new Uint8Array(w*w*4);X.get_morphTargetInfluences=function(){return H};X.get_morphTargetInfluencesStabilized=function(){return Ab.Le()};X.set_morphUpdateCallback=function(B){K=B};X.get_rotation=function(){return d};X.get_positionScale=function(){var B=m.Jd.Ie();B.Ab(!1);B=B.bc();N[0]=1-B[1][0];N[1]=B[2][0];\nN[2]=B[3][0]*k[0];return N};X.get_rotationStabilized=function(){return G};X.switch_sleep=function(B){ba!==R.hc||B?ba=B?R.hc:R.play:e()};X.on_detect=function(B){B(ca.T);ca.Xb.push(B)};X.is_detected=function(){return ca.T};X.set_animateDelay=function(B){f=B;zb.update({O:f})}}function e(){ba!==R.play&&(ba=R.play,zb.stop(),l())}function l(){var B,L;return Ba(new va(new ma(function(aa){switch(aa.ba){case 1:a:{if(\"VIDEO\"===C.element.nodeName){var O=C.element.currentTime-x;0>O&&(x=C.element.currentTime);\nif(1E3*O<b.Pf)break a;x+=O}C.ra.refresh();O=ja.Rc();O[0]===C.Ia[0]&&O[1]===C.Ia[1]||ja.Od()}B=xb.Ke();L=0;case 2:if(!(L<B)){aa.ba=4;break}O=m;var ta=t;I.set(\"s53\");Sa.Y();O.Wa.R();C.ra.g(0);O.jb.g(1);S.l(!1,!1);O.Wa.g(0);ta.K(O.Wa);b.Re?O=T.sf(P,y).then(q):(T.rf(P,y),q(),O=Promise.resolve());aa.ba=3;return{value:O};case 3:++L;aa.ba=2;break;case 4:O=m,Sa.Y(),J.R(),I.set(\"s56\"),O.jb.g(0),S.l(!1,!1),O=xb.Be(),g=3*(1-O)+1*O,xb.Ld(),X.Ea&&(Sa.Jf(),I.set(\"s52\"),C.ra.g(0),S.l(!1,!1),F.enable(F.BLEND),F.blendFunc(F.SRC_ALPHA,\nF.ONE),J.g(0),S.l(!1,!1),F.disable(F.BLEND)),F.flush(),ba!==R.hc&&zb.zd(l),aa.ba=0}})))}function q(){r();if(!b.se&&ca.T)for(var B=0;3>B;++B){var L=n(B+b.H.rotation[0],b.H.rotation[1]);L=(2*L-1)*b.tf[B];L+=b.uf[B];u[B]=L}p();B=Date.now();L=B-Y.hd;var aa=n(b.H.quality[0],b.H.quality[1]);Y.sd=Ia(b.td[0],b.td[1],aa);aa=n(b.H.position[0],b.H.position[1]);var O=n(b.H.position[0]+1,b.H.position[1]),ta=n(b.H.position[0]+2,b.H.position[1]);Y.Ad=1-Ia(b.vd[0],b.vd[1],Math.sqrt(aa*aa+O*O+ta*ta)/L);aa=Y.pa[0]-\nu[0];O=Y.pa[1]-u[1];ta=Y.pa[2]-u[2];L=Math.sqrt(aa*aa+O*O+ta*ta)/L;Y.pa[0]=u[0];Y.pa[1]=u[1];Y.pa[2]=u[2];Y.wd=1-Ia(b.ud[0],b.ud[1],L);Y.P=Y.sd*Y.Ad*Y.wd;Y.hd=B;Y.gd[Y.Qb]=Y.P;Y.Qb=(Y.Qb+1)%b.Vb;for(B=0;B<b.Vb;++B)Y.P=Math.min(Y.gd[B],Y.P);Ab.Ff(H,Y.P,g,Q);K&&K(Y.P,g);if(ca.T)for(B=b.xc[1]*Y.P+b.xc[0]*(1-Y.P),B*=g,L=0;3>L;++L)d[L]=B*u[L]+(1-B)*d[L],G[L]=d[L];else B=Date.now()*b.Yd,z[0]=b.yc[0]*Math.sin(B),z[1]=b.yc[1]*Math.cos(B),G[0]=z[0],G[1]=z[1],G[2]=z[2]}function p(){var B=n(b.H.Uc[0],b.H.Uc[1]);\nca.Xa=b.Vc*B+(1-b.Vc)*ca.Xa;.6<ca.Xa&&!ca.T?(ca.Xb.forEach(function(L){L(!0)}),ca.T=!0):.4>ca.Xa&&ca.T&&(ca.Xb.forEach(function(L){L(!1)}),ca.T=!1)}function n(B,L){B+=w*L;return(y[4*B]+y[4*B+1]+y[4*B+2]+y[4*B+3])/1020}function r(){H.forEach(function(B,L){if(ca.T){var aa=(b.ld+L)%w,O=b.bf+Math.floor((b.ld+L)/w);O=w-1-O;aa+=w*O;O=y.slice(4*aa,4*aa+4);aa=(O[0]+O[1]+O[2]+O[3])/1020;O=b.ye*Math.sqrt((O[0]*O[0]+O[1]*O[1]+O[2]*O[2]+O[3]*O[3])/1020-aa*aa);H[L]=B>aa-O&&B<aa+O?B:aa}else H[L]=0})}function h(B){t=\nnew hb({ab:B.layers,ac:\"gpuRaw\",Yb:function(L){var aa=m;aa.jb.Gd(1);F.viewport(0,0,1,1);I.set(\"s54\");I.L(\"u37\",Y.P);I.Hd(\"u38\",yb.get());I.Hd(\"u39\",b.ja);S.l(!1,!1);aa.Jd.Gd(1);I.set(\"s55\");I.L(\"u37\",Y.P);aa.jb.g(0);S.l(!1,!1);P=L}});B=t.He();B!==D&&(D=B,ja.Xc(),m.Wa.resize(D,D),ja.Id());w=t.Ne();a()}var v=-1,A=-1,D=64,f=b.O,t=null,w=0,k=null,m={},J=null,H=null,Q=null,y=null,K=null,P=null,u=[0,0,0],d=[0,0,0],z=[0,0,0],G=[0,0,0],N=[0,0,0],g=1,C={Of:[.5,.5],Nf:[.5,.5],element:null,ra:null,Ia:[-1,-1]},\nM=0,R={oe:-4,ef:-3,Cg:-2,hc:-1,play:0},ba=R.ef,ca={Xa:0,T:!1,Xb:[]},Y={P:1,Ad:1,sd:1,wd:1,pa:[0,0,0],hd:Date.now(),gd:new Float32Array(b.Vb),Qb:0},x=0,ja={Xc:function(){v=b.width;A=b.height;yb.s({eb:b.wf,nd:b.vf,ka:v,Hb:A,Bd:b.xf,ja:b.ja,Dd:!0});k=[1,v/A]},Id:function(){I.I(\"s52\",[{type:\"1i\",name:\"u1\",value:0}]);I.I(\"s53\",[{type:\"1i\",name:\"u1\",value:0},{type:\"1i\",name:\"u40\",value:1},{type:\"2f\",name:\"u41\",value:k}]);I.I(\"s56\",[{type:\"1i\",name:\"u40\",value:0},{type:\"2f\",name:\"u41\",value:k},{type:\"3f\",\nname:\"u42\",value:[0,.5,1]}]);I.I(\"s54\",[{type:\"1i\",name:\"u43\",value:0},{type:\"1i\",name:\"u40\",value:1},{type:\"1f\",name:\"u44\",value:b.Cd[0]},{type:\"1f\",name:\"u45\",value:b.Cd[1]},{type:\"1f\",name:\"u46\",value:b.Hf},{type:\"1f\",name:\"u47\",value:b.threshold},{type:\"1f\",name:\"u48\",value:b.ue},{type:\"1f\",name:\"u49\",value:k[0]}]);I.I(\"s55\",[{type:\"1i\",name:\"u1\",value:0},{type:\"1i\",name:\"u5\",value:1},{type:\"2f\",name:\"u50\",value:b.Xd}])},ke:function(){I.wc([{id:\"s52\",name:\"_\",Ca:\"attribute vec2 a0;uniform vec2 u51,u52;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=u52+u51*a0;}\",\nGa:[\"a0\"],va:[2],h:\"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}\",i:[\"u1\",\"u51\",\"u52\"],precision:\"lowp\"},{id:\"s53\",name:\"_\",h:\"uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}\",Ca:\"attribute vec2 a0;uniform sampler2D u40;uniform vec2 u41,u51,u52;const vec2 f=vec2(.25,.5),i=vec2(.75,.5),e=vec2(.5,.5);varying vec2 vv0;void main(){vec4 a=texture2D(u40,f);vec2 b=a.gb,c=a.a*u41,d=a0*.5+e,h=b+(d-e)*c;vv0=u52+u51*2.*(h-.5),gl_Position=vec4(a0,0.,1.);}\",\nGa:[\"a0\"],va:[2],i:[\"u1\",\"u40\",\"u41\",\"u51\",\"u52\"],precision:\"lowp\"},{id:\"s54\",name:\"_\",Ca:\"attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}\",h:\"uniform sampler2D u43,u40;uniform vec3 u38,u39;uniform float u44,u45,u46,u47,u49,u37,u48;varying vec2 vv0;const vec4 e=vec4(.25,.25,.25,.25);void main(){vec4 g=texture2D(u43,vec2(.4375,.9375)),h=texture2D(u43,vec2(.5625,.9375));float i=dot(g-h,e);bool j=i>u47;vec4 a=texture2D(u40,vec2(.5,.5));j?a.r=2.:a.r>u46?a.r=0.:a.r>1.9&&(a.a>u45||a.a<u44)?a.r=0.:a.r>1.9?a.r+=1.:0.;if(a.r<.9)a.gba=u38,a.r=1.;else{float c=dot(e,texture2D(u43,vec2(.0625,.9375))),d=dot(e,texture2D(u43,vec2(.1875,.9375))),f=dot(e,texture2D(u43,vec2(.3125,.9375))),b;a.r>1.9?(b=1.-u37,b*=1.-step(abs(c),u48)*step(abs(d),u48)*step(abs(f),u48)):(b=1.,a.r=0.);float k=a.a*u49;a.gba+=vec3(c,d,f)*u39*b*k;}gl_FragColor=a;}\",\ni:\"u43 u40 u38 u44 u45 u46 u47 u39 u49 u37 u48\".split(\" \")},{id:\"s56\",name:\"_\",h:\"uniform sampler2D u40;uniform vec3 u42;uniform vec2 u41;varying vec2 vv0;const vec2 i=vec2(1.,1.);void main(){vec4 f=texture2D(u40,vec2(.25,.5));vec2 g=f.gb;float j=f.a;vec2 a=j*u41,c=g+a,d=g;d-=a/2.,c-=a/2.;vec2 k=.5*(d+c),h=step(d,vv0)*step(vv0,c);float l=h.x*h.y;vec2 b=2.*abs(k-vv0)/a;b=pow(b,3.*i),gl_FragColor=vec4(l*u42*max(b.x,b.y),1.);}\",i:[\"u40\",\"u41\",\"u42\"],precision:\"lowp\"},{id:\"s55\",name:\"_\",h:\"uniform sampler2D u1,u5;uniform vec2 u50;uniform float u37;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u5,vv0);float c=(1.-u37)*(u50.y-u50.x)+u50.x;gl_FragColor=mix(b,a,c*f);}\",\ni:[\"u1\",\"u5\",\"u50\",\"u37\"]}])},Qe:function(B){var L=new Float32Array([0,.5,.5,0]);B.Wa=T.instance({isPot:!0,isFloat:!1,width:D});L={width:1,height:1,isFloat:!0,isPot:!1,array:L};B.jb=Va.instance(L);B.Jd=Va.instance(L)},le:function(){C.ra=T.instance({C:C.element,isPot:!1,isFloat:!1,isFlipY:!0});J=T.instance({isPot:!1,isFloat:!1,width:v,height:A})},s:function(){ja.le();ja.Qe(m);zb.s({cd:!1,O:f});xb.s({Ub:0,n:b.pb[1]-b.pb[0]+1,kd:b.pb[0]});Eb?h(Eb):Da(function(B){B=JSON.parse(B);h(B)})},m:function(){zb.stop();\nt&&(t.m(),t=null);ba=R.oe},ge:function(B){X.rb&&X.rb();var L={video:{facingMode:{ideal:Bb.facingMode},width:{min:Bb.minWidth,max:Bb.maxWidth,ideal:Bb.idealWidth},height:{min:Bb.minHeight,max:Bb.maxHeight,ideal:Bb.idealHeight}},audio:Bb.isAudio};pb(L,Bb.deviceId);wb(function(aa,O){Cb=O;X.sb&&X.sb();B(aa)},function(){window.ob&&window.ob(\"WEBCAM_UNAVAILABLE\")},L)},jd:function(B,L){ja.ke();C.element=B;Db=C.element;ja.Od();ja.Xc();ja.Id();ja.s();L&&L()},Rc:function(){var B=[-1,-1],L=C.element;\"VIDEO\"===\nL.nodeName?(B[0]=L.videoWidth,B[1]=L.videoHeight):(B[0]=L.width,B[1]=L.height);return B},Od:function(){var B=ja.Rc();C.Ia[0]=B[0];C.Ia[1]=B[1];Ta.Pa().width=B[0];Ta.Pa().height=B[1];b.width=B[0];b.height=B[1];var L=C.Of,aa=C.Nf,O=B[1]/B[0];B=Ta.J()/Ta.A();O>B?1>=O?L[0]*=O:L[1]/=O:(L[0]*=O,O=1/B,L[0]*=O,L[1]*=O);L[1]*=B;L=[{type:\"2f\",name:\"u51\",value:L},{type:\"2f\",name:\"u52\",value:aa}];I.I(\"s53\",[{type:\"1i\",name:\"u1\",value:0}].concat(L));I.I(\"s52\",L)}};Fb.push(ja);return ja}\nX.onLoad=function(a){X.ready?a():X.la.push(a)};X.switch_displayVideo=function(a){X.Ea=a;X.Da&&(X.Da.style.display=X.Ea?\"block\":\"none\")};X.onWebcamAsk=function(a){X.rb=a};X.onContextLost=function(a){X.qb=a};X.onWebcamGet=function(a){X.sb=a};X.destroy=function(){zb.m();Db&&Db.srcObject&&Db.srcObject.getTracks().forEach(function(a){a.stop()});Fb.forEach(function(a){a.m()});Fb.splice(0);Ta.m();X.switch_displayVideo(!1);X.initialized=!1;X.la.splice(0)};X.set_size=function(a,c){b.width=a;b.height=c};\nX.get_size=function(){return{width:b.width,height:b.height}};X.get_videoStream=function(){return Cb};X.get_video=function(){return Db};X.get_cv=function(){return Ta.Pa()};X.set_color=function(a){I.I(\"s56\",[{type:\"3f\",name:\"u42\",value:a}])};\nX.init=function(a){var c=Gb(),e=a.callbackReady?a.callbackReady:function(p){console.log(\"ERR:\",p)},l=a.callbackReady?a.callbackReady.bind(null,!1):!1;if(a.canvasId||a.canvas){var q=a.canvas?a.canvas:document.getElementById(a.canvasId);if(q)if(X.initialized)e(\"ALREADY_INITIALIZED\");else{X.initialized=!0;window.ob=e?function(p){e(p);window.ob=!1}:!1;a.NNCPath&&(b.tc=a.NNCPath);\"undefined\"!==typeof a.NNC&&(Eb=\"string\"===typeof a.NNC?JSON.parse(a.NNC):a.NNC);l&&X.la.push(l);if(!Ta.s({yb:q,width:b.width,\nheight:b.height,debug:!1,Lb:!1,od:function(){X.qb&&X.qb()},premultipliedAlpha:!1}))return e(\"GL_INCOMPATIBLE\"),!1;X.Da=Ta.Pa();X.Ea||(X.Da.style.display=\"none\");a.videoSettings&&a.videoSettings.videoElement?c.jd(a.videoSettings.videoElement,!1):(a.videoSettings&&Object.assign(Bb,a.videoSettings),c.ge(function(p){c.jd(p,!1)}));return!0}else e(\"INVALID_CANVAS\")}else e(\"NO_CANVASID\")};const JEELIZFACEEXPRESSIONS=X;\nif(true){module.exports=JEELIZFACEEXPRESSIONS;}\n/* eslint-enable */\n\n\n//# sourceURL=webpack://vrm-test/./lib/jeelizFaceExpressions.module.js?");

/***/ }),

/***/ "./lib/jeelizFaceExpressionsNNC.json":
/*!*******************************************!*\
  !*** ./lib/jeelizFaceExpressionsNNC.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"layers\":[{\"preprocessing\":\"inputMix0\",\"size\":128,\"nBlurPass\":1,\"varianceMin\":0.1,\"blurKernelSizePx\":5,\"type\":\"input\",\"index\":0,\"mask\":false,\"tilt\":0,\"customInputShader\":false},{\"size\":128,\"sparsity\":8,\"activation\":\"arctan\",\"connectivity\":{\"fromLayerSize\":128,\"toLayerSize\":128,\"toSparsity\":8,\"weights\":{\"isPot\":true,\"width\":32,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":4096,\\\\\"data\\\\\":\\\\\"rnkZtbKKsMoStoKasnpEtpKrqcpKreJirOqFreKntTpCpcLNsXoNp6LcsQmbqILVKWGjOsMgNXHLL8MXM9JAk4MuLYI+tVLxguI7uGMEqBI2s2L0rQIqrjJhq+Iqt3KpJkuimIGPOSuIrfAAO0uVs7kWNwuSsAlzqMuOsBmvtjtPqUmYt9stofmas7sXpqmaJWtSNFmUIXNxPJm8JMPYMXnZJ6PJtFm6K2rMtlmdIaucsooNHErxIPozI0JiIPjEqApqNwHEKsqRJZFiLrqHphICL2pJrhHZKRnbojKQqaA4oeIrsNHKphIgsdIZprJ0qjJMNsM7MkJMuQMoN4JBvQLGN/IxvBLdM5GmtSKsINGZH8KPJGGQL0IXJ7C2oGJCrerusgk5MDsXpkmXMusKlxoUJSsBk9nTrpsIkdnKs1sdkJmFtGsHlImLnqrolFlvqLuEs2jFpDpIONismQOEOti+I6PsI6AAKWMyuQAAH9qrsZhwHAp9otjEI9K+MvCjMcqqMAmQMqpvLjoUNjkGIhGTMtGaE5GwMnIHAAH9FyI0mkKYpKI+pZIkrNJIpyKDvCGSESJtqhAwunGQKEAAuWIwMLiRslH6MBh1iVIrFPgIMbGcAAAAMCECGOAAnMG9sZI+qloJAAJoDXoEH1KNHfmxgzJgHEm9o8IYGykznPAzGxjvG9oLAlhyLaolAAiNq8sXtFFAqiq4OGDcpTHiOMEXl0NhKDGsGON7tbHhFkIYuCH9HapfqRIHHnKDLEIvKxpqIdjHL2AAIEjHNRIVIpFVNAI1G3HkNLI2IEIoKeIoGfKFIRH0n2JeAAHzorJevCgOpfgntfk8t2pir5mAsYp3n8ogH0pfGMl0MFAAlAlZMbAACbmPIkg7HjmUnHFdsSKTnWm+qqKkGOmjoVJVIKk0kSKGICAAIZIaGYiNJUH7FOAAKBD+EvBkK/GJE2B0qVq4qMHlpPrvNKG7miqBOEHUDTK4KdIWI6M6rUI1HXL0twJFJJkIrbIQJNHWL2JrqEmJIEFNH3IZI3HiIqIBDQE7LDIDGsFiMgHlFHIUKXG2DiJKJkEhmGIdJQFml0I2qsjvrxqMsOkLszqZsukbooqfrzjgKCqambAAMZqfGWCsKMpAJsCDmSnnLJCHntkRo6KfFQkOqTLzHQDPoVLLIEDGCeK1GIGHJhJVD2E8IbIhD2EnhlItDXDcFzJoDyEZp7qQigJNkkrfJTIrGErgM4ICJpoiMDJKKxLWpqJIKWL5s+IFKSJJsKHPKPklIGI2tXGIINAAs7GQIHB2sTGMHODlqXGEEDEeDvExHZEeqKDsFpD7qJAAnEEZofhVofIfMvAAssquoYAqpcqgs/C5HUqesvDdLZqWqCFELon+oCFMGnoSBBGcm6l4IGGFD7kFKLJrHhAAiIKZJgGwAAKOHwIIIvIeFmGcKbI3AAGCIHJJBhGKk6H5BOGcGnI9FXGktqG4DcJitMp+G4H0strJLQHesLroMDHVsFGPHnGOsvLlr8D9s6KgsYAAtCidntCcr0HIIMi+rPFwJWiFqKFeH7AAnEDzJFCvEPCLIvAAqPgbGuAAqAkHmCD8okkbmSFrOLCxsQocJlExGdAHrLE5KdharvGyKyCXpWFhHkCOpuF6mJiJohFlkyk5mKExFog/IrI8JMHKoRJWIAGxoiJFHHGRlUISDmGcAAIFFIGHpKIKFfGRqcIZG6E+nyJDEKFPtXIdJQHIsxGGEFCssEoMIdjFsCrTKzkIsEkvH0AAsvKbpIlGtAKeqclotUIVqRjsGxGfJ3jxH8DGJ1jvImAAKGhDJhgJKCB6LqkCJvAAGakxJpCTGpkGJrEXH7i2JtG1OWB0pYCvMLBnKiG8GxAtKWIoAAAAEUHuI6AAogIdEHBZpQHdAAAAnPGsEUAADxFELXIsJWHGIhITHDHoAAITAAGLBhIyAAGkFRIrAAGJnQIrDjFBowIvBcBSHsI8A+DqtAndLCE0szIHGhjrsoEnGmmpsfqeJhljsjp6KOAAtAHcnBijtaJ2o3m7t3JZsLgNJ2ukM9qNGfIjMAp5EqNsA4nbEUNWruntFlIGrensIarMmLmQJFrEJwlaJnHkolmLNQoPGeuSLzKHDXu8IYMwAAtMrSMaGjsHGDnEInoCJtq9HFlxKyqQmtnnK+pFp0mKIPDJtMJRtIDaNbHbuNCvNwJCuQAANaL2sWgPkYLIpZC1qyKdI8GilsKQMUGanfLCOjAAKWu4NgjIKAuorKixK1vvwXAAMVv5wzCENfv7tYCANLvQNRAwMEuiQJAANtuNICulNPlyAtq9ELmqkfLPrpmTl4Ozrtn1AAotndn/G2sHKDnoIKqLJXnFIwLxqfm8MEI/HcOLI3MqEAAupILskHqwobqMkXrAKKtCkQtQK4s5oIrHMkq7pOpsMCLppnIXODAAGbNyMDCLOENyqfAALgNxsYhdrfNwsFF2tkMdrKGWsUKOqYG4J7JJHwELIxI/M6AALWsHNqjXILr5LVjNJmsFsGAAgBq+sdB2pgoNokCeqzH7MIA/skJ0M/AbrSLsHeuzNYCcFCtAnaAAhgKKr0kIlsOWqtl4mQpYAAmCGBraIgmAHbockulwIYJtqXl8KQMpBJNfoBMREeMHoRj+lnLSJisUo7G/K8tSqXjRL6sNpTrZLFHznRqULTLLGOENNCgLMaOHMPAAMDN9KyBHAaNimlAAsaLlruAAszKBq6GMpvFzrCGWKjCzqRAAoRFrqZAAKHKREKksIqMSh3inoTNRqyAcqGOAq2B8qBOHAABrnnNsLyBXGlMzITAAE8M6IXuZNACpGsscqJAACDjbsDAAkfMLoHjNmNJfGLjYAAoUDfjsEWmIjqitGkkTqWj3JWNqIPIqmZJXHoI9Jpqul+KjKnswpwKiLps6qoIdK6oUiCGTLFKsKEnvLTKAItnSLNHWOOKULWFOIGHyKrD3qaj1J9CDsLoimtBKrnpBpfCeFYo2rKEHJ7o4qdAAqYnPsHAAJ8NdnNiFpPNrpwgUkpOiqRAwhCPBEpCxHQOnAPAAAAOFKxAAlpMhisAAm/M8IetnLwE6G9r9rXDkDioxqsEkjalJAAEjmBJtE2CyhdAAo1CdBRkwnhA1FEpCqJAAI9NNJvFEJ/m0JDILK0sclWIaKdtCo5LELHsaosKULkHeCFLDK2KNHFIMLGJCHdAgJFETNjjDLCGRqnmyLTEGsvpXK8EKskqYKcAArIqaKBh+G2qWinhIILp4oVAApNo8IVAAkGNrKVhcp/NdKDg1rIOcGQAArrOgKRC/peOUJYAcoDNgI2EXC+L4kBAAI1MaKKrPJRF7Hmr7p7FoFeqon0GCAArQGEGJklnhpjFhAAKQo7E3CcnGl1FIAAqFpMG2AAMVpALFCfrGqaJJF/swsgJAFysqqLKrEto0AAK7HEKSJVLEH7KlKyK6IDG1JAKkshDeNgpqqED5r9oVpdGWskpnFyHIoUqLk6AAIyqSklhgKopjpJjsI+pYpLjEAAojqbhQouNliyiTn6KHnXiLAAJ8mUgCIjIUGgAAKKHYojAAJMi1ozBjkAoRqkCvGbEJKMHUHnFIIEkZlwEpGiqoGxEvC5rom+GOjonvlsGEAAJdoNGBAAFWFjHXk1pincHdmhLVrwL1mHrDrAKAmcshqdKPm4qGqbK1mgHYEqLHjNKjKKKQC9KDKFKoFYnSnzK0rWJWNpqInSI1rToZCVIyqmpBGGDZGhoyAYAAJCo3FGirGdockGkKnUoOCFiaoVnpkWAAkilOIjAAIYrnDfAAJnsnDDARKMtHIIDcJStKDQC0FHsWHYCelIsDEADemFqKI1KIHwC5IVJGj8BUHTpwpCGPAArpqeGQmBosqbGflWHboDELmaKBkoDRmgnDGID+pQJZo3KUomrrImJOo4qRLWK1o+IOKhLWm7JFBpLGl3JOrRJ7BpG1t/KHE5nauFKDjkEJManVE8g1sknBHPg9rNnsJahgDin7IpkmkCoALRlqnTneK4hroGm8LWArCgmVm5icIXr+huAAknsQgTAAo4seBdAIpKskHhDpmisMmHDMngsCkSCsiyq3gCCBIHqjQMoUsjLEszoYsVMNuVp0rrLjuxpvrYJtsKpfrwHvNEnvsNAANfnEsOkNFvjnqSplseOPscLPo3PUpLIzKTKcKzLgMjuFMeIkM2vHLzGHLzu0IAmkJyrhoWoyHXH3p7nFOZrdoNGgOurVqLIEOMoMqHGrOEHhooFlNtMJnAJOMALukXLjLTJShSH/LdCjgHDcKyEZtCvHLKIVtltxL6IlFTt8L8LYMbulK6LdNAtPI3LgKPuKE1IdoewYr3IYpLwgOlnJpkKRuGnTp9I/usnfqfAArPn0rCpQMlnoprrENSnaporZKRnCjKqSrJm+HBm2LiMYsStEMOQ2qYrjNFOsJvsrNdprMIsUNBt6LPs+KNuLhos7CSmvqCqOGfKKqArIOUswErAALtnPkIrOGhLZoQrYo7M/oNpWHYN3oAkaoVAAkjJznApVhLKEDAoNAAKdqrJdtUpQIyJwIyn+KSISN/sBLAIHNrsfL1IFH7tiMQIPr2tqLOFssGssnHFxlfqbMXGEi0qXtdDKGJrAtUDDlEslJzBgj4s+MkAAAAtEMwAAHiswGJiaINq8rci+I3DvM5pprYsaMYOUpcpsMaPEImr9MHHiLLtbKYoWKCstmytLCLsnqYp9n8rOrPJ3orphJrqUIFAAs1KeHEoksxNOEJrstQNJi8t9sLKTjQsCpoqAjQm7pQqxAAHjqGmIDEAKthA3sCo4qokzLJsImpktMRtsJ1k3LeuFKrk0qCr7LgmTqqp8KfAArrqWIiCyK4LHICH6Hes0rSIAF4sOpLGlAAshJhGiBdsYLbFPEQrpJjELJiqWorDOJnmLq+CtHxJSLlq8qerMJ+KjnpkYI6MVIHn0GCJbJ3quo4mSIbrSr8m9GcqasaorhKD4sDIZmUFFsNmuIVLouALfIlmsthM+IOrZs9MWGTr8qKBcDMr4qPqRCervm/rECpmBoTleDumMs2k8q4qUrAlVKdsgpDmLMLskgfmNJfqrI0mCqShkJ7k+qSqAKWjsoWpxKAkrJ4iZrlH2HXsXsPICJPqCsAIEDYomqdH5G6EOotHvHHJhrJGVJlKAsIE5HXJgr9CtJvL8KFmEpyMHDFkvnUB0n2IPGLHUqFhcIFIarUnjHkIfsPo4GZJPsOmdB1LHrbpMlkMesGnsHdMisELrIEG4q9L3IEICobISIAkmIxqOGZpbHHrFEDqwLFpmDUqjKroPD5k1rXjCqAAAqvjaKHNImPk1KELwmek9EEMMIAk2prMRKUkboYKHKnh8lSHaJDiqH/IbFjGvKiq7I+HNKcknLpHdKiJILtHPKlLcK7HTJTLQKlGLJQKkKuGCJBKBMSEXIoMZK+J0ozL7H+pTnWo8nBqnBZqknCFOGGlBo6klFKI2pdnQEdH1oJmeAbLLkSqxk1NZs7EvgBKUq8LTC0Inp+K8GMLLqKmAETLWEFqMEDIxqLqqEBiepCnKAqoEqTnRCfkZq+gUm4JcmNiDJiNfoOjvIUM6pVkBkoMPHviZoZMeJKghmFLdKOhoEPGzItk0iTKhqXjLMjKCpChPLMKjmKAALVL+nUAPLZMeo0EHLdLdo7GBKNKInYEsIGJkH6EJFbLulNKgnJK7pOk/mirontqCBDrdpBmsF0q2piHLFGo4pjDVEBjkomEOCdKQjHqXhEM/mgI4l8JUK8L4hYIpLcGtAzI/KXnqDfIyKTqmDKIjmEnICsDZAAAMAAhqg3noAsDlpgi2DZLXqNieGoMHsAjxFRLnpnh4l1KmoIkBjpLbhWiEEmKmI0gWFrHeIkgpkZMAGCk4KeMhDcktJaKcE7j5JwJMkRgIJ4E7jSAAJckOEKA3FJm/HVB3lSlYJTE7nLK6rKJGl1FjqhAAkrpipenCEIo/oDAAGRojoIHcGCDSplHZE4Kno+HqEbMVC6peEDNJqrKgmIJsK3G/ilHULXlWiSI1Jjp0AAItItnAAAF3o0A2C0EsFvFoDJiWG1l6EMivrgiYI4KMr3iSFfJ8sEjzAAKQsHiYhcJyrEiWE5KLqkiHEpIMoEg1EtF7pDg1nBL8EjLQOaEiFKLAL8m/ovK4q2AAonMutwjkmILxuGglAAKut9HzEHAAseJwAArnrsLFNTu8qEAAMpKRpLnxMtEyoqowK4pmmWopqDtlFno8sEtVmJp+r/sWlmqgpitGmPrOHIo3M0sEKou+u8iSJDsvuRkCFQJqIZnIkdMSMumRm8LWMFIJmfpCJ0KPAAqaqXHeqtqjwFNZItqDsbK8MPrNs1MSMVgxsPMdNXlmq6M8MHItqSMQKWIpmmLFEmGTszJjM7J4OOM+LRLdrdMzK4MhtkMcK7MouBLwKxILtXLWJEqZrOKwI2sWpTKgIyshI3M4Nyw9mdEdIFxXnioJrqxOoTozsyvgofoXs/tlk+m/r3oyFHo6EEI2HEn4MAJuIMGVnHOSQAneKbu9uNHWjZulvPmgotrwEroSqFMEMKoqofMvLvpLm6FnGToIAArRrJpbptpqK9oStJqcsNktt6p0tVAAt4o0scJzsbGKrKM3sGIkmxNPl2JCKoLZKonaDHLOM8MNoKMPMXMOu5KrL0NWvDMYLzMKukMpLrkzrtMYLNq+n3MnKYtMLLMOJhsiMKNFOOtKHIizk+tqHfottYvSGNoiuLv4AAnesbvymYovkKulAAoJLBtdGPlqMasFG0JbnJO/PlLrKzult0LwG/u1ujMOoMtmsfLaocJHHjK8njNMM4JLi3LELwKaG9qwpgJCpgqTOBouqIpLIwnitApVoOoQuAqItRGEsyGOtFHXsdKKssLQqVKYpNJrgTHHmAMAM/L9uiDIMQNEu/m+MOMfuIo2MAJ9ptnCMPqXGckQMKtbKGGuKptFMzKSJysrMaMNN/JkIBpsokKBJPoftOKYI+nstPMEHjnUnADAGIgxKor1l2CnL2p6k2GFK2tpAAJtqAPtP+MyiOtbs8K2qhuktvLgrqubs9LRqwq+rDJbotMYL6IilxMVMNHjIFnjo+LyKUqkMOicMKqhLQgGoJq+LfmfqEnGIZEzoZImrWJSsIKntNJcsTLUsLGMs5FWsmLtLcLzvMplKtL3uDhOKwIosVFaLIrCKHn9MFsuK/q3MEs4K+sALNqVL0rqKaGILgrUOCM5FtqWDqMZIni4rYMYIlFHqkNHItINH5N7KZJQLCNaIRJIKFNNFNJCjbLVoXKRsTPJPHMeJfprqxKNkpt9uOIYlCujr1HhEttTsFqIKLKSL6q1KZMDL2rGMNGRJGIDMnrhCOmLNwr3KhnKNkqkNmoNMgHNNAlhMULJMnF8o3LEKWFxqkJemnkatJqMsxLAKeK+u2o2IvJms4nHFxmsqisTKCqqMPtDK4sZMXs3K7qFMHsjK/IkMZsFKNMpLRsVKdPVAPpYqcOAAAINrwMiAAHrqrMnFYIOoNMoIjJuG+MFAAJ3ApMrCcIqpaM3kUJXuwOgOWOIqqJ1GaMTqzsFsTKjqLuOtmKCpnuPsuiNlxpDFDqIlVLYKmqil0JZINK9MYr/ogoAN/qMoTnXNoqiEJpsNiGwKLowNjKzMLCqMYKSMSg+L5IRMRoyImomoQJjGAIasduaCvkOpOszFloyMVshHPpSNZsOI8niMXp1JhEHLWpDJtH0KfndJpKLIAoCKKOiA3AApbN9lTJIlONLnNIKF2LQn+IdETMFofKAJUKrnWJvGwKEkeHqnzLTiBHMtQMXNFOXp8MrKaMgAAJqm0K7IOsns9HZIEuRtAomIrsSnNrnIGGdKxqSGFLLLQLmkapvH+nwD5ndp6mphem8ojonGSAAmhnFLxIaFUE/JwIPJUEHKzHQK2oBKDAAGFIfotKpiJGao3JZMXOHniHYOCN0mfGpMiM2GAJimrMKGbI3p7JTI+lppNKQJKp9qaJoI8F3GDMCDTiXk0LlHRI9nsKRAAKwo5JGoDMHoWIZnkMDn6iLnvLjiMnwoNNEG5Com4BFKLOZLuKRMtL2MhMLMOLHMhJPpngaMLsQt1q4L8sTsVsfKsquAAqWHWAAMELGsxpYLYGYtmpiKJI8tQnFHWImsfESmkKepVHnj/L1qGIlGqLCknGVFbJ1GSgQMlL6\\\\\"}\"},\"kernelsCount\":4,\"layerIndex\":1},\"bias\":{\"isPot\":true,\"width\":4,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":64,\\\\\"data\\\\\":\\\\\"sKzLR7yjq7yYr8O8qBvgyuygKmvmuusVOtMOuJyoqbNJuGtqJPRTkryNpcSbjHtjFH0aw+R7uewGx0Pnq8wWzGy7sB0fR3tpspoew4vsm7uuuisrDAr5pjsCkWw6r1sC\\\\\"}\"},\"index\":1,\"classesCount\":false,\"connectivityUp\":\"conv\",\"normalize\":false,\"kernelsCount\":4,\"maxPooling\":{\"size\":2},\"remap\":{\"isEnabled\":false},\"isReorganize\":true,\"dynPelu\":false},{\"size\":128,\"sparsity\":16,\"activation\":\"arctan\",\"connectivity\":{\"fromLayerSize\":64,\"toLayerSize\":128,\"toSparsity\":16,\"weights\":{\"isPot\":true,\"width\":256,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":262144,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"kernelsCount\":16,\"layerIndex\":2},\"bias\":{\"isPot\":true,\"width\":16,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":1024,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"index\":2,\"classesCount\":false,\"connectivityUp\":\"conv\",\"normalize\":false,\"kernelsCount\":16,\"maxPooling\":{\"size\":2},\"remap\":{\"isEnabled\":false},\"isReorganize\":true,\"dynPelu\":false},{\"size\":32,\"sparsity\":32,\"activation\":\"elu01\",\"connectivity\":{\"fromLayerSize\":64,\"toLayerSize\":32,\"toSparsity\":32,\"weights\":{\"isPot\":true,\"width\":128,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":65536,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"kernelsCount\":4,\"layerIndex\":3},\"bias\":{\"isPot\":true,\"width\":4,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":64,\\\\\"data\\\\\":\\\\\"JXKXIJK2Ljn/LGLjLFm3LgMKLsJMKSJkLgoQEpKGMgAALOLXMNJwIkKiMMJLKyLDLQJNJtLqMRIJLlKZMQKJjfKtMGHflIgUL7pBK1KrJFAmJqIPMVKDKHKoLYErLNIi\\\\\"}\"},\"index\":3,\"classesCount\":false,\"connectivityUp\":\"conv\",\"normalize\":false,\"kernelsCount\":4,\"maxPooling\":false,\"remap\":{\"isEnabled\":false},\"isReorganize\":true,\"dynPelu\":false},{\"size\":16,\"sparsity\":14,\"activation\":\"elu01\",\"connectivity\":{\"fromLayerSize\":32,\"toLayerSize\":16,\"toSparsity\":14,\"weightsFromTo\":false,\"fromBindings\":false,\"toBindings\":false,\"squareFast\":true,\"weights\":{\"isPot\":false,\"width\":224,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":200704,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"stride\":1},\"bias\":{\"isPot\":true,\"width\":16,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":1024,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"index\":4,\"classesCount\":false,\"connectivityUp\":\"squareFast\",\"normalize\":false,\"kernelsCount\":false,\"maxPooling\":false,\"remap\":{\"isEnabled\":false},\"isReorganize\":false,\"dynPelu\":false},{\"size\":16,\"sparsity\":5,\"activation\":\"elu01\",\"connectivity\":{\"fromLayerSize\":16,\"toLayerSize\":16,\"toSparsity\":5,\"weightsFromTo\":false,\"fromBindings\":false,\"toBindings\":false,\"squareFast\":true,\"weights\":{\"isPot\":false,\"width\":80,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":25600,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"stride\":3},\"bias\":{\"isPot\":true,\"width\":16,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":1024,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"index\":5,\"classesCount\":false,\"connectivityUp\":\"squareFast\",\"normalize\":false,\"kernelsCount\":false,\"maxPooling\":false,\"remap\":{\"isEnabled\":false},\"isReorganize\":false,\"dynPelu\":false},{\"size\":16,\"sparsity\":5,\"activation\":\"elu01\",\"connectivity\":{\"fromLayerSize\":16,\"toLayerSize\":16,\"toSparsity\":5,\"weightsFromTo\":false,\"fromBindings\":false,\"toBindings\":false,\"squareFast\":true,\"weights\":{\"isPot\":false,\"width\":80,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":25600,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"stride\":1},\"bias\":{\"isPot\":true,\"width\":16,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":1024,\\\\\"data\\\\\":\\\\\"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\\\\\"}\"},\"index\":6,\"classesCount\":false,\"connectivityUp\":\"squareFast\",\"normalize\":false,\"kernelsCount\":false,\"maxPooling\":false,\"remap\":{\"isEnabled\":false},\"isReorganize\":false,\"dynPelu\":false},{\"size\":8,\"sparsity\":16,\"activation\":\"copy\",\"connectivity\":{\"fromLayerSize\":16,\"toLayerSize\":8,\"toSparsity\":16,\"weightsFromTo\":false,\"fromBindings\":false,\"toBindings\":false,\"square\":false,\"weights\":{\"isPot\":true,\"width\":128,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":65536,\\\\\"data\\\\\":\\\\\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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\\\\\"}\"}},\"bias\":{\"isPot\":true,\"width\":8,\"isFloat\":true,\"data\":\"{\\\\\"ne\\\\\":4,\\\\\"nf\\\\\":7,\\\\\"n\\\\\":256,\\\\\"data\\\\\":\\\\\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAltFwlqICMGLyM5LRMKLkKXJJEDKVCXIPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJIKmKOLRGRAAIWHJIxLWMXLhJ7KwKpJMKvKvKhKcLNKpLYJeJfLpIkLxMdF2FLmlAcH9menikqHCouIvlnqnqglpNlN3NfNFtlt3tftFLyMWMkMqMAMzKeKpMlMVMDLc\\\\\"}\"},\"index\":7,\"classesCount\":false,\"connectivityUp\":\"full\",\"normalize\":false,\"kernelsCount\":false,\"maxPooling\":false,\"remap\":{\"isEnabled\":false},\"isReorganize\":false,\"dynPelu\":false}],\"exportData\":{}}');\n\n//# sourceURL=webpack://vrm-test/./lib/jeelizFaceExpressionsNNC.json?");

/***/ }),

/***/ "./node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MToonMaterial\": () => (/* binding */ Ce),\n/* harmony export */   \"MToonMaterialCullMode\": () => (/* binding */ Ee),\n/* harmony export */   \"MToonMaterialDebugMode\": () => (/* binding */ we),\n/* harmony export */   \"MToonMaterialOutlineColorMode\": () => (/* binding */ Pe),\n/* harmony export */   \"MToonMaterialOutlineWidthMode\": () => (/* binding */ Re),\n/* harmony export */   \"MToonMaterialRenderMode\": () => (/* binding */ Ae),\n/* harmony export */   \"VRM\": () => (/* binding */ Qe),\n/* harmony export */   \"VRMBlendShapeGroup\": () => (/* binding */ W),\n/* harmony export */   \"VRMBlendShapeImporter\": () => (/* binding */ J),\n/* harmony export */   \"VRMBlendShapeProxy\": () => (/* binding */ $),\n/* harmony export */   \"VRMCurveMapper\": () => (/* binding */ he),\n/* harmony export */   \"VRMDebug\": () => (/* binding */ ft),\n/* harmony export */   \"VRMFirstPerson\": () => (/* binding */ ne),\n/* harmony export */   \"VRMFirstPersonImporter\": () => (/* binding */ ie),\n/* harmony export */   \"VRMHumanBone\": () => (/* binding */ re),\n/* harmony export */   \"VRMHumanoid\": () => (/* binding */ le),\n/* harmony export */   \"VRMHumanoidImporter\": () => (/* binding */ de),\n/* harmony export */   \"VRMImporter\": () => (/* binding */ Je),\n/* harmony export */   \"VRMLookAtApplyer\": () => (/* binding */ ue),\n/* harmony export */   \"VRMLookAtBlendShapeApplyer\": () => (/* binding */ ce),\n/* harmony export */   \"VRMLookAtBoneApplyer\": () => (/* binding */ Te),\n/* harmony export */   \"VRMLookAtHead\": () => (/* binding */ ve),\n/* harmony export */   \"VRMLookAtImporter\": () => (/* binding */ Se),\n/* harmony export */   \"VRMMaterialImporter\": () => (/* binding */ Ne),\n/* harmony export */   \"VRMMetaImporter\": () => (/* binding */ De),\n/* harmony export */   \"VRMRendererFirstPersonFlags\": () => (/* binding */ te),\n/* harmony export */   \"VRMSchema\": () => (/* binding */ H),\n/* harmony export */   \"VRMSpringBone\": () => (/* binding */ Ye),\n/* harmony export */   \"VRMSpringBoneDebug\": () => (/* binding */ ut),\n/* harmony export */   \"VRMSpringBoneImporter\": () => (/* binding */ $e),\n/* harmony export */   \"VRMSpringBoneImporterDebug\": () => (/* binding */ ct),\n/* harmony export */   \"VRMSpringBoneManager\": () => (/* binding */ Xe),\n/* harmony export */   \"VRMUnlitMaterial\": () => (/* binding */ be),\n/* harmony export */   \"VRMUnlitMaterialRenderType\": () => (/* binding */ Oe),\n/* harmony export */   \"VRMUtils\": () => (/* binding */ rt),\n/* harmony export */   \"VRM_GIZMO_RENDER_ORDER\": () => (/* binding */ mt)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/*! (c) 2019-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */\n\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */function D(e,t,n,i){return new(n||(n=Promise))((function(r,o){function s(e){try{l(i.next(e))}catch(e){o(e)}}function a(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((i=i.apply(e,t||[])).next())}))}function I(e){Object.keys(e).forEach((t=>{const n=e[t];if(null==n?void 0:n.isTexture){n.dispose()}})),e.dispose()}function U(e){const t=e.geometry;t&&t.dispose();const n=e.material;n&&(Array.isArray(n)?n.forEach((e=>I(e))):n&&I(n))}var B;!function(e){e[e.NUMBER=0]=\"NUMBER\",e[e.VECTOR2=1]=\"VECTOR2\",e[e.VECTOR3=2]=\"VECTOR3\",e[e.VECTOR4=3]=\"VECTOR4\",e[e.COLOR=4]=\"COLOR\"}(B||(B={}));const V=new three__WEBPACK_IMPORTED_MODULE_0__.Vector2,G=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,F=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4,k=new three__WEBPACK_IMPORTED_MODULE_0__.Color;class W extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D{constructor(e){super(),this.weight=0,this.isBinary=!1,this._binds=[],this._materialValues=[],this.name=`BlendShapeController_${e}`,this.type=\"BlendShapeController\",this.visible=!1}addBind(e){const t=e.weight/100;this._binds.push({meshes:e.meshes,morphTargetIndex:e.morphTargetIndex,weight:t})}addMaterialValue(r){const o=r.material,s=r.propertyName;let a,l,d,h,u=o[s];u&&(u=r.defaultValue||u,u.isVector2?(a=B.VECTOR2,l=u.clone(),d=(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2).fromArray(r.targetValue),h=d.clone().sub(l)):u.isVector3?(a=B.VECTOR3,l=u.clone(),d=(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3).fromArray(r.targetValue),h=d.clone().sub(l)):u.isVector4?(a=B.VECTOR4,l=u.clone(),d=(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4).fromArray([r.targetValue[2],r.targetValue[3],r.targetValue[0],r.targetValue[1]]),h=d.clone().sub(l)):u.isColor?(a=B.COLOR,l=u.clone(),d=(new three__WEBPACK_IMPORTED_MODULE_0__.Color).fromArray(r.targetValue),h=d.clone().sub(l)):(a=B.NUMBER,l=u,d=r.targetValue[0],h=d-l),this._materialValues.push({material:o,propertyName:s,defaultValue:l,targetValue:d,deltaValue:h,type:a}))}applyWeight(){const e=this.isBinary?this.weight<.5?0:1:this.weight;this._binds.forEach((t=>{t.meshes.forEach((n=>{n.morphTargetInfluences&&(n.morphTargetInfluences[t.morphTargetIndex]+=e*t.weight)}))})),this._materialValues.forEach((t=>{if(void 0!==t.material[t.propertyName]){if(t.type===B.NUMBER){const n=t.deltaValue;t.material[t.propertyName]+=n*e}else if(t.type===B.VECTOR2){const n=t.deltaValue;t.material[t.propertyName].add(V.copy(n).multiplyScalar(e))}else if(t.type===B.VECTOR3){const n=t.deltaValue;t.material[t.propertyName].add(G.copy(n).multiplyScalar(e))}else if(t.type===B.VECTOR4){const n=t.deltaValue;t.material[t.propertyName].add(F.copy(n).multiplyScalar(e))}else if(t.type===B.COLOR){const n=t.deltaValue;t.material[t.propertyName].add(k.copy(n).multiplyScalar(e))}\"boolean\"==typeof t.material.shouldApplyUniforms&&(t.material.shouldApplyUniforms=!0)}}))}clearAppliedWeight(){this._binds.forEach((e=>{e.meshes.forEach((t=>{t.morphTargetInfluences&&(t.morphTargetInfluences[e.morphTargetIndex]=0)}))})),this._materialValues.forEach((e=>{if(void 0!==e.material[e.propertyName]){if(e.type===B.NUMBER){const t=e.defaultValue;e.material[e.propertyName]=t}else if(e.type===B.VECTOR2){const t=e.defaultValue;e.material[e.propertyName].copy(t)}else if(e.type===B.VECTOR3){const t=e.defaultValue;e.material[e.propertyName].copy(t)}else if(e.type===B.VECTOR4){const t=e.defaultValue;e.material[e.propertyName].copy(t)}else if(e.type===B.COLOR){const t=e.defaultValue;e.material[e.propertyName].copy(t)}\"boolean\"==typeof e.material.shouldApplyUniforms&&(e.material.shouldApplyUniforms=!0)}}))}}var H;function z(e,t,n){const i=e.parser.json.nodes[t].mesh;if(null==i)return null;const r=e.parser.json.meshes[i].primitives.length,o=[];return n.traverse((e=>{o.length<r&&e.isMesh&&o.push(e)})),o}function j(e){return D(this,void 0,void 0,(function*(){const t=yield e.parser.getDependencies(\"node\"),n=new Map;return t.forEach(((t,i)=>{const r=z(e,i,t);null!=r&&n.set(i,r)})),n}))}function Y(e){return\"_\"!==e[0]?(console.warn(`renameMaterialProperty: Given property name \"${e}\" might be invalid`),e):(e=e.substring(1),/[A-Z]/.test(e[0])?e[0].toLowerCase()+e.substring(1):(console.warn(`renameMaterialProperty: Given property name \"${e}\" might be invalid`),e))}!function(e){var t,n,i,r,o,s;(t=e.BlendShapePresetName||(e.BlendShapePresetName={})).A=\"a\",t.Angry=\"angry\",t.Blink=\"blink\",t.BlinkL=\"blink_l\",t.BlinkR=\"blink_r\",t.E=\"e\",t.Fun=\"fun\",t.I=\"i\",t.Joy=\"joy\",t.Lookdown=\"lookdown\",t.Lookleft=\"lookleft\",t.Lookright=\"lookright\",t.Lookup=\"lookup\",t.Neutral=\"neutral\",t.O=\"o\",t.Sorrow=\"sorrow\",t.U=\"u\",t.Unknown=\"unknown\",(n=e.FirstPersonLookAtTypeName||(e.FirstPersonLookAtTypeName={})).BlendShape=\"BlendShape\",n.Bone=\"Bone\",(i=e.HumanoidBoneName||(e.HumanoidBoneName={})).Chest=\"chest\",i.Head=\"head\",i.Hips=\"hips\",i.Jaw=\"jaw\",i.LeftEye=\"leftEye\",i.LeftFoot=\"leftFoot\",i.LeftHand=\"leftHand\",i.LeftIndexDistal=\"leftIndexDistal\",i.LeftIndexIntermediate=\"leftIndexIntermediate\",i.LeftIndexProximal=\"leftIndexProximal\",i.LeftLittleDistal=\"leftLittleDistal\",i.LeftLittleIntermediate=\"leftLittleIntermediate\",i.LeftLittleProximal=\"leftLittleProximal\",i.LeftLowerArm=\"leftLowerArm\",i.LeftLowerLeg=\"leftLowerLeg\",i.LeftMiddleDistal=\"leftMiddleDistal\",i.LeftMiddleIntermediate=\"leftMiddleIntermediate\",i.LeftMiddleProximal=\"leftMiddleProximal\",i.LeftRingDistal=\"leftRingDistal\",i.LeftRingIntermediate=\"leftRingIntermediate\",i.LeftRingProximal=\"leftRingProximal\",i.LeftShoulder=\"leftShoulder\",i.LeftThumbDistal=\"leftThumbDistal\",i.LeftThumbIntermediate=\"leftThumbIntermediate\",i.LeftThumbProximal=\"leftThumbProximal\",i.LeftToes=\"leftToes\",i.LeftUpperArm=\"leftUpperArm\",i.LeftUpperLeg=\"leftUpperLeg\",i.Neck=\"neck\",i.RightEye=\"rightEye\",i.RightFoot=\"rightFoot\",i.RightHand=\"rightHand\",i.RightIndexDistal=\"rightIndexDistal\",i.RightIndexIntermediate=\"rightIndexIntermediate\",i.RightIndexProximal=\"rightIndexProximal\",i.RightLittleDistal=\"rightLittleDistal\",i.RightLittleIntermediate=\"rightLittleIntermediate\",i.RightLittleProximal=\"rightLittleProximal\",i.RightLowerArm=\"rightLowerArm\",i.RightLowerLeg=\"rightLowerLeg\",i.RightMiddleDistal=\"rightMiddleDistal\",i.RightMiddleIntermediate=\"rightMiddleIntermediate\",i.RightMiddleProximal=\"rightMiddleProximal\",i.RightRingDistal=\"rightRingDistal\",i.RightRingIntermediate=\"rightRingIntermediate\",i.RightRingProximal=\"rightRingProximal\",i.RightShoulder=\"rightShoulder\",i.RightThumbDistal=\"rightThumbDistal\",i.RightThumbIntermediate=\"rightThumbIntermediate\",i.RightThumbProximal=\"rightThumbProximal\",i.RightToes=\"rightToes\",i.RightUpperArm=\"rightUpperArm\",i.RightUpperLeg=\"rightUpperLeg\",i.Spine=\"spine\",i.UpperChest=\"upperChest\",(r=e.MetaAllowedUserName||(e.MetaAllowedUserName={})).Everyone=\"Everyone\",r.ExplicitlyLicensedPerson=\"ExplicitlyLicensedPerson\",r.OnlyAuthor=\"OnlyAuthor\",(o=e.MetaUssageName||(e.MetaUssageName={})).Allow=\"Allow\",o.Disallow=\"Disallow\",(s=e.MetaLicenseName||(e.MetaLicenseName={})).Cc0=\"CC0\",s.CcBy=\"CC_BY\",s.CcByNc=\"CC_BY_NC\",s.CcByNcNd=\"CC_BY_NC_ND\",s.CcByNcSa=\"CC_BY_NC_SA\",s.CcByNd=\"CC_BY_ND\",s.CcBySa=\"CC_BY_SA\",s.Other=\"Other\",s.RedistributionProhibited=\"Redistribution_Prohibited\"}(H||(H={}));const X=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,q=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3;function Z(e,t){return e.matrixWorld.decompose(X,t,q),t}new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion;class ${constructor(){this._blendShapeGroups={},this._blendShapePresetMap={},this._unknownGroupNames=[]}get expressions(){return Object.keys(this._blendShapeGroups)}get blendShapePresetMap(){return this._blendShapePresetMap}get unknownGroupNames(){return this._unknownGroupNames}getBlendShapeGroup(e){const t=this._blendShapePresetMap[e],n=t?this._blendShapeGroups[t]:this._blendShapeGroups[e];if(n)return n;console.warn(`no blend shape found by ${e}`)}registerBlendShapeGroup(e,t,n){this._blendShapeGroups[e]=n,t?this._blendShapePresetMap[t]=e:this._unknownGroupNames.push(e)}getValue(e){var t;const n=this.getBlendShapeGroup(e);return null!==(t=null==n?void 0:n.weight)&&void 0!==t?t:null}setValue(e,t){const n=this.getBlendShapeGroup(e);var i;n&&(n.weight=(i=t,Math.max(Math.min(i,1),0)))}getBlendShapeTrackName(e){const t=this.getBlendShapeGroup(e);return t?`${t.name}.weight`:null}update(){Object.keys(this._blendShapeGroups).forEach((e=>{this._blendShapeGroups[e].clearAppliedWeight()})),Object.keys(this._blendShapeGroups).forEach((e=>{this._blendShapeGroups[e].applyWeight()}))}}class J{import(e){var t;return D(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.blendShapeMaster;if(!i)return null;const r=new $,o=i.blendShapeGroups;if(!o)return r;const s={};return yield Promise.all(o.map((t=>D(this,void 0,void 0,(function*(){const n=t.name;if(void 0===n)return void console.warn(\"VRMBlendShapeImporter: One of blendShapeGroups has no name\");let i;t.presetName&&t.presetName!==H.BlendShapePresetName.Unknown&&!s[t.presetName]&&(i=t.presetName,s[t.presetName]=n);const o=new W(n);e.scene.add(o),o.isBinary=t.isBinary||!1,t.binds&&t.binds.forEach((n=>D(this,void 0,void 0,(function*(){if(void 0===n.mesh||void 0===n.index)return;const i=[];e.parser.json.nodes.forEach(((e,t)=>{e.mesh===n.mesh&&i.push(t)}));const r=n.index;yield Promise.all(i.map((i=>D(this,void 0,void 0,(function*(){var s;const a=yield function(e,t){return D(this,void 0,void 0,(function*(){const n=yield e.parser.getDependency(\"node\",t);return z(e,t,n)}))}(e,i);a.every((e=>Array.isArray(e.morphTargetInfluences)&&r<e.morphTargetInfluences.length))?o.addBind({meshes:a,morphTargetIndex:r,weight:null!==(s=n.weight)&&void 0!==s?s:100}):console.warn(`VRMBlendShapeImporter: ${t.name} attempts to index ${r}th morph but not found.`)})))))}))));const a=t.materialValues;a&&a.forEach((t=>{if(void 0===t.materialName||void 0===t.propertyName||void 0===t.targetValue)return;const n=[];e.scene.traverse((e=>{if(e.material){const i=e.material;Array.isArray(i)?n.push(...i.filter((e=>e.name===t.materialName&&-1===n.indexOf(e)))):i.name===t.materialName&&-1===n.indexOf(i)&&n.push(i)}})),n.forEach((e=>{o.addMaterialValue({material:e,propertyName:Y(t.propertyName),targetValue:t.targetValue})}))})),r.registerBlendShapeGroup(n,i,o)}))))),r}))}}const Q=Object.freeze(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0,0,-1)),K=new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion;var ee;!function(e){e[e.Auto=0]=\"Auto\",e[e.Both=1]=\"Both\",e[e.ThirdPersonOnly=2]=\"ThirdPersonOnly\",e[e.FirstPersonOnly=3]=\"FirstPersonOnly\"}(ee||(ee={}));class te{constructor(e,t){this.firstPersonFlag=te._parseFirstPersonFlag(e),this.primitives=t}static _parseFirstPersonFlag(e){switch(e){case\"Both\":return ee.Both;case\"ThirdPersonOnly\":return ee.ThirdPersonOnly;case\"FirstPersonOnly\":return ee.FirstPersonOnly;default:return ee.Auto}}}class ne{constructor(e,t,n){this._meshAnnotations=[],this._firstPersonOnlyLayer=ne._DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=ne._DEFAULT_THIRDPERSON_ONLY_LAYER,this._initialized=!1,this._firstPersonBone=e,this._firstPersonBoneOffset=t,this._meshAnnotations=n}get firstPersonBone(){return this._firstPersonBone}get meshAnnotations(){return this._meshAnnotations}getFirstPersonWorldDirection(e){return e.copy(Q).applyQuaternion(Z(this._firstPersonBone,K))}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}getFirstPersonBoneOffset(e){return e.copy(this._firstPersonBoneOffset)}getFirstPersonWorldPosition(e){const t=this._firstPersonBoneOffset,i=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(t.x,t.y,t.z,1);return i.applyMatrix4(this._firstPersonBone.matrixWorld),e.set(i.x,i.y,i.z)}setup({firstPersonOnlyLayer:e=ne._DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:t=ne._DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initialized||(this._initialized=!0,this._firstPersonOnlyLayer=e,this._thirdPersonOnlyLayer=t,this._meshAnnotations.forEach((e=>{e.firstPersonFlag===ee.FirstPersonOnly?e.primitives.forEach((e=>{e.layers.set(this._firstPersonOnlyLayer)})):e.firstPersonFlag===ee.ThirdPersonOnly?e.primitives.forEach((e=>{e.layers.set(this._thirdPersonOnlyLayer)})):e.firstPersonFlag===ee.Auto&&this._createHeadlessModel(e.primitives)})))}_excludeTriangles(e,t,n,i){let r=0;if(null!=t&&t.length>0)for(let o=0;o<e.length;o+=3){const s=e[o],a=e[o+1],l=e[o+2],d=t[s],h=n[s];if(d[0]>0&&i.includes(h[0]))continue;if(d[1]>0&&i.includes(h[1]))continue;if(d[2]>0&&i.includes(h[2]))continue;if(d[3]>0&&i.includes(h[3]))continue;const u=t[a],c=n[a];if(u[0]>0&&i.includes(c[0]))continue;if(u[1]>0&&i.includes(c[1]))continue;if(u[2]>0&&i.includes(c[2]))continue;if(u[3]>0&&i.includes(c[3]))continue;const p=t[l],m=n[l];p[0]>0&&i.includes(m[0])||(p[1]>0&&i.includes(m[1])||p[2]>0&&i.includes(m[2])||p[3]>0&&i.includes(m[3])||(e[r++]=s,e[r++]=a,e[r++]=l))}return r}_createErasedMesh(e,t){const n=new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(e.geometry.clone(),e.material);n.name=`${e.name}(erase)`,n.frustumCulled=e.frustumCulled,n.layers.set(this._firstPersonOnlyLayer);const i=n.geometry,r=i.getAttribute(\"skinIndex\").array,o=[];for(let e=0;e<r.length;e+=4)o.push([r[e],r[e+1],r[e+2],r[e+3]]);const d=i.getAttribute(\"skinWeight\").array,h=[];for(let e=0;e<d.length;e+=4)h.push([d[e],d[e+1],d[e+2],d[e+3]]);const u=i.getIndex();if(!u)throw new Error(\"The geometry doesn't have an index buffer\");const c=Array.from(u.array),p=this._excludeTriangles(c,h,o,t),m=[];for(let e=0;e<p;e++)m[e]=c[e];return i.setIndex(m),e.onBeforeRender&&(n.onBeforeRender=e.onBeforeRender),n.bind(new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(e.skeleton.bones,e.skeleton.boneInverses),new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4),n}_createHeadlessModelForSkinnedMesh(e,t){const n=[];if(t.skeleton.bones.forEach(((e,t)=>{this._isEraseTarget(e)&&n.push(t)})),!n.length)return t.layers.enable(this._thirdPersonOnlyLayer),void t.layers.enable(this._firstPersonOnlyLayer);t.layers.set(this._thirdPersonOnlyLayer);const i=this._createErasedMesh(t,n);e.add(i)}_createHeadlessModel(e){e.forEach((e=>{if(\"SkinnedMesh\"===e.type){const t=e;this._createHeadlessModelForSkinnedMesh(t.parent,t)}else this._isEraseTarget(e)&&e.layers.set(this._thirdPersonOnlyLayer)}))}_isEraseTarget(e){return e===this._firstPersonBone||!!e.parent&&this._isEraseTarget(e.parent)}}ne._DEFAULT_FIRSTPERSON_ONLY_LAYER=9,ne._DEFAULT_THIRDPERSON_ONLY_LAYER=10;class ie{import(e,n){var i;return D(this,void 0,void 0,(function*(){const r=null===(i=e.parser.json.extensions)||void 0===i?void 0:i.VRM;if(!r)return null;const o=r.firstPerson;if(!o)return null;const s=o.firstPersonBone;let a;if(a=void 0===s||-1===s?n.getBoneNode(H.HumanoidBoneName.Head):yield e.parser.getDependency(\"node\",s),!a)return console.warn(\"VRMFirstPersonImporter: Could not find firstPersonBone of the VRM\"),null;const l=o.firstPersonBoneOffset?new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(o.firstPersonBoneOffset.x,o.firstPersonBoneOffset.y,-o.firstPersonBoneOffset.z):new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0,.06,0),d=[],h=yield j(e);return Array.from(h.entries()).forEach((([t,n])=>{const i=e.parser.json.nodes[t],r=o.meshAnnotations?o.meshAnnotations.find((e=>e.mesh===i.mesh)):void 0;d.push(new te(null==r?void 0:r.firstPersonFlag,n))})),new ne(a,l,d)}))}}class re{constructor(e,t){this.node=e,this.humanLimit=t}}function oe(e){return e.invert?e.invert():e.inverse(),e}const se=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,ae=new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion;class le{constructor(e,t){this.restPose={},this.humanBones=this._createHumanBones(e),this.humanDescription=t,this.restPose=this.getPose()}getPose(){const e={};return Object.keys(this.humanBones).forEach((t=>{const n=this.getBoneNode(t);if(!n)return;if(e[t])return;se.set(0,0,0),ae.identity();const i=this.restPose[t];(null==i?void 0:i.position)&&se.fromArray(i.position).negate(),(null==i?void 0:i.rotation)&&oe(ae.fromArray(i.rotation)),se.add(n.position),ae.premultiply(n.quaternion),e[t]={position:se.toArray(),rotation:ae.toArray()}}),{}),e}setPose(e){Object.keys(e).forEach((t=>{const n=e[t],i=this.getBoneNode(t);if(!i)return;const r=this.restPose[t];r&&(n.position&&(i.position.fromArray(n.position),r.position&&i.position.add(se.fromArray(r.position))),n.rotation&&(i.quaternion.fromArray(n.rotation),r.rotation&&i.quaternion.multiply(ae.fromArray(r.rotation))))}))}resetPose(){Object.entries(this.restPose).forEach((([e,t])=>{const n=this.getBoneNode(e);n&&((null==t?void 0:t.position)&&n.position.fromArray(t.position),(null==t?void 0:t.rotation)&&n.quaternion.fromArray(t.rotation))}))}getBone(e){var t;return null!==(t=this.humanBones[e][0])&&void 0!==t?t:void 0}getBones(e){var t;return null!==(t=this.humanBones[e])&&void 0!==t?t:[]}getBoneNode(e){var t,n;return null!==(n=null===(t=this.humanBones[e][0])||void 0===t?void 0:t.node)&&void 0!==n?n:null}getBoneNodes(e){var t,n;return null!==(n=null===(t=this.humanBones[e])||void 0===t?void 0:t.map((e=>e.node)))&&void 0!==n?n:[]}_createHumanBones(e){const t=Object.values(H.HumanoidBoneName).reduce(((e,t)=>(e[t]=[],e)),{});return e.forEach((e=>{t[e.name].push(e.bone)})),t}}class de{import(e){var n;return D(this,void 0,void 0,(function*(){const i=null===(n=e.parser.json.extensions)||void 0===n?void 0:n.VRM;if(!i)return null;const r=i.humanoid;if(!r)return null;const o=[];r.humanBones&&(yield Promise.all(r.humanBones.map((n=>D(this,void 0,void 0,(function*(){if(!n.bone||null==n.node)return;const i=yield e.parser.getDependency(\"node\",n.node);o.push({name:n.bone,bone:new re(i,{axisLength:n.axisLength,center:n.center&&new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(n.center.x,n.center.y,n.center.z),max:n.max&&new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(n.max.x,n.max.y,n.max.z),min:n.min&&new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(n.min.x,n.min.y,n.min.z),useDefaultValues:n.useDefaultValues})})}))))));const s={armStretch:r.armStretch,legStretch:r.legStretch,upperArmTwist:r.upperArmTwist,lowerArmTwist:r.lowerArmTwist,upperLegTwist:r.upperLegTwist,lowerLegTwist:r.lowerLegTwist,feetSpacing:r.feetSpacing,hasTranslationDoF:r.hasTranslationDoF};return new le(o,s)}))}}class he{constructor(e,t,n){this.curve=[0,0,0,1,1,1,1,0],this.curveXRangeDegree=90,this.curveYRangeDegree=10,void 0!==e&&(this.curveXRangeDegree=e),void 0!==t&&(this.curveYRangeDegree=t),void 0!==n&&(this.curve=n)}map(e){const t=Math.min(Math.max(e,0),this.curveXRangeDegree)/this.curveXRangeDegree;return this.curveYRangeDegree*((e,t)=>{if(e.length<8)throw new Error(\"evaluateCurve: Invalid curve detected! (Array length must be 8 at least)\");if(e.length%4!=0)throw new Error(\"evaluateCurve: Invalid curve detected! (Array length must be multiples of 4\");let n;for(n=0;;n++){if(e.length<=4*n)return e[4*n-3];if(t<=e[4*n])break}const i=n-1;if(i<0)return e[4*i+5];const r=e[4*i],o=(t-r)/(e[4*n]-r);return((e,t,n,i,r)=>{const o=r*r*r,s=r*r;return e+(t-e)*(-2*o+3*s)+n*(o-2*s+r)+i*(o-s)})(e[4*i+1],e[4*n+1],e[4*i+3],e[4*n+2],o)})(this.curve,t)}}class ue{}class ce extends ue{constructor(e,t,n,i){super(),this.type=H.FirstPersonLookAtTypeName.BlendShape,this._curveHorizontal=t,this._curveVerticalDown=n,this._curveVerticalUp=i,this._blendShapeProxy=e}name(){return H.FirstPersonLookAtTypeName.BlendShape}lookAt(e){const t=e.x,n=e.y;t<0?(this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookup,0),this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookdown,this._curveVerticalDown.map(-t))):(this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookdown,0),this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookup,this._curveVerticalUp.map(t))),n<0?(this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookleft,0),this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookright,this._curveHorizontal.map(-n))):(this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookright,0),this._blendShapeProxy.setValue(H.BlendShapePresetName.Lookleft,this._curveHorizontal.map(n)))}}const pe=Object.freeze(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0,0,-1)),me=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,fe=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,ge=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,_e=new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion;class ve{constructor(e,t){this.autoUpdate=!0,this._euler=new three__WEBPACK_IMPORTED_MODULE_0__.Euler(0,0,0,ve.EULER_ORDER),this.firstPerson=e,this.applyer=t}getLookAtWorldDirection(e){const t=Z(this.firstPerson.firstPersonBone,_e);return e.copy(pe).applyEuler(this._euler).applyQuaternion(t)}lookAt(e){this._calcEuler(this._euler,e),this.applyer&&this.applyer.lookAt(this._euler)}update(e){this.target&&this.autoUpdate&&(this.lookAt(this.target.getWorldPosition(me)),this.applyer&&this.applyer.lookAt(this._euler))}_calcEuler(e,t){const n=this.firstPerson.getFirstPersonWorldPosition(fe),i=ge.copy(t).sub(n).normalize();return i.applyQuaternion(oe(Z(this.firstPerson.firstPersonBone,_e))),e.x=Math.atan2(i.y,Math.sqrt(i.x*i.x+i.z*i.z)),e.y=Math.atan2(-i.x,-i.z),e}}ve.EULER_ORDER=\"YXZ\";const ye=new three__WEBPACK_IMPORTED_MODULE_0__.Euler(0,0,0,ve.EULER_ORDER);class Te extends ue{constructor(e,t,n,i,r){super(),this.type=H.FirstPersonLookAtTypeName.Bone,this._curveHorizontalInner=t,this._curveHorizontalOuter=n,this._curveVerticalDown=i,this._curveVerticalUp=r,this._leftEye=e.getBoneNode(H.HumanoidBoneName.LeftEye),this._rightEye=e.getBoneNode(H.HumanoidBoneName.RightEye)}lookAt(e){const t=e.x,n=e.y;this._leftEye&&(ye.x=t<0?-this._curveVerticalDown.map(-t):this._curveVerticalUp.map(t),ye.y=n<0?-this._curveHorizontalInner.map(-n):this._curveHorizontalOuter.map(n),this._leftEye.quaternion.setFromEuler(ye)),this._rightEye&&(ye.x=t<0?-this._curveVerticalDown.map(-t):this._curveVerticalUp.map(t),ye.y=n<0?-this._curveHorizontalOuter.map(-n):this._curveHorizontalInner.map(n),this._rightEye.quaternion.setFromEuler(ye))}}const xe=Math.PI/180;class Se{import(e,t,n,i){var r;const o=null===(r=e.parser.json.extensions)||void 0===r?void 0:r.VRM;if(!o)return null;const s=o.firstPerson;if(!s)return null;const a=this._importApplyer(s,n,i);return new ve(t,a||void 0)}_importApplyer(e,t,n){const i=e.lookAtHorizontalInner,r=e.lookAtHorizontalOuter,o=e.lookAtVerticalDown,s=e.lookAtVerticalUp;switch(e.lookAtTypeName){case H.FirstPersonLookAtTypeName.Bone:return void 0===i||void 0===r||void 0===o||void 0===s?null:new Te(n,this._importCurveMapperBone(i),this._importCurveMapperBone(r),this._importCurveMapperBone(o),this._importCurveMapperBone(s));case H.FirstPersonLookAtTypeName.BlendShape:return void 0===r||void 0===o||void 0===s?null:new ce(t,this._importCurveMapperBlendShape(r),this._importCurveMapperBlendShape(o),this._importCurveMapperBlendShape(s));default:return null}}_importCurveMapperBone(e){return new he(\"number\"==typeof e.xRange?xe*e.xRange:void 0,\"number\"==typeof e.yRange?xe*e.yRange:void 0,e.curve)}_importCurveMapperBlendShape(e){return new he(\"number\"==typeof e.xRange?xe*e.xRange:void 0,e.yRange,e.curve)}}const Me=(e,t)=>{const n=(e=>{switch(e){case three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding:return[\"Linear\",\"( value )\"];case three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding:return[\"sRGB\",\"( value )\"];case three__WEBPACK_IMPORTED_MODULE_0__.RGBEEncoding:return[\"RGBE\",\"( value )\"];case three__WEBPACK_IMPORTED_MODULE_0__.RGBM7Encoding:return[\"RGBM\",\"( value, 7.0 )\"];case three__WEBPACK_IMPORTED_MODULE_0__.RGBM16Encoding:return[\"RGBM\",\"( value, 16.0 )\"];case three__WEBPACK_IMPORTED_MODULE_0__.RGBDEncoding:return[\"RGBD\",\"( value, 256.0 )\"];case three__WEBPACK_IMPORTED_MODULE_0__.GammaEncoding:return[\"Gamma\",\"( value, float( GAMMA_FACTOR ) )\"];default:throw new Error(\"unsupported encoding: \"+e)}})(t);return\"vec4 \"+e+\"( vec4 value ) { return \"+n[0]+\"ToLinear\"+n[1]+\"; }\"};const Le=2*Math.PI;var Ee,we,Pe,Re,Ae;!function(e){e[e.Off=0]=\"Off\",e[e.Front=1]=\"Front\",e[e.Back=2]=\"Back\"}(Ee||(Ee={})),function(e){e[e.None=0]=\"None\",e[e.Normal=1]=\"Normal\",e[e.LitShadeRate=2]=\"LitShadeRate\",e[e.UV=3]=\"UV\"}(we||(we={})),function(e){e[e.FixedColor=0]=\"FixedColor\",e[e.MixedLighting=1]=\"MixedLighting\"}(Pe||(Pe={})),function(e){e[e.None=0]=\"None\",e[e.WorldCoordinates=1]=\"WorldCoordinates\",e[e.ScreenCoordinates=2]=\"ScreenCoordinates\"}(Re||(Re={})),function(e){e[e.Opaque=0]=\"Opaque\",e[e.Cutout=1]=\"Cutout\",e[e.Transparent=2]=\"Transparent\",e[e.TransparentWithZWrite=3]=\"TransparentWithZWrite\"}(Ae||(Ae={}));class Ce extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial{constructor(t={}){super(),this.isMToonMaterial=!0,this.cutoff=.5,this.color=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(1,1,1,1),this.shadeColor=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(.97,.81,.86,1),this.map=null,this.mainTex_ST=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,1,1),this.shadeTexture=null,this.normalMap=null,this.normalMapType=three__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap,this.normalScale=new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1,1),this.receiveShadowRate=1,this.receiveShadowTexture=null,this.shadingGradeRate=1,this.shadingGradeTexture=null,this.shadeShift=0,this.shadeToony=.9,this.lightColorAttenuation=0,this.indirectLightIntensity=.1,this.rimTexture=null,this.rimColor=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,0,1),this.rimLightingMix=0,this.rimFresnelPower=1,this.rimLift=0,this.sphereAdd=null,this.emissionColor=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,0,1),this.emissiveMap=null,this.outlineWidthTexture=null,this.outlineWidth=.5,this.outlineScaledMaxDistance=1,this.outlineColor=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,0,1),this.outlineLightingMix=1,this.uvAnimMaskTexture=null,this.uvAnimScrollX=0,this.uvAnimScrollY=0,this.uvAnimRotation=0,this.shouldApplyUniforms=!0,this._debugMode=we.None,this._blendMode=Ae.Opaque,this._outlineWidthMode=Re.None,this._outlineColorMode=Pe.FixedColor,this._cullMode=Ee.Back,this._outlineCullMode=Ee.Front,this._isOutline=!1,this._uvAnimOffsetX=0,this._uvAnimOffsetY=0,this._uvAnimPhase=0,this.encoding=t.encoding||three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding,this.encoding!==three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding&&this.encoding!==three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding&&console.warn(\"The specified color encoding does not work properly with MToonMaterial. You might want to use THREE.sRGBEncoding instead.\"),[\"mToonVersion\",\"shadeTexture_ST\",\"bumpMap_ST\",\"receiveShadowTexture_ST\",\"shadingGradeTexture_ST\",\"rimTexture_ST\",\"sphereAdd_ST\",\"emissionMap_ST\",\"outlineWidthTexture_ST\",\"uvAnimMaskTexture_ST\",\"srcBlend\",\"dstBlend\"].forEach((e=>{void 0!==t[e]&&delete t[e]})),t.fog=!0,t.lights=!0,t.clipping=!0,t.skinning=t.skinning||!1,t.morphTargets=t.morphTargets||!1,t.morphNormals=t.morphNormals||!1,t.uniforms=three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.merge([three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.common,three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.normalmap,three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.emissivemap,three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.fog,three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.lights,{cutoff:{value:.5},color:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Color(1,1,1)},colorAlpha:{value:1},shadeColor:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Color(.97,.81,.86)},mainTex_ST:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,1,1)},shadeTexture:{value:null},receiveShadowRate:{value:1},receiveShadowTexture:{value:null},shadingGradeRate:{value:1},shadingGradeTexture:{value:null},shadeShift:{value:0},shadeToony:{value:.9},lightColorAttenuation:{value:0},indirectLightIntensity:{value:.1},rimTexture:{value:null},rimColor:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Color(0,0,0)},rimLightingMix:{value:0},rimFresnelPower:{value:1},rimLift:{value:0},sphereAdd:{value:null},emissionColor:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Color(0,0,0)},outlineWidthTexture:{value:null},outlineWidth:{value:.5},outlineScaledMaxDistance:{value:1},outlineColor:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Color(0,0,0)},outlineLightingMix:{value:1},uvAnimMaskTexture:{value:null},uvAnimOffsetX:{value:0},uvAnimOffsetY:{value:0},uvAnimTheta:{value:0}}]),this.setValues(t),this._updateShaderCode(),this._applyUniforms()}get mainTex(){return this.map}set mainTex(e){this.map=e}get bumpMap(){return this.normalMap}set bumpMap(e){this.normalMap=e}get bumpScale(){return this.normalScale.x}set bumpScale(e){this.normalScale.set(e,e)}get emissionMap(){return this.emissiveMap}set emissionMap(e){this.emissiveMap=e}get blendMode(){return this._blendMode}set blendMode(e){this._blendMode=e,this.depthWrite=this._blendMode!==Ae.Transparent,this.transparent=this._blendMode===Ae.Transparent||this._blendMode===Ae.TransparentWithZWrite,this._updateShaderCode()}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode=e,this._updateShaderCode()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,this._updateShaderCode()}get outlineColorMode(){return this._outlineColorMode}set outlineColorMode(e){this._outlineColorMode=e,this._updateShaderCode()}get cullMode(){return this._cullMode}set cullMode(e){this._cullMode=e,this._updateCullFace()}get outlineCullMode(){return this._outlineCullMode}set outlineCullMode(e){this._outlineCullMode=e,this._updateCullFace()}get zWrite(){return this.depthWrite?1:0}set zWrite(e){this.depthWrite=.5<=e}get isOutline(){return this._isOutline}set isOutline(e){this._isOutline=e,this._updateShaderCode(),this._updateCullFace()}updateVRMMaterials(e){this._uvAnimOffsetX=this._uvAnimOffsetX+e*this.uvAnimScrollX,this._uvAnimOffsetY=this._uvAnimOffsetY-e*this.uvAnimScrollY,this._uvAnimPhase=this._uvAnimPhase+e*this.uvAnimRotation,this._applyUniforms()}copy(e){return super.copy(e),this.cutoff=e.cutoff,this.color.copy(e.color),this.shadeColor.copy(e.shadeColor),this.map=e.map,this.mainTex_ST.copy(e.mainTex_ST),this.shadeTexture=e.shadeTexture,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(this.normalScale),this.receiveShadowRate=e.receiveShadowRate,this.receiveShadowTexture=e.receiveShadowTexture,this.shadingGradeRate=e.shadingGradeRate,this.shadingGradeTexture=e.shadingGradeTexture,this.shadeShift=e.shadeShift,this.shadeToony=e.shadeToony,this.lightColorAttenuation=e.lightColorAttenuation,this.indirectLightIntensity=e.indirectLightIntensity,this.rimTexture=e.rimTexture,this.rimColor.copy(e.rimColor),this.rimLightingMix=e.rimLightingMix,this.rimFresnelPower=e.rimFresnelPower,this.rimLift=e.rimLift,this.sphereAdd=e.sphereAdd,this.emissionColor.copy(e.emissionColor),this.emissiveMap=e.emissiveMap,this.outlineWidthTexture=e.outlineWidthTexture,this.outlineWidth=e.outlineWidth,this.outlineScaledMaxDistance=e.outlineScaledMaxDistance,this.outlineColor.copy(e.outlineColor),this.outlineLightingMix=e.outlineLightingMix,this.uvAnimMaskTexture=e.uvAnimMaskTexture,this.uvAnimScrollX=e.uvAnimScrollX,this.uvAnimScrollY=e.uvAnimScrollY,this.uvAnimRotation=e.uvAnimRotation,this.debugMode=e.debugMode,this.blendMode=e.blendMode,this.outlineWidthMode=e.outlineWidthMode,this.outlineColorMode=e.outlineColorMode,this.cullMode=e.cullMode,this.outlineCullMode=e.outlineCullMode,this.isOutline=e.isOutline,this}_applyUniforms(){this.uniforms.uvAnimOffsetX.value=this._uvAnimOffsetX,this.uniforms.uvAnimOffsetY.value=this._uvAnimOffsetY,this.uniforms.uvAnimTheta.value=Le*this._uvAnimPhase,this.shouldApplyUniforms&&(this.shouldApplyUniforms=!1,this.uniforms.cutoff.value=this.cutoff,this.uniforms.color.value.setRGB(this.color.x,this.color.y,this.color.z),this.uniforms.colorAlpha.value=this.color.w,this.uniforms.shadeColor.value.setRGB(this.shadeColor.x,this.shadeColor.y,this.shadeColor.z),this.uniforms.map.value=this.map,this.uniforms.mainTex_ST.value.copy(this.mainTex_ST),this.uniforms.shadeTexture.value=this.shadeTexture,this.uniforms.normalMap.value=this.normalMap,this.uniforms.normalScale.value.copy(this.normalScale),this.uniforms.receiveShadowRate.value=this.receiveShadowRate,this.uniforms.receiveShadowTexture.value=this.receiveShadowTexture,this.uniforms.shadingGradeRate.value=this.shadingGradeRate,this.uniforms.shadingGradeTexture.value=this.shadingGradeTexture,this.uniforms.shadeShift.value=this.shadeShift,this.uniforms.shadeToony.value=this.shadeToony,this.uniforms.lightColorAttenuation.value=this.lightColorAttenuation,this.uniforms.indirectLightIntensity.value=this.indirectLightIntensity,this.uniforms.rimTexture.value=this.rimTexture,this.uniforms.rimColor.value.setRGB(this.rimColor.x,this.rimColor.y,this.rimColor.z),this.uniforms.rimLightingMix.value=this.rimLightingMix,this.uniforms.rimFresnelPower.value=this.rimFresnelPower,this.uniforms.rimLift.value=this.rimLift,this.uniforms.sphereAdd.value=this.sphereAdd,this.uniforms.emissionColor.value.setRGB(this.emissionColor.x,this.emissionColor.y,this.emissionColor.z),this.uniforms.emissiveMap.value=this.emissiveMap,this.uniforms.outlineWidthTexture.value=this.outlineWidthTexture,this.uniforms.outlineWidth.value=this.outlineWidth,this.uniforms.outlineScaledMaxDistance.value=this.outlineScaledMaxDistance,this.uniforms.outlineColor.value.setRGB(this.outlineColor.x,this.outlineColor.y,this.outlineColor.z),this.uniforms.outlineLightingMix.value=this.outlineLightingMix,this.uniforms.uvAnimMaskTexture.value=this.uvAnimMaskTexture,this.encoding===three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding&&(this.uniforms.color.value.convertSRGBToLinear(),this.uniforms.shadeColor.value.convertSRGBToLinear(),this.uniforms.rimColor.value.convertSRGBToLinear(),this.uniforms.emissionColor.value.convertSRGBToLinear(),this.uniforms.outlineColor.value.convertSRGBToLinear()),this._updateCullFace())}_updateShaderCode(){const e=null!==this.outlineWidthTexture,t=null!==this.map||null!==this.shadeTexture||null!==this.receiveShadowTexture||null!==this.shadingGradeTexture||null!==this.rimTexture||null!==this.uvAnimMaskTexture;this.defines={THREE_VRM_THREE_REVISION_126:parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION)>=126,OUTLINE:this._isOutline,BLENDMODE_OPAQUE:this._blendMode===Ae.Opaque,BLENDMODE_CUTOUT:this._blendMode===Ae.Cutout,BLENDMODE_TRANSPARENT:this._blendMode===Ae.Transparent||this._blendMode===Ae.TransparentWithZWrite,MTOON_USE_UV:e||t,MTOON_UVS_VERTEX_ONLY:e&&!t,USE_SHADETEXTURE:null!==this.shadeTexture,USE_RECEIVESHADOWTEXTURE:null!==this.receiveShadowTexture,USE_SHADINGGRADETEXTURE:null!==this.shadingGradeTexture,USE_RIMTEXTURE:null!==this.rimTexture,USE_SPHEREADD:null!==this.sphereAdd,USE_OUTLINEWIDTHTEXTURE:null!==this.outlineWidthTexture,USE_UVANIMMASKTEXTURE:null!==this.uvAnimMaskTexture,DEBUG_NORMAL:this._debugMode===we.Normal,DEBUG_LITSHADERATE:this._debugMode===we.LitShadeRate,DEBUG_UV:this._debugMode===we.UV,OUTLINE_WIDTH_WORLD:this._outlineWidthMode===Re.WorldCoordinates,OUTLINE_WIDTH_SCREEN:this._outlineWidthMode===Re.ScreenCoordinates,OUTLINE_COLOR_FIXED:this._outlineColorMode===Pe.FixedColor,OUTLINE_COLOR_MIXED:this._outlineColorMode===Pe.MixedLighting};const n=(null!==this.shadeTexture?Me(\"shadeTextureTexelToLinear\",this.shadeTexture.encoding)+\"\\n\":\"\")+(null!==this.sphereAdd?Me(\"sphereAddTexelToLinear\",this.sphereAdd.encoding)+\"\\n\":\"\")+(null!==this.rimTexture?Me(\"rimTextureTexelToLinear\",this.rimTexture.encoding)+\"\\n\":\"\");this.vertexShader=\"// #define PHONG\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#include <common>\\n\\n// #include <uv_pars_vertex>\\n#ifdef MTOON_USE_UV\\n  #ifdef MTOON_UVS_VERTEX_ONLY\\n    vec2 vUv;\\n  #else\\n    varying vec2 vUv;\\n  #endif\\n\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\n#ifdef USE_OUTLINEWIDTHTEXTURE\\n  uniform sampler2D outlineWidthTexture;\\n#endif\\n\\nuniform float outlineWidth;\\nuniform float outlineScaledMaxDistance;\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #ifdef MTOON_USE_UV\\n    vUv = uv;\\n    vUv.y = 1.0 - vUv.y; // uv.y is opposite from UniVRM's\\n    vUv = mainTex_ST.st + mainTex_ST.pq * vUv;\\n    vUv.y = 1.0 - vUv.y; // reverting the previous flip\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinbase_vertex>\\n  #include <skinnormal_vertex>\\n\\n  // we need this to compute the outline properly\\n  objectNormal = normalize( objectNormal );\\n\\n  #include <defaultnormal_vertex>\\n\\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n    vNormal = normalize( transformedNormal );\\n  #endif\\n\\n  #include <begin_vertex>\\n\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  // #include <displacementmap_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n  #include <clipping_planes_vertex>\\n\\n  vViewPosition = - mvPosition.xyz;\\n\\n  float outlineTex = 1.0;\\n\\n  #ifdef OUTLINE\\n    #ifdef USE_OUTLINEWIDTHTEXTURE\\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_WORLD\\n      float worldNormalLength = length( transformedNormal );\\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * worldNormalLength * objectNormal;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_SCREEN\\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n      vec2 projectedNormal = normalize( clipNormal.xy );\\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\\n    #endif\\n\\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\\n  #endif\\n\\n  #include <worldpos_vertex>\\n  // #include <envmap_vertex>\\n  #include <shadowmap_vertex>\\n  #include <fog_vertex>\\n\\n}\",this.fragmentShader=n+'// #define PHONG\\n\\n#ifdef BLENDMODE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\nuniform vec3 color;\\nuniform float colorAlpha;\\nuniform vec3 shadeColor;\\n#ifdef USE_SHADETEXTURE\\n  uniform sampler2D shadeTexture;\\n#endif\\n\\nuniform float receiveShadowRate;\\n#ifdef USE_RECEIVESHADOWTEXTURE\\n  uniform sampler2D receiveShadowTexture;\\n#endif\\n\\nuniform float shadingGradeRate;\\n#ifdef USE_SHADINGGRADETEXTURE\\n  uniform sampler2D shadingGradeTexture;\\n#endif\\n\\nuniform float shadeShift;\\nuniform float shadeToony;\\nuniform float lightColorAttenuation;\\nuniform float indirectLightIntensity;\\n\\n#ifdef USE_RIMTEXTURE\\n  uniform sampler2D rimTexture;\\n#endif\\nuniform vec3 rimColor;\\nuniform float rimLightingMix;\\nuniform float rimFresnelPower;\\nuniform float rimLift;\\n\\n#ifdef USE_SPHEREADD\\n  uniform sampler2D sphereAdd;\\n#endif\\n\\nuniform vec3 emissionColor;\\n\\nuniform vec3 outlineColor;\\nuniform float outlineLightingMix;\\n\\n#ifdef USE_UVANIMMASKTEXTURE\\n  uniform sampler2D uvAnimMaskTexture;\\n#endif\\n\\nuniform float uvAnimOffsetX;\\nuniform float uvAnimOffsetY;\\nuniform float uvAnimTheta;\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n\\n// #include <uv_pars_fragment>\\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\\n  varying vec2 vUv;\\n#endif\\n\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n// #include <envmap_common_pars_fragment>\\n// #include <envmap_pars_fragment>\\n// #include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n\\n// #include <lights_phong_pars_fragment>\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\nstruct MToonMaterial {\\n  vec3 diffuseColor;\\n  vec3 shadeColor;\\n  float shadingGrade;\\n  float receiveShadow;\\n};\\n\\n#define Material_LightProbeLOD( material ) (0)\\n\\n#include <shadowmap_pars_fragment>\\n// #include <bumpmap_pars_fragment>\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n\\n  uniform sampler2D normalMap;\\n  uniform vec2 normalScale;\\n\\n#endif\\n\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\n  uniform mat3 normalMatrix;\\n\\n#endif\\n\\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\\n\\n  // Per-Pixel Tangent Space Normal Mapping\\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\\n\\n  // Temporary compat against shader change @ Three.js r126\\n  // See: #21205, #21307, #21299\\n  #ifdef THREE_VRM_THREE_REVISION_126\\n\\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n      vec2 st0 = dFdx( uv.st );\\n      vec2 st1 = dFdy( uv.st );\\n\\n      vec3 N = normalize( surf_norm );\\n\\n      vec3 q1perp = cross( q1, N );\\n      vec3 q0perp = cross( N, q0 );\\n\\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\\n      // TODO: Is this still required? Or shall I make a PR about it?\\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\\n        return surf_norm;\\n      }\\n\\n      float det = max( dot( T, T ), dot( B, B ) );\\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\n    }\\n\\n  #else\\n\\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\\n\\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n\\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n      vec2 st0 = dFdx( uv.st );\\n      vec2 st1 = dFdy( uv.st );\\n\\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\\n\\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\\n\\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\\n      // TODO: Is this still required? Or shall I make a PR about it?\\n\\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\\n        return surf_norm;\\n      }\\n\\n      S = normalize( S );\\n      T = normalize( T );\\n      vec3 N = normalize( surf_norm );\\n\\n      #ifdef DOUBLE_SIDED\\n\\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\\n\\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\\n\\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\\n\\n      #else\\n\\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\n      #endif\\n\\n      mat3 tsn = mat3( S, T, N );\\n      return normalize( tsn * mapN );\\n\\n    }\\n\\n  #endif\\n\\n#endif\\n\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == lighting stuff ===========================================================\\nfloat getLightIntensity(\\n  const in IncidentLight directLight,\\n  const in GeometricContext geometry,\\n  const in float shadow,\\n  const in float shadingGrade\\n) {\\n  float lightIntensity = dot( geometry.normal, directLight.direction );\\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\\n  lightIntensity = lightIntensity * shadow;\\n  lightIntensity = lightIntensity * shadingGrade;\\n  lightIntensity = lightIntensity * 2.0 - 1.0;\\n  return shadeToony == 1.0\\n    ? step( shadeShift, lightIntensity )\\n    : smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\\n}\\n\\nvec3 getLighting( const in vec3 lightColor ) {\\n  vec3 lighting = lightColor;\\n  lighting = mix(\\n    lighting,\\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\\n    lightColorAttenuation\\n  );\\n\\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\\n    lighting *= PI;\\n  #endif\\n\\n  return lighting;\\n}\\n\\nvec3 getDiffuse(\\n  const in MToonMaterial material,\\n  const in float lightIntensity,\\n  const in vec3 lighting\\n) {\\n  #ifdef DEBUG_LITSHADERATE\\n    return vec3( BRDF_Diffuse_Lambert( lightIntensity * lighting ) );\\n  #endif\\n\\n  return lighting * BRDF_Diffuse_Lambert( mix( material.shadeColor, material.diffuseColor, lightIntensity ) );\\n}\\n\\n// == post correction ==========================================================\\nvoid postCorrection() {\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n  #include <premultiplied_alpha_fragment>\\n  #include <dithering_fragment>\\n}\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec2 uv = vec2(0.5, 0.5);\\n\\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\\n    uv = vUv;\\n\\n    float uvAnimMask = 1.0;\\n    #ifdef USE_UVANIMMASKTEXTURE\\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\\n    #endif\\n\\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\\n  #endif\\n\\n  #ifdef DEBUG_UV\\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\\n    #endif\\n    return;\\n  #endif\\n\\n  vec4 diffuseColor = vec4( color, colorAlpha );\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n  vec3 totalEmissiveRadiance = emissionColor;\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // -- MToon: alpha -----------------------------------------------------------\\n  // #include <alphatest_fragment>\\n  #ifdef BLENDMODE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef BLENDMODE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n  #include <normal_fragment_begin>\\n\\n  #ifdef OUTLINE\\n    normal *= -1.0;\\n  #endif\\n\\n  // #include <normal_fragment_maps>\\n\\n  #ifdef OBJECTSPACE_NORMALMAP\\n\\n    normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\\n\\n    #ifdef FLIP_SIDED\\n\\n      normal = - normal;\\n\\n    #endif\\n\\n    #ifdef DOUBLE_SIDED\\n\\n      // Temporary compat against shader change @ Three.js r126\\n      // See: #21205, #21307, #21299\\n      #ifdef THREE_VRM_THREE_REVISION_126\\n\\n        normal = normal * faceDirection;\\n\\n      #else\\n\\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\n      #endif\\n\\n    #endif\\n\\n    normal = normalize( normalMatrix * normal );\\n\\n  #elif defined( TANGENTSPACE_NORMALMAP )\\n\\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\\n    mapN.xy *= normalScale;\\n\\n    #ifdef USE_TANGENT\\n\\n      normal = normalize( vTBN * mapN );\\n\\n    #else\\n\\n      // Temporary compat against shader change @ Three.js r126\\n      // See: #21205, #21307, #21299\\n      #ifdef THREE_VRM_THREE_REVISION_126\\n\\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\\n\\n      #else\\n\\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\\n\\n      #endif\\n\\n    #endif\\n\\n  #endif\\n\\n  // #include <emissivemap_fragment>\\n  #ifdef USE_EMISSIVEMAP\\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\\n  #endif\\n\\n  #ifdef DEBUG_NORMAL\\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\\n    return;\\n  #endif\\n\\n  // -- MToon: lighting --------------------------------------------------------\\n  // accumulation\\n  // #include <lights_phong_fragment>\\n  MToonMaterial material;\\n\\n  material.diffuseColor = diffuseColor.rgb;\\n\\n  material.shadeColor = shadeColor;\\n  #ifdef USE_SHADETEXTURE\\n    material.shadeColor *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\\n  #endif\\n\\n  material.shadingGrade = 1.0;\\n  #ifdef USE_SHADINGGRADETEXTURE\\n    material.shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\\n  #endif\\n\\n  material.receiveShadow = receiveShadowRate;\\n  #ifdef USE_RECEIVESHADOWTEXTURE\\n    material.receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\\n  #endif\\n\\n  // #include <lights_fragment_begin>\\n  GeometricContext geometry;\\n\\n  geometry.position = - vViewPosition;\\n  geometry.normal = normal;\\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\n  IncidentLight directLight;\\n  vec3 lightingSum = vec3( 0.0 );\\n\\n  #if ( NUM_POINT_LIGHTS > 0 )\\n    PointLight pointLight;\\n\\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n    PointLightShadow pointLightShadow;\\n    #endif\\n\\n    #pragma unroll_loop_start\\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n      pointLight = pointLights[ i ];\\n      getPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n      pointLightShadow = pointLightShadows[ i ];\\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n    #pragma unroll_loop_end\\n  #endif\\n\\n  #if ( NUM_SPOT_LIGHTS > 0 )\\n    SpotLight spotLight;\\n\\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n    SpotLightShadow spotLightShadow;\\n    #endif\\n\\n    #pragma unroll_loop_start\\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n      spotLight = spotLights[ i ];\\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n      spotLightShadow = spotLightShadows[ i ];\\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n    #pragma unroll_loop_end\\n  #endif\\n\\n  #if ( NUM_DIR_LIGHTS > 0 )\\n    DirectionalLight directionalLight;\\n\\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n    DirectionalLightShadow directionalLightShadow;\\n    #endif\\n\\n    #pragma unroll_loop_start\\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n      directionalLight = directionalLights[ i ];\\n      getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n      directionalLightShadow = directionalLightShadows[ i ];\\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n    #pragma unroll_loop_end\\n  #endif\\n\\n  // #if defined( RE_IndirectDiffuse )\\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n  irradiance += getLightProbeIrradiance( lightProbe, geometry );\\n  #if ( NUM_HEMI_LIGHTS > 0 )\\n    #pragma unroll_loop_start\\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n    }\\n    #pragma unroll_loop_end\\n  #endif\\n  // #endif\\n\\n  // #include <lights_fragment_maps>\\n  #ifdef USE_LIGHTMAP\\n    vec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n    vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n      lightMapIrradiance *= PI;\\n    #endif\\n    irradiance += lightMapIrradiance;\\n  #endif\\n\\n  // #include <lights_fragment_end>\\n  // RE_IndirectDiffuse here\\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\n  // modulation\\n  #include <aomap_fragment>\\n\\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\n  // The \"comment out if you want to PBR absolutely\" line\\n  #ifndef DEBUG_LITSHADERATE\\n    col = min(col, material.diffuseColor);\\n  #endif\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED )\\n    gl_FragColor = vec4(\\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\\n      diffuseColor.a\\n    );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  #ifdef DEBUG_LITSHADERATE\\n    gl_FragColor = vec4( col, diffuseColor.a );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // -- MToon: parametric rim lighting -----------------------------------------\\n  vec3 viewDir = normalize( vViewPosition );\\n  vec3 rimMix = mix( vec3( 1.0 ), lightingSum + indirectLightIntensity * irradiance, rimLightingMix );\\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\\n  #ifdef USE_RIMTEXTURE\\n    rim *= rimTextureTexelToLinear( texture2D( rimTexture, uv ) ).rgb;\\n  #endif\\n  col += rim;\\n\\n  // -- MToon: additive matcap -------------------------------------------------\\n  #ifdef USE_SPHEREADD\\n    {\\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\\n      col += matcap;\\n    }\\n  #endif\\n\\n  // -- MToon: Emission --------------------------------------------------------\\n  col += totalEmissiveRadiance;\\n\\n  // #include <envmap_fragment>\\n\\n  // -- Almost done! -----------------------------------------------------------\\n  gl_FragColor = vec4( col, diffuseColor.a );\\n  postCorrection();\\n}',this.needsUpdate=!0}_updateCullFace(){this.isOutline?this.outlineCullMode===Ee.Off?this.side=three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:this.outlineCullMode===Ee.Front?this.side=three__WEBPACK_IMPORTED_MODULE_0__.BackSide:this.outlineCullMode===Ee.Back&&(this.side=three__WEBPACK_IMPORTED_MODULE_0__.FrontSide):this.cullMode===Ee.Off?this.side=three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:this.cullMode===Ee.Front?this.side=three__WEBPACK_IMPORTED_MODULE_0__.BackSide:this.cullMode===Ee.Back&&(this.side=three__WEBPACK_IMPORTED_MODULE_0__.FrontSide)}}var Oe;!function(e){e[e.Opaque=0]=\"Opaque\",e[e.Cutout=1]=\"Cutout\",e[e.Transparent=2]=\"Transparent\",e[e.TransparentWithZWrite=3]=\"TransparentWithZWrite\"}(Oe||(Oe={}));class be extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial{constructor(e){super(),this.isVRMUnlitMaterial=!0,this.cutoff=.5,this.map=null,this.mainTex_ST=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,1,1),this._renderType=Oe.Opaque,this.shouldApplyUniforms=!0,void 0===e&&(e={}),e.fog=!0,e.clipping=!0,e.skinning=e.skinning||!1,e.morphTargets=e.morphTargets||!1,e.morphNormals=e.morphNormals||!1,e.uniforms=three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.merge([three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.common,three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib.fog,{cutoff:{value:.5},mainTex_ST:{value:new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0,0,1,1)}}]),this.setValues(e),this._updateShaderCode(),this._applyUniforms()}get mainTex(){return this.map}set mainTex(e){this.map=e}get renderType(){return this._renderType}set renderType(e){this._renderType=e,this.depthWrite=this._renderType!==Oe.Transparent,this.transparent=this._renderType===Oe.Transparent||this._renderType===Oe.TransparentWithZWrite,this._updateShaderCode()}updateVRMMaterials(e){this._applyUniforms()}copy(e){return super.copy(e),this.cutoff=e.cutoff,this.map=e.map,this.mainTex_ST.copy(e.mainTex_ST),this.renderType=e.renderType,this}_applyUniforms(){this.shouldApplyUniforms&&(this.shouldApplyUniforms=!1,this.uniforms.cutoff.value=this.cutoff,this.uniforms.map.value=this.map,this.uniforms.mainTex_ST.value.copy(this.mainTex_ST))}_updateShaderCode(){this.defines={RENDERTYPE_OPAQUE:this._renderType===Oe.Opaque,RENDERTYPE_CUTOUT:this._renderType===Oe.Cutout,RENDERTYPE_TRANSPARENT:this._renderType===Oe.Transparent||this._renderType===Oe.TransparentWithZWrite},this.vertexShader=\"#include <common>\\n\\n// #include <uv_pars_vertex>\\n#ifdef USE_MAP\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #ifdef USE_MAP\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n  #include <skinbase_vertex>\\n\\n  #ifdef USE_ENVMAP\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #endif\\n\\n  #include <begin_vertex>\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n\\n  #include <worldpos_vertex>\\n  #include <clipping_planes_vertex>\\n  #include <envmap_vertex>\\n  #include <fog_vertex>\\n\\n}\",this.fragmentShader=\"#ifdef RENDERTYPE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n// #include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec4 diffuseColor = vec4( 1.0 );\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // MToon: alpha\\n  // #include <alphatest_fragment>\\n  #ifdef RENDERTYPE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef RENDERTYPE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\n  // accumulation (baked indirect lighting only)\\n  #ifdef USE_LIGHTMAP\\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n  #else\\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\\n  #endif\\n\\n  // modulation\\n  // #include <aomap_fragment>\\n\\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\n  // #include <envmap_fragment>\\n\\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\n  #include <premultiplied_alpha_fragment>\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n}\",this.needsUpdate=!0}}class Ne{constructor(e={}){this._encoding=e.encoding||three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding,this._encoding!==three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding&&this._encoding!==three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding&&console.warn(\"The specified color encoding might not work properly with VRMMaterialImporter. You might want to use THREE.sRGBEncoding instead.\"),this._requestEnvMap=e.requestEnvMap}convertGLTFMaterials(e){var t;return D(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.materialProperties;if(!i)return null;const r=yield j(e),o={},s=[];return yield Promise.all(Array.from(r.entries()).map((([t,n])=>D(this,void 0,void 0,(function*(){const r=e.parser.json.nodes[t],a=e.parser.json.meshes[r.mesh];yield Promise.all(n.map(((t,n)=>D(this,void 0,void 0,(function*(){const r=a.primitives[n];if(!r)return;const l=t.geometry,d=l.index?l.index.count:l.attributes.position.count/3;Array.isArray(t.material)||(t.material=[t.material],l.addGroup(0,d,0));const h=r.material;let u,c=i[h];c||(console.warn(`VRMMaterialImporter: There are no material definition for material #${h} on VRM extension.`),c={shader:\"VRM_USE_GLTFSHADER\"}),o[h]?u=o[h]:(u=yield this.createVRMMaterials(t.material[0],c,e),o[h]=u,s.push(u.surface),u.outline&&s.push(u.outline)),t.material[0]=u.surface,this._requestEnvMap&&u.surface.isMeshStandardMaterial&&this._requestEnvMap().then((e=>{u.surface.envMap=e,u.surface.needsUpdate=!0})),t.renderOrder=c.renderQueue||2e3,u.outline&&(t.material[1]=u.outline,l.addGroup(0,d,1))})))))}))))),s}))}createVRMMaterials(e,t,n){return D(this,void 0,void 0,(function*(){let i,r;if(\"VRM/MToon\"===t.shader){const o=yield this._extractMaterialProperties(e,t,n);[\"srcBlend\",\"dstBlend\",\"isFirstSetup\"].forEach((e=>{void 0!==o[e]&&delete o[e]})),[\"mainTex\",\"shadeTexture\",\"emissionMap\",\"sphereAdd\",\"rimTexture\"].forEach((e=>{void 0!==o[e]&&(o[e].encoding=this._encoding)})),o.encoding=this._encoding,i=new Ce(o),o.outlineWidthMode!==Re.None&&(o.isOutline=!0,r=new Ce(o))}else if(\"VRM/UnlitTexture\"===t.shader){const r=yield this._extractMaterialProperties(e,t,n);r.renderType=Oe.Opaque,i=new be(r)}else if(\"VRM/UnlitCutout\"===t.shader){const r=yield this._extractMaterialProperties(e,t,n);r.renderType=Oe.Cutout,i=new be(r)}else if(\"VRM/UnlitTransparent\"===t.shader){const r=yield this._extractMaterialProperties(e,t,n);r.renderType=Oe.Transparent,i=new be(r)}else if(\"VRM/UnlitTransparentZWrite\"===t.shader){const r=yield this._extractMaterialProperties(e,t,n);r.renderType=Oe.TransparentWithZWrite,i=new be(r)}else\"VRM_USE_GLTFSHADER\"!==t.shader&&console.warn(`Unknown shader detected: \"${t.shader}\"`),i=this._convertGLTFMaterial(e.clone());return i.name=e.name,i.userData=JSON.parse(JSON.stringify(e.userData)),i.userData.vrmMaterialProperties=t,r&&(r.name=e.name+\" (Outline)\",r.userData=JSON.parse(JSON.stringify(e.userData)),r.userData.vrmMaterialProperties=t),{surface:i,outline:r}}))}_renameMaterialProperty(e){return\"_\"!==e[0]?(console.warn(`VRMMaterials: Given property name \"${e}\" might be invalid`),e):(e=e.substring(1),/[A-Z]/.test(e[0])?e[0].toLowerCase()+e.substring(1):(console.warn(`VRMMaterials: Given property name \"${e}\" might be invalid`),e))}_convertGLTFMaterial(e){if(e.isMeshStandardMaterial){const t=e;t.map&&(t.map.encoding=this._encoding),t.emissiveMap&&(t.emissiveMap.encoding=this._encoding),this._encoding===three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding&&(t.color.convertLinearToSRGB(),t.emissive.convertLinearToSRGB())}if(e.isMeshBasicMaterial){const t=e;t.map&&(t.map.encoding=this._encoding),this._encoding===three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding&&t.color.convertLinearToSRGB()}return e}_extractMaterialProperties(e,t,i){const r=[],o={};if(t.textureProperties)for(const e of Object.keys(t.textureProperties)){const n=this._renameMaterialProperty(e),s=t.textureProperties[e];r.push(i.parser.getDependency(\"texture\",s).then((e=>{o[n]=e})))}if(t.floatProperties)for(const e of Object.keys(t.floatProperties)){const n=this._renameMaterialProperty(e);o[n]=t.floatProperties[e]}if(t.vectorProperties)for(const e of Object.keys(t.vectorProperties)){let i=this._renameMaterialProperty(e);[\"_MainTex\",\"_ShadeTexture\",\"_BumpMap\",\"_ReceiveShadowTexture\",\"_ShadingGradeTexture\",\"_RimTexture\",\"_SphereAdd\",\"_EmissionMap\",\"_OutlineWidthTexture\",\"_UvAnimMaskTexture\"].some((t=>e===t))&&(i+=\"_ST\"),o[i]=new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(...t.vectorProperties[e])}return o.skinning=e.skinning||!1,o.morphTargets=e.morphTargets||!1,o.morphNormals=e.morphNormals||!1,Promise.all(r).then((()=>o))}}class De{constructor(e){var t;this.ignoreTexture=null!==(t=null==e?void 0:e.ignoreTexture)&&void 0!==t&&t}import(e){var t;return D(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.meta;if(!i)return null;let r;return this.ignoreTexture||null==i.texture||-1===i.texture||(r=yield e.parser.getDependency(\"texture\",i.texture)),{allowedUserName:i.allowedUserName,author:i.author,commercialUssageName:i.commercialUssageName,contactInformation:i.contactInformation,licenseName:i.licenseName,otherLicenseUrl:i.otherLicenseUrl,otherPermissionUrl:i.otherPermissionUrl,reference:i.reference,sexualUssageName:i.sexualUssageName,texture:null!=r?r:void 0,title:i.title,version:i.version,violentUssageName:i.violentUssageName}}))}}const Ie=new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4;function Ue(e){return e.invert?e.invert():e.getInverse(Ie.copy(e)),e}class Be{constructor(e){this._inverseCache=new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4,this._shouldUpdateInverse=!0,this.matrix=e;const t={set:(e,t,n)=>(this._shouldUpdateInverse=!0,e[t]=n,!0)};this._originalElements=e.elements,e.elements=new Proxy(e.elements,t)}get inverse(){return this._shouldUpdateInverse&&(Ue(this._inverseCache.copy(this.matrix)),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const Ve=Object.freeze(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4),Ge=Object.freeze(new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion),Fe=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,ke=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,We=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,He=new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion,ze=new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4,je=new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4;class Ye{constructor(e,n={}){var i,r,s,a,d,h;if(this._currentTail=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,this._prevTail=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,this._nextTail=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,this._boneAxis=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,this._centerSpacePosition=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,this._center=null,this._parentWorldRotation=new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion,this._initialLocalMatrix=new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4,this._initialLocalRotation=new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion,this._initialLocalChildPosition=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,this.bone=e,this.bone.matrixAutoUpdate=!1,this.radius=null!==(i=n.radius)&&void 0!==i?i:.02,this.stiffnessForce=null!==(r=n.stiffnessForce)&&void 0!==r?r:1,this.gravityDir=n.gravityDir?(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3).copy(n.gravityDir):(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3).set(0,-1,0),this.gravityPower=null!==(s=n.gravityPower)&&void 0!==s?s:0,this.dragForce=null!==(a=n.dragForce)&&void 0!==a?a:.4,this.colliders=null!==(d=n.colliders)&&void 0!==d?d:[],this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld),this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),0===this.bone.children.length)this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);else{const e=this.bone.children[0];this._initialLocalChildPosition.copy(e.position)}this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)),this._prevTail.copy(this._currentTail),this._nextTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize(),this._centerSpaceBoneLength=Fe.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length(),this.center=null!==(h=n.center)&&void 0!==h?h:null}get center(){return this._center}set center(e){var t;this._getMatrixCenterToWorld(ze),this._currentTail.applyMatrix4(ze),this._prevTail.applyMatrix4(ze),this._nextTail.applyMatrix4(ze),(null===(t=this._center)||void 0===t?void 0:t.userData.inverseCacheProxy)&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=e,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new Be(this._center.matrixWorld))),this._getMatrixWorldToCenter(ze),this._currentTail.applyMatrix4(ze),this._prevTail.applyMatrix4(ze),this._nextTail.applyMatrix4(ze),ze.multiply(this.bone.matrixWorld),this._centerSpacePosition.setFromMatrixPosition(ze),this._centerSpaceBoneLength=Fe.copy(this._initialLocalChildPosition).applyMatrix4(ze).sub(this._centerSpacePosition).length()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix),this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld),this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)),this._prevTail.copy(this._currentTail),this._nextTail.copy(this._currentTail)}update(e){if(e<=0)return;this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix),this.bone.parent?Z(this.bone.parent,this._parentWorldRotation):this._parentWorldRotation.copy(Ge),this._getMatrixWorldToCenter(ze),ze.multiply(this.bone.matrixWorld),this._centerSpacePosition.setFromMatrixPosition(ze),this._getMatrixWorldToCenter(je),je.multiply(this._getParentMatrixWorld());const t=this.stiffnessForce*e,n=ke.copy(this.gravityDir).multiplyScalar(this.gravityPower*e);this._nextTail.copy(this._currentTail).add(Fe.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1-this.dragForce)).add(Fe.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(je).sub(this._centerSpacePosition).normalize().multiplyScalar(t)).add(n),this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition),this._collision(this._nextTail),this._prevTail.copy(this._currentTail),this._currentTail.copy(this._nextTail);const i=Ue(ze.copy(je.multiply(this._initialLocalMatrix))),r=He.setFromUnitVectors(this._boneAxis,Fe.copy(this._nextTail).applyMatrix4(i).normalize());this.bone.quaternion.copy(this._initialLocalRotation).multiply(r),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix)}_collision(e){this.colliders.forEach((t=>{this._getMatrixWorldToCenter(ze),ze.multiply(t.matrixWorld);const n=Fe.setFromMatrixPosition(ze),i=t.geometry.boundingSphere.radius,r=this.radius+i;if(e.distanceToSquared(n)<=r*r){const t=ke.subVectors(e,n).normalize(),i=We.addVectors(n,t.multiplyScalar(r));e.copy(i.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition))}}))}_getMatrixCenterToWorld(e){return this._center?e.copy(this._center.matrixWorld):e.identity(),e}_getMatrixWorldToCenter(e){return this._center?e.copy(this._center.userData.inverseCacheProxy.inverse):e.identity(),e}_getParentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:Ve}}class Xe{constructor(e,t){this.colliderGroups=[],this.springBoneGroupList=[],this.colliderGroups=e,this.springBoneGroupList=t}setCenter(e){this.springBoneGroupList.forEach((t=>{t.forEach((t=>{t.center=e}))}))}lateUpdate(e){this.springBoneGroupList.forEach((t=>{t.forEach((t=>{t.update(e)}))}))}reset(){this.springBoneGroupList.forEach((e=>{e.forEach((e=>{e.reset()}))}))}}const qe=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3,Ze=new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({visible:!1});class $e{import(e){var t;return D(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.secondaryAnimation;if(!i)return null;const r=yield this._importColliderMeshGroups(e,i),o=yield this._importSpringBoneGroupList(e,i,r);return new Xe(r,o)}))}_createSpringBone(e,t={}){return new Ye(e,t)}_importSpringBoneGroupList(e,n,i){return D(this,void 0,void 0,(function*(){const r=n.boneGroups||[],o=[];return yield Promise.all(r.map((n=>D(this,void 0,void 0,(function*(){if(void 0===n.stiffiness||void 0===n.gravityDir||void 0===n.gravityDir.x||void 0===n.gravityDir.y||void 0===n.gravityDir.z||void 0===n.gravityPower||void 0===n.dragForce||void 0===n.hitRadius||void 0===n.colliderGroups||void 0===n.bones||void 0===n.center)return;const r=n.stiffiness,s=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(n.gravityDir.x,n.gravityDir.y,-n.gravityDir.z),a=n.gravityPower,l=n.dragForce,d=n.hitRadius,h=[];n.colliderGroups.forEach((e=>{h.push(...i[e].colliders)}));const u=[];yield Promise.all(n.bones.map((t=>D(this,void 0,void 0,(function*(){const i=yield e.parser.getDependency(\"node\",t),o=-1!==n.center?yield e.parser.getDependency(\"node\",n.center):null;i&&i.traverse((e=>{const t=this._createSpringBone(e,{radius:d,stiffnessForce:r,gravityDir:s,gravityPower:a,dragForce:l,colliders:h,center:o});u.push(t)}))}))))),o.push(u)}))))),o}))}_importColliderMeshGroups(e,t){return D(this,void 0,void 0,(function*(){const n=t.colliderGroups;if(void 0===n)return[];const i=[];return n.forEach((t=>D(this,void 0,void 0,(function*(){if(void 0===t.node||void 0===t.colliders)return;const n=yield e.parser.getDependency(\"node\",t.node),r=[];t.colliders.forEach((e=>{if(void 0===e.offset||void 0===e.offset.x||void 0===e.offset.y||void 0===e.offset.z||void 0===e.radius)return;const t=qe.set(e.offset.x,e.offset.y,-e.offset.z),i=this._createColliderMesh(e.radius,t);n.add(i),r.push(i)}));const o={node:t.node,colliders:r};i.push(o)})))),i}))}_createColliderMesh(e,t){const n=new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.SphereBufferGeometry(e,8,4),Ze);return n.position.copy(t),n.name=\"vrmColliderSphere\",n.geometry.computeBoundingSphere(),n}}class Je{constructor(e={}){this._metaImporter=e.metaImporter||new De,this._blendShapeImporter=e.blendShapeImporter||new J,this._lookAtImporter=e.lookAtImporter||new Se,this._humanoidImporter=e.humanoidImporter||new de,this._firstPersonImporter=e.firstPersonImporter||new ie,this._materialImporter=e.materialImporter||new Ne,this._springBoneImporter=e.springBoneImporter||new $e}import(e){return D(this,void 0,void 0,(function*(){if(void 0===e.parser.json.extensions||void 0===e.parser.json.extensions.VRM)throw new Error(\"Could not find VRM extension on the GLTF\");const t=e.scene;t.updateMatrixWorld(!1),t.traverse((e=>{e.isMesh&&(e.frustumCulled=!1)}));const n=(yield this._metaImporter.import(e))||void 0,i=(yield this._materialImporter.convertGLTFMaterials(e))||void 0,r=(yield this._humanoidImporter.import(e))||void 0,o=r&&(yield this._firstPersonImporter.import(e,r))||void 0,s=(yield this._blendShapeImporter.import(e))||void 0,a=o&&s&&r&&(yield this._lookAtImporter.import(e,o,s,r))||void 0,l=(yield this._springBoneImporter.import(e))||void 0;return new Qe({scene:e.scene,meta:n,materials:i,humanoid:r,firstPerson:o,blendShapeProxy:s,lookAt:a,springBoneManager:l})}))}}class Qe{constructor(e){this.scene=e.scene,this.humanoid=e.humanoid,this.blendShapeProxy=e.blendShapeProxy,this.firstPerson=e.firstPerson,this.lookAt=e.lookAt,this.materials=e.materials,this.springBoneManager=e.springBoneManager,this.meta=e.meta}static from(e,t={}){return D(this,void 0,void 0,(function*(){const n=new Je(t);return yield n.import(e)}))}update(e){this.lookAt&&this.lookAt.update(e),this.blendShapeProxy&&this.blendShapeProxy.update(),this.springBoneManager&&this.springBoneManager.lateUpdate(e),this.materials&&this.materials.forEach((t=>{t.updateVRMMaterials&&t.updateVRMMaterials(e)}))}dispose(){var e,t;const n=this.scene;n&&n.traverse(U),null===(t=null===(e=this.meta)||void 0===e?void 0:e.texture)||void 0===t||t.dispose()}}const Ke=new three__WEBPACK_IMPORTED_MODULE_0__.Vector2,et=new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-1,1,-1,1,-1,1),tt=new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({color:16777215,side:three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide}),nt=new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneBufferGeometry(2,2),tt),it=new three__WEBPACK_IMPORTED_MODULE_0__.Scene;it.add(nt);class rt{constructor(){}}rt.extractThumbnailBlob=function(e,t,n=512){var i;const r=null===(i=t.meta)||void 0===i?void 0:i.texture;if(!r)throw new Error(\"extractThumbnailBlob: This VRM does not have a thumbnail\");const o=e.getContext().canvas;e.getSize(Ke);const s=Ke.x,a=Ke.y;return e.setSize(n,n,!1),tt.map=r,e.render(it,et),tt.map=null,o instanceof OffscreenCanvas?o.convertToBlob().finally((()=>{e.setSize(s,a,!1)})):new Promise(((t,n)=>{o.toBlob((i=>{e.setSize(s,a,!1),null==i?n(\"extractThumbnailBlob: Failed to create a blob\"):t(i)}))}))},rt.removeUnnecessaryJoints=function(e){const t=new Map;e.traverse((e=>{if(\"SkinnedMesh\"!==e.type)return;const n=e,i=n.geometry.getAttribute(\"skinIndex\");let r=t.get(i);if(!r){const e=[],o=[],s={},l=i.array;for(let t=0;t<l.length;t++){const i=l[t];void 0===s[i]&&(s[i]=e.length,e.push(n.skeleton.bones[i]),o.push(n.skeleton.boneInverses[i])),l[t]=s[i]}i.copyArray(l),i.needsUpdate=!0,r=new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(e,o),t.set(i,r)}n.bind(r,new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4)}))};const ot=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3;class st extends ve{setupHelper(e,n){n.disableFaceDirectionHelper||(this._faceDirectionHelper=new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0,0,-1),new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0,0,0),.5,16711935),e.add(this._faceDirectionHelper))}update(e){super.update(e),this._faceDirectionHelper&&(this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position),this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(ot)))}}class at extends Se{import(e,t,n,i){var r;const o=null===(r=e.parser.json.extensions)||void 0===r?void 0:r.VRM;if(!o)return null;const s=o.firstPerson;if(!s)return null;const a=this._importApplyer(s,n,i);return new st(t,a||void 0)}}const lt=new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({color:16711935,wireframe:!0,transparent:!0,depthTest:!1});class dt extends Xe{setupHelper(e,t){t.disableSpringBoneHelper||(this.springBoneGroupList.forEach((t=>{t.forEach((t=>{if(t.getGizmo){const n=t.getGizmo();e.add(n)}}))})),this.colliderGroups.forEach((e=>{e.colliders.forEach((e=>{e.material=lt,e.renderOrder=mt}))})))}}const ht=new three__WEBPACK_IMPORTED_MODULE_0__.Vector3;class ut extends Ye{constructor(e,t){super(e,t)}getGizmo(){if(this._gizmo)return this._gizmo;const e=ht.copy(this._nextTail).sub(this._centerSpacePosition),t=e.length();return this._gizmo=new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(e.normalize(),this._centerSpacePosition,t,16776960,this.radius,this.radius),this._gizmo.line.renderOrder=mt,this._gizmo.cone.renderOrder=mt,this._gizmo.line.material.depthTest=!1,this._gizmo.line.material.transparent=!0,this._gizmo.cone.material.depthTest=!1,this._gizmo.cone.material.transparent=!0,this._gizmo}update(e){super.update(e),this._updateGizmo()}_updateGizmo(){if(!this._gizmo)return;const e=ht.copy(this._currentTail).sub(this._centerSpacePosition),t=e.length();this._gizmo.setDirection(e.normalize()),this._gizmo.setLength(t,this.radius,this.radius),this._gizmo.position.copy(this._centerSpacePosition)}}class ct extends $e{import(e){var t;return D(this,void 0,void 0,(function*(){const n=null===(t=e.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!n)return null;const i=n.secondaryAnimation;if(!i)return null;const r=yield this._importColliderMeshGroups(e,i),o=yield this._importSpringBoneGroupList(e,i,r);return new dt(r,o)}))}_createSpringBone(e,t){return new ut(e,t)}}class pt extends Je{constructor(e={}){e.lookAtImporter=e.lookAtImporter||new at,e.springBoneImporter=e.springBoneImporter||new ct,super(e)}import(e,t={}){return D(this,void 0,void 0,(function*(){if(void 0===e.parser.json.extensions||void 0===e.parser.json.extensions.VRM)throw new Error(\"Could not find VRM extension on the GLTF\");const n=e.scene;n.updateMatrixWorld(!1),n.traverse((e=>{e.isMesh&&(e.frustumCulled=!1)}));const i=(yield this._metaImporter.import(e))||void 0,r=(yield this._materialImporter.convertGLTFMaterials(e))||void 0,o=(yield this._humanoidImporter.import(e))||void 0,s=o&&(yield this._firstPersonImporter.import(e,o))||void 0,a=(yield this._blendShapeImporter.import(e))||void 0,l=s&&a&&o&&(yield this._lookAtImporter.import(e,s,a,o))||void 0;l.setupHelper&&l.setupHelper(n,t);const d=(yield this._springBoneImporter.import(e))||void 0;return d.setupHelper&&d.setupHelper(n,t),new ft({scene:e.scene,meta:i,materials:r,humanoid:o,firstPerson:s,blendShapeProxy:a,lookAt:l,springBoneManager:d},t)}))}}const mt=1e4;class ft extends Qe{static from(e,t={},n={}){return D(this,void 0,void 0,(function*(){const i=new pt(t);return yield i.import(e,n)}))}constructor(e,t={}){super(e),t.disableBoxHelper||this.scene.add(new three__WEBPACK_IMPORTED_MODULE_0__.BoxHelper(this.scene)),t.disableSkeletonHelper||this.scene.add(new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(this.scene))}update(e){super.update(e)}}\n\n\n//# sourceURL=webpack://vrm-test/./node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js?");

/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACESFilmicToneMapping\": () => (/* binding */ ACESFilmicToneMapping),\n/* harmony export */   \"AddEquation\": () => (/* binding */ AddEquation),\n/* harmony export */   \"AddOperation\": () => (/* binding */ AddOperation),\n/* harmony export */   \"AdditiveAnimationBlendMode\": () => (/* binding */ AdditiveAnimationBlendMode),\n/* harmony export */   \"AdditiveBlending\": () => (/* binding */ AdditiveBlending),\n/* harmony export */   \"AlphaFormat\": () => (/* binding */ AlphaFormat),\n/* harmony export */   \"AlwaysDepth\": () => (/* binding */ AlwaysDepth),\n/* harmony export */   \"AlwaysStencilFunc\": () => (/* binding */ AlwaysStencilFunc),\n/* harmony export */   \"AmbientLight\": () => (/* binding */ AmbientLight),\n/* harmony export */   \"AmbientLightProbe\": () => (/* binding */ AmbientLightProbe),\n/* harmony export */   \"AnimationClip\": () => (/* binding */ AnimationClip),\n/* harmony export */   \"AnimationLoader\": () => (/* binding */ AnimationLoader),\n/* harmony export */   \"AnimationMixer\": () => (/* binding */ AnimationMixer),\n/* harmony export */   \"AnimationObjectGroup\": () => (/* binding */ AnimationObjectGroup),\n/* harmony export */   \"AnimationUtils\": () => (/* binding */ AnimationUtils),\n/* harmony export */   \"ArcCurve\": () => (/* binding */ ArcCurve),\n/* harmony export */   \"ArrayCamera\": () => (/* binding */ ArrayCamera),\n/* harmony export */   \"ArrowHelper\": () => (/* binding */ ArrowHelper),\n/* harmony export */   \"Audio\": () => (/* binding */ Audio),\n/* harmony export */   \"AudioAnalyser\": () => (/* binding */ AudioAnalyser),\n/* harmony export */   \"AudioContext\": () => (/* binding */ AudioContext),\n/* harmony export */   \"AudioListener\": () => (/* binding */ AudioListener),\n/* harmony export */   \"AudioLoader\": () => (/* binding */ AudioLoader),\n/* harmony export */   \"AxesHelper\": () => (/* binding */ AxesHelper),\n/* harmony export */   \"AxisHelper\": () => (/* binding */ AxisHelper),\n/* harmony export */   \"BackSide\": () => (/* binding */ BackSide),\n/* harmony export */   \"BasicDepthPacking\": () => (/* binding */ BasicDepthPacking),\n/* harmony export */   \"BasicShadowMap\": () => (/* binding */ BasicShadowMap),\n/* harmony export */   \"BinaryTextureLoader\": () => (/* binding */ BinaryTextureLoader),\n/* harmony export */   \"Bone\": () => (/* binding */ Bone),\n/* harmony export */   \"BooleanKeyframeTrack\": () => (/* binding */ BooleanKeyframeTrack),\n/* harmony export */   \"BoundingBoxHelper\": () => (/* binding */ BoundingBoxHelper),\n/* harmony export */   \"Box2\": () => (/* binding */ Box2),\n/* harmony export */   \"Box3\": () => (/* binding */ Box3),\n/* harmony export */   \"Box3Helper\": () => (/* binding */ Box3Helper),\n/* harmony export */   \"BoxBufferGeometry\": () => (/* binding */ BoxGeometry),\n/* harmony export */   \"BoxGeometry\": () => (/* binding */ BoxGeometry),\n/* harmony export */   \"BoxHelper\": () => (/* binding */ BoxHelper),\n/* harmony export */   \"BufferAttribute\": () => (/* binding */ BufferAttribute),\n/* harmony export */   \"BufferGeometry\": () => (/* binding */ BufferGeometry),\n/* harmony export */   \"BufferGeometryLoader\": () => (/* binding */ BufferGeometryLoader),\n/* harmony export */   \"ByteType\": () => (/* binding */ ByteType),\n/* harmony export */   \"Cache\": () => (/* binding */ Cache),\n/* harmony export */   \"Camera\": () => (/* binding */ Camera),\n/* harmony export */   \"CameraHelper\": () => (/* binding */ CameraHelper),\n/* harmony export */   \"CanvasRenderer\": () => (/* binding */ CanvasRenderer),\n/* harmony export */   \"CanvasTexture\": () => (/* binding */ CanvasTexture),\n/* harmony export */   \"CatmullRomCurve3\": () => (/* binding */ CatmullRomCurve3),\n/* harmony export */   \"CineonToneMapping\": () => (/* binding */ CineonToneMapping),\n/* harmony export */   \"CircleBufferGeometry\": () => (/* binding */ CircleGeometry),\n/* harmony export */   \"CircleGeometry\": () => (/* binding */ CircleGeometry),\n/* harmony export */   \"ClampToEdgeWrapping\": () => (/* binding */ ClampToEdgeWrapping),\n/* harmony export */   \"Clock\": () => (/* binding */ Clock),\n/* harmony export */   \"Color\": () => (/* binding */ Color),\n/* harmony export */   \"ColorKeyframeTrack\": () => (/* binding */ ColorKeyframeTrack),\n/* harmony export */   \"CompressedTexture\": () => (/* binding */ CompressedTexture),\n/* harmony export */   \"CompressedTextureLoader\": () => (/* binding */ CompressedTextureLoader),\n/* harmony export */   \"ConeBufferGeometry\": () => (/* binding */ ConeGeometry),\n/* harmony export */   \"ConeGeometry\": () => (/* binding */ ConeGeometry),\n/* harmony export */   \"CubeCamera\": () => (/* binding */ CubeCamera),\n/* harmony export */   \"CubeReflectionMapping\": () => (/* binding */ CubeReflectionMapping),\n/* harmony export */   \"CubeRefractionMapping\": () => (/* binding */ CubeRefractionMapping),\n/* harmony export */   \"CubeTexture\": () => (/* binding */ CubeTexture),\n/* harmony export */   \"CubeTextureLoader\": () => (/* binding */ CubeTextureLoader),\n/* harmony export */   \"CubeUVReflectionMapping\": () => (/* binding */ CubeUVReflectionMapping),\n/* harmony export */   \"CubeUVRefractionMapping\": () => (/* binding */ CubeUVRefractionMapping),\n/* harmony export */   \"CubicBezierCurve\": () => (/* binding */ CubicBezierCurve),\n/* harmony export */   \"CubicBezierCurve3\": () => (/* binding */ CubicBezierCurve3),\n/* harmony export */   \"CubicInterpolant\": () => (/* binding */ CubicInterpolant),\n/* harmony export */   \"CullFaceBack\": () => (/* binding */ CullFaceBack),\n/* harmony export */   \"CullFaceFront\": () => (/* binding */ CullFaceFront),\n/* harmony export */   \"CullFaceFrontBack\": () => (/* binding */ CullFaceFrontBack),\n/* harmony export */   \"CullFaceNone\": () => (/* binding */ CullFaceNone),\n/* harmony export */   \"Curve\": () => (/* binding */ Curve),\n/* harmony export */   \"CurvePath\": () => (/* binding */ CurvePath),\n/* harmony export */   \"CustomBlending\": () => (/* binding */ CustomBlending),\n/* harmony export */   \"CustomToneMapping\": () => (/* binding */ CustomToneMapping),\n/* harmony export */   \"CylinderBufferGeometry\": () => (/* binding */ CylinderGeometry),\n/* harmony export */   \"CylinderGeometry\": () => (/* binding */ CylinderGeometry),\n/* harmony export */   \"Cylindrical\": () => (/* binding */ Cylindrical),\n/* harmony export */   \"DataTexture\": () => (/* binding */ DataTexture),\n/* harmony export */   \"DataTexture2DArray\": () => (/* binding */ DataTexture2DArray),\n/* harmony export */   \"DataTexture3D\": () => (/* binding */ DataTexture3D),\n/* harmony export */   \"DataTextureLoader\": () => (/* binding */ DataTextureLoader),\n/* harmony export */   \"DataUtils\": () => (/* binding */ DataUtils),\n/* harmony export */   \"DecrementStencilOp\": () => (/* binding */ DecrementStencilOp),\n/* harmony export */   \"DecrementWrapStencilOp\": () => (/* binding */ DecrementWrapStencilOp),\n/* harmony export */   \"DefaultLoadingManager\": () => (/* binding */ DefaultLoadingManager),\n/* harmony export */   \"DepthFormat\": () => (/* binding */ DepthFormat),\n/* harmony export */   \"DepthStencilFormat\": () => (/* binding */ DepthStencilFormat),\n/* harmony export */   \"DepthTexture\": () => (/* binding */ DepthTexture),\n/* harmony export */   \"DirectionalLight\": () => (/* binding */ DirectionalLight),\n/* harmony export */   \"DirectionalLightHelper\": () => (/* binding */ DirectionalLightHelper),\n/* harmony export */   \"DiscreteInterpolant\": () => (/* binding */ DiscreteInterpolant),\n/* harmony export */   \"DodecahedronBufferGeometry\": () => (/* binding */ DodecahedronGeometry),\n/* harmony export */   \"DodecahedronGeometry\": () => (/* binding */ DodecahedronGeometry),\n/* harmony export */   \"DoubleSide\": () => (/* binding */ DoubleSide),\n/* harmony export */   \"DstAlphaFactor\": () => (/* binding */ DstAlphaFactor),\n/* harmony export */   \"DstColorFactor\": () => (/* binding */ DstColorFactor),\n/* harmony export */   \"DynamicBufferAttribute\": () => (/* binding */ DynamicBufferAttribute),\n/* harmony export */   \"DynamicCopyUsage\": () => (/* binding */ DynamicCopyUsage),\n/* harmony export */   \"DynamicDrawUsage\": () => (/* binding */ DynamicDrawUsage),\n/* harmony export */   \"DynamicReadUsage\": () => (/* binding */ DynamicReadUsage),\n/* harmony export */   \"EdgesGeometry\": () => (/* binding */ EdgesGeometry),\n/* harmony export */   \"EdgesHelper\": () => (/* binding */ EdgesHelper),\n/* harmony export */   \"EllipseCurve\": () => (/* binding */ EllipseCurve),\n/* harmony export */   \"EqualDepth\": () => (/* binding */ EqualDepth),\n/* harmony export */   \"EqualStencilFunc\": () => (/* binding */ EqualStencilFunc),\n/* harmony export */   \"EquirectangularReflectionMapping\": () => (/* binding */ EquirectangularReflectionMapping),\n/* harmony export */   \"EquirectangularRefractionMapping\": () => (/* binding */ EquirectangularRefractionMapping),\n/* harmony export */   \"Euler\": () => (/* binding */ Euler),\n/* harmony export */   \"EventDispatcher\": () => (/* binding */ EventDispatcher),\n/* harmony export */   \"ExtrudeBufferGeometry\": () => (/* binding */ ExtrudeGeometry),\n/* harmony export */   \"ExtrudeGeometry\": () => (/* binding */ ExtrudeGeometry),\n/* harmony export */   \"FaceColors\": () => (/* binding */ FaceColors),\n/* harmony export */   \"FileLoader\": () => (/* binding */ FileLoader),\n/* harmony export */   \"FlatShading\": () => (/* binding */ FlatShading),\n/* harmony export */   \"Float16BufferAttribute\": () => (/* binding */ Float16BufferAttribute),\n/* harmony export */   \"Float32Attribute\": () => (/* binding */ Float32Attribute),\n/* harmony export */   \"Float32BufferAttribute\": () => (/* binding */ Float32BufferAttribute),\n/* harmony export */   \"Float64Attribute\": () => (/* binding */ Float64Attribute),\n/* harmony export */   \"Float64BufferAttribute\": () => (/* binding */ Float64BufferAttribute),\n/* harmony export */   \"FloatType\": () => (/* binding */ FloatType),\n/* harmony export */   \"Fog\": () => (/* binding */ Fog),\n/* harmony export */   \"FogExp2\": () => (/* binding */ FogExp2),\n/* harmony export */   \"Font\": () => (/* binding */ Font),\n/* harmony export */   \"FontLoader\": () => (/* binding */ FontLoader),\n/* harmony export */   \"FrontSide\": () => (/* binding */ FrontSide),\n/* harmony export */   \"Frustum\": () => (/* binding */ Frustum),\n/* harmony export */   \"GLBufferAttribute\": () => (/* binding */ GLBufferAttribute),\n/* harmony export */   \"GLSL1\": () => (/* binding */ GLSL1),\n/* harmony export */   \"GLSL3\": () => (/* binding */ GLSL3),\n/* harmony export */   \"GammaEncoding\": () => (/* binding */ GammaEncoding),\n/* harmony export */   \"GreaterDepth\": () => (/* binding */ GreaterDepth),\n/* harmony export */   \"GreaterEqualDepth\": () => (/* binding */ GreaterEqualDepth),\n/* harmony export */   \"GreaterEqualStencilFunc\": () => (/* binding */ GreaterEqualStencilFunc),\n/* harmony export */   \"GreaterStencilFunc\": () => (/* binding */ GreaterStencilFunc),\n/* harmony export */   \"GridHelper\": () => (/* binding */ GridHelper),\n/* harmony export */   \"Group\": () => (/* binding */ Group),\n/* harmony export */   \"HalfFloatType\": () => (/* binding */ HalfFloatType),\n/* harmony export */   \"HemisphereLight\": () => (/* binding */ HemisphereLight),\n/* harmony export */   \"HemisphereLightHelper\": () => (/* binding */ HemisphereLightHelper),\n/* harmony export */   \"HemisphereLightProbe\": () => (/* binding */ HemisphereLightProbe),\n/* harmony export */   \"IcosahedronBufferGeometry\": () => (/* binding */ IcosahedronGeometry),\n/* harmony export */   \"IcosahedronGeometry\": () => (/* binding */ IcosahedronGeometry),\n/* harmony export */   \"ImageBitmapLoader\": () => (/* binding */ ImageBitmapLoader),\n/* harmony export */   \"ImageLoader\": () => (/* binding */ ImageLoader),\n/* harmony export */   \"ImageUtils\": () => (/* binding */ ImageUtils),\n/* harmony export */   \"ImmediateRenderObject\": () => (/* binding */ ImmediateRenderObject),\n/* harmony export */   \"IncrementStencilOp\": () => (/* binding */ IncrementStencilOp),\n/* harmony export */   \"IncrementWrapStencilOp\": () => (/* binding */ IncrementWrapStencilOp),\n/* harmony export */   \"InstancedBufferAttribute\": () => (/* binding */ InstancedBufferAttribute),\n/* harmony export */   \"InstancedBufferGeometry\": () => (/* binding */ InstancedBufferGeometry),\n/* harmony export */   \"InstancedInterleavedBuffer\": () => (/* binding */ InstancedInterleavedBuffer),\n/* harmony export */   \"InstancedMesh\": () => (/* binding */ InstancedMesh),\n/* harmony export */   \"Int16Attribute\": () => (/* binding */ Int16Attribute),\n/* harmony export */   \"Int16BufferAttribute\": () => (/* binding */ Int16BufferAttribute),\n/* harmony export */   \"Int32Attribute\": () => (/* binding */ Int32Attribute),\n/* harmony export */   \"Int32BufferAttribute\": () => (/* binding */ Int32BufferAttribute),\n/* harmony export */   \"Int8Attribute\": () => (/* binding */ Int8Attribute),\n/* harmony export */   \"Int8BufferAttribute\": () => (/* binding */ Int8BufferAttribute),\n/* harmony export */   \"IntType\": () => (/* binding */ IntType),\n/* harmony export */   \"InterleavedBuffer\": () => (/* binding */ InterleavedBuffer),\n/* harmony export */   \"InterleavedBufferAttribute\": () => (/* binding */ InterleavedBufferAttribute),\n/* harmony export */   \"Interpolant\": () => (/* binding */ Interpolant),\n/* harmony export */   \"InterpolateDiscrete\": () => (/* binding */ InterpolateDiscrete),\n/* harmony export */   \"InterpolateLinear\": () => (/* binding */ InterpolateLinear),\n/* harmony export */   \"InterpolateSmooth\": () => (/* binding */ InterpolateSmooth),\n/* harmony export */   \"InvertStencilOp\": () => (/* binding */ InvertStencilOp),\n/* harmony export */   \"JSONLoader\": () => (/* binding */ JSONLoader),\n/* harmony export */   \"KeepStencilOp\": () => (/* binding */ KeepStencilOp),\n/* harmony export */   \"KeyframeTrack\": () => (/* binding */ KeyframeTrack),\n/* harmony export */   \"LOD\": () => (/* binding */ LOD),\n/* harmony export */   \"LatheBufferGeometry\": () => (/* binding */ LatheGeometry),\n/* harmony export */   \"LatheGeometry\": () => (/* binding */ LatheGeometry),\n/* harmony export */   \"Layers\": () => (/* binding */ Layers),\n/* harmony export */   \"LensFlare\": () => (/* binding */ LensFlare),\n/* harmony export */   \"LessDepth\": () => (/* binding */ LessDepth),\n/* harmony export */   \"LessEqualDepth\": () => (/* binding */ LessEqualDepth),\n/* harmony export */   \"LessEqualStencilFunc\": () => (/* binding */ LessEqualStencilFunc),\n/* harmony export */   \"LessStencilFunc\": () => (/* binding */ LessStencilFunc),\n/* harmony export */   \"Light\": () => (/* binding */ Light),\n/* harmony export */   \"LightProbe\": () => (/* binding */ LightProbe),\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"Line3\": () => (/* binding */ Line3),\n/* harmony export */   \"LineBasicMaterial\": () => (/* binding */ LineBasicMaterial),\n/* harmony export */   \"LineCurve\": () => (/* binding */ LineCurve),\n/* harmony export */   \"LineCurve3\": () => (/* binding */ LineCurve3),\n/* harmony export */   \"LineDashedMaterial\": () => (/* binding */ LineDashedMaterial),\n/* harmony export */   \"LineLoop\": () => (/* binding */ LineLoop),\n/* harmony export */   \"LinePieces\": () => (/* binding */ LinePieces),\n/* harmony export */   \"LineSegments\": () => (/* binding */ LineSegments),\n/* harmony export */   \"LineStrip\": () => (/* binding */ LineStrip),\n/* harmony export */   \"LinearEncoding\": () => (/* binding */ LinearEncoding),\n/* harmony export */   \"LinearFilter\": () => (/* binding */ LinearFilter),\n/* harmony export */   \"LinearInterpolant\": () => (/* binding */ LinearInterpolant),\n/* harmony export */   \"LinearMipMapLinearFilter\": () => (/* binding */ LinearMipMapLinearFilter),\n/* harmony export */   \"LinearMipMapNearestFilter\": () => (/* binding */ LinearMipMapNearestFilter),\n/* harmony export */   \"LinearMipmapLinearFilter\": () => (/* binding */ LinearMipmapLinearFilter),\n/* harmony export */   \"LinearMipmapNearestFilter\": () => (/* binding */ LinearMipmapNearestFilter),\n/* harmony export */   \"LinearToneMapping\": () => (/* binding */ LinearToneMapping),\n/* harmony export */   \"Loader\": () => (/* binding */ Loader),\n/* harmony export */   \"LoaderUtils\": () => (/* binding */ LoaderUtils),\n/* harmony export */   \"LoadingManager\": () => (/* binding */ LoadingManager),\n/* harmony export */   \"LogLuvEncoding\": () => (/* binding */ LogLuvEncoding),\n/* harmony export */   \"LoopOnce\": () => (/* binding */ LoopOnce),\n/* harmony export */   \"LoopPingPong\": () => (/* binding */ LoopPingPong),\n/* harmony export */   \"LoopRepeat\": () => (/* binding */ LoopRepeat),\n/* harmony export */   \"LuminanceAlphaFormat\": () => (/* binding */ LuminanceAlphaFormat),\n/* harmony export */   \"LuminanceFormat\": () => (/* binding */ LuminanceFormat),\n/* harmony export */   \"MOUSE\": () => (/* binding */ MOUSE),\n/* harmony export */   \"Material\": () => (/* binding */ Material),\n/* harmony export */   \"MaterialLoader\": () => (/* binding */ MaterialLoader),\n/* harmony export */   \"Math\": () => (/* binding */ MathUtils),\n/* harmony export */   \"MathUtils\": () => (/* binding */ MathUtils),\n/* harmony export */   \"Matrix3\": () => (/* binding */ Matrix3),\n/* harmony export */   \"Matrix4\": () => (/* binding */ Matrix4),\n/* harmony export */   \"MaxEquation\": () => (/* binding */ MaxEquation),\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh),\n/* harmony export */   \"MeshBasicMaterial\": () => (/* binding */ MeshBasicMaterial),\n/* harmony export */   \"MeshDepthMaterial\": () => (/* binding */ MeshDepthMaterial),\n/* harmony export */   \"MeshDistanceMaterial\": () => (/* binding */ MeshDistanceMaterial),\n/* harmony export */   \"MeshFaceMaterial\": () => (/* binding */ MeshFaceMaterial),\n/* harmony export */   \"MeshLambertMaterial\": () => (/* binding */ MeshLambertMaterial),\n/* harmony export */   \"MeshMatcapMaterial\": () => (/* binding */ MeshMatcapMaterial),\n/* harmony export */   \"MeshNormalMaterial\": () => (/* binding */ MeshNormalMaterial),\n/* harmony export */   \"MeshPhongMaterial\": () => (/* binding */ MeshPhongMaterial),\n/* harmony export */   \"MeshPhysicalMaterial\": () => (/* binding */ MeshPhysicalMaterial),\n/* harmony export */   \"MeshStandardMaterial\": () => (/* binding */ MeshStandardMaterial),\n/* harmony export */   \"MeshToonMaterial\": () => (/* binding */ MeshToonMaterial),\n/* harmony export */   \"MinEquation\": () => (/* binding */ MinEquation),\n/* harmony export */   \"MirroredRepeatWrapping\": () => (/* binding */ MirroredRepeatWrapping),\n/* harmony export */   \"MixOperation\": () => (/* binding */ MixOperation),\n/* harmony export */   \"MultiMaterial\": () => (/* binding */ MultiMaterial),\n/* harmony export */   \"MultiplyBlending\": () => (/* binding */ MultiplyBlending),\n/* harmony export */   \"MultiplyOperation\": () => (/* binding */ MultiplyOperation),\n/* harmony export */   \"NearestFilter\": () => (/* binding */ NearestFilter),\n/* harmony export */   \"NearestMipMapLinearFilter\": () => (/* binding */ NearestMipMapLinearFilter),\n/* harmony export */   \"NearestMipMapNearestFilter\": () => (/* binding */ NearestMipMapNearestFilter),\n/* harmony export */   \"NearestMipmapLinearFilter\": () => (/* binding */ NearestMipmapLinearFilter),\n/* harmony export */   \"NearestMipmapNearestFilter\": () => (/* binding */ NearestMipmapNearestFilter),\n/* harmony export */   \"NeverDepth\": () => (/* binding */ NeverDepth),\n/* harmony export */   \"NeverStencilFunc\": () => (/* binding */ NeverStencilFunc),\n/* harmony export */   \"NoBlending\": () => (/* binding */ NoBlending),\n/* harmony export */   \"NoColors\": () => (/* binding */ NoColors),\n/* harmony export */   \"NoToneMapping\": () => (/* binding */ NoToneMapping),\n/* harmony export */   \"NormalAnimationBlendMode\": () => (/* binding */ NormalAnimationBlendMode),\n/* harmony export */   \"NormalBlending\": () => (/* binding */ NormalBlending),\n/* harmony export */   \"NotEqualDepth\": () => (/* binding */ NotEqualDepth),\n/* harmony export */   \"NotEqualStencilFunc\": () => (/* binding */ NotEqualStencilFunc),\n/* harmony export */   \"NumberKeyframeTrack\": () => (/* binding */ NumberKeyframeTrack),\n/* harmony export */   \"Object3D\": () => (/* binding */ Object3D),\n/* harmony export */   \"ObjectLoader\": () => (/* binding */ ObjectLoader),\n/* harmony export */   \"ObjectSpaceNormalMap\": () => (/* binding */ ObjectSpaceNormalMap),\n/* harmony export */   \"OctahedronBufferGeometry\": () => (/* binding */ OctahedronGeometry),\n/* harmony export */   \"OctahedronGeometry\": () => (/* binding */ OctahedronGeometry),\n/* harmony export */   \"OneFactor\": () => (/* binding */ OneFactor),\n/* harmony export */   \"OneMinusDstAlphaFactor\": () => (/* binding */ OneMinusDstAlphaFactor),\n/* harmony export */   \"OneMinusDstColorFactor\": () => (/* binding */ OneMinusDstColorFactor),\n/* harmony export */   \"OneMinusSrcAlphaFactor\": () => (/* binding */ OneMinusSrcAlphaFactor),\n/* harmony export */   \"OneMinusSrcColorFactor\": () => (/* binding */ OneMinusSrcColorFactor),\n/* harmony export */   \"OrthographicCamera\": () => (/* binding */ OrthographicCamera),\n/* harmony export */   \"PCFShadowMap\": () => (/* binding */ PCFShadowMap),\n/* harmony export */   \"PCFSoftShadowMap\": () => (/* binding */ PCFSoftShadowMap),\n/* harmony export */   \"PMREMGenerator\": () => (/* binding */ PMREMGenerator),\n/* harmony export */   \"ParametricBufferGeometry\": () => (/* binding */ ParametricGeometry),\n/* harmony export */   \"ParametricGeometry\": () => (/* binding */ ParametricGeometry),\n/* harmony export */   \"Particle\": () => (/* binding */ Particle),\n/* harmony export */   \"ParticleBasicMaterial\": () => (/* binding */ ParticleBasicMaterial),\n/* harmony export */   \"ParticleSystem\": () => (/* binding */ ParticleSystem),\n/* harmony export */   \"ParticleSystemMaterial\": () => (/* binding */ ParticleSystemMaterial),\n/* harmony export */   \"Path\": () => (/* binding */ Path),\n/* harmony export */   \"PerspectiveCamera\": () => (/* binding */ PerspectiveCamera),\n/* harmony export */   \"Plane\": () => (/* binding */ Plane),\n/* harmony export */   \"PlaneBufferGeometry\": () => (/* binding */ PlaneGeometry),\n/* harmony export */   \"PlaneGeometry\": () => (/* binding */ PlaneGeometry),\n/* harmony export */   \"PlaneHelper\": () => (/* binding */ PlaneHelper),\n/* harmony export */   \"PointCloud\": () => (/* binding */ PointCloud),\n/* harmony export */   \"PointCloudMaterial\": () => (/* binding */ PointCloudMaterial),\n/* harmony export */   \"PointLight\": () => (/* binding */ PointLight),\n/* harmony export */   \"PointLightHelper\": () => (/* binding */ PointLightHelper),\n/* harmony export */   \"Points\": () => (/* binding */ Points),\n/* harmony export */   \"PointsMaterial\": () => (/* binding */ PointsMaterial),\n/* harmony export */   \"PolarGridHelper\": () => (/* binding */ PolarGridHelper),\n/* harmony export */   \"PolyhedronBufferGeometry\": () => (/* binding */ PolyhedronGeometry),\n/* harmony export */   \"PolyhedronGeometry\": () => (/* binding */ PolyhedronGeometry),\n/* harmony export */   \"PositionalAudio\": () => (/* binding */ PositionalAudio),\n/* harmony export */   \"PropertyBinding\": () => (/* binding */ PropertyBinding),\n/* harmony export */   \"PropertyMixer\": () => (/* binding */ PropertyMixer),\n/* harmony export */   \"QuadraticBezierCurve\": () => (/* binding */ QuadraticBezierCurve),\n/* harmony export */   \"QuadraticBezierCurve3\": () => (/* binding */ QuadraticBezierCurve3),\n/* harmony export */   \"Quaternion\": () => (/* binding */ Quaternion),\n/* harmony export */   \"QuaternionKeyframeTrack\": () => (/* binding */ QuaternionKeyframeTrack),\n/* harmony export */   \"QuaternionLinearInterpolant\": () => (/* binding */ QuaternionLinearInterpolant),\n/* harmony export */   \"REVISION\": () => (/* binding */ REVISION),\n/* harmony export */   \"RGBADepthPacking\": () => (/* binding */ RGBADepthPacking),\n/* harmony export */   \"RGBAFormat\": () => (/* binding */ RGBAFormat),\n/* harmony export */   \"RGBAIntegerFormat\": () => (/* binding */ RGBAIntegerFormat),\n/* harmony export */   \"RGBA_ASTC_10x10_Format\": () => (/* binding */ RGBA_ASTC_10x10_Format),\n/* harmony export */   \"RGBA_ASTC_10x5_Format\": () => (/* binding */ RGBA_ASTC_10x5_Format),\n/* harmony export */   \"RGBA_ASTC_10x6_Format\": () => (/* binding */ RGBA_ASTC_10x6_Format),\n/* harmony export */   \"RGBA_ASTC_10x8_Format\": () => (/* binding */ RGBA_ASTC_10x8_Format),\n/* harmony export */   \"RGBA_ASTC_12x10_Format\": () => (/* binding */ RGBA_ASTC_12x10_Format),\n/* harmony export */   \"RGBA_ASTC_12x12_Format\": () => (/* binding */ RGBA_ASTC_12x12_Format),\n/* harmony export */   \"RGBA_ASTC_4x4_Format\": () => (/* binding */ RGBA_ASTC_4x4_Format),\n/* harmony export */   \"RGBA_ASTC_5x4_Format\": () => (/* binding */ RGBA_ASTC_5x4_Format),\n/* harmony export */   \"RGBA_ASTC_5x5_Format\": () => (/* binding */ RGBA_ASTC_5x5_Format),\n/* harmony export */   \"RGBA_ASTC_6x5_Format\": () => (/* binding */ RGBA_ASTC_6x5_Format),\n/* harmony export */   \"RGBA_ASTC_6x6_Format\": () => (/* binding */ RGBA_ASTC_6x6_Format),\n/* harmony export */   \"RGBA_ASTC_8x5_Format\": () => (/* binding */ RGBA_ASTC_8x5_Format),\n/* harmony export */   \"RGBA_ASTC_8x6_Format\": () => (/* binding */ RGBA_ASTC_8x6_Format),\n/* harmony export */   \"RGBA_ASTC_8x8_Format\": () => (/* binding */ RGBA_ASTC_8x8_Format),\n/* harmony export */   \"RGBA_BPTC_Format\": () => (/* binding */ RGBA_BPTC_Format),\n/* harmony export */   \"RGBA_ETC2_EAC_Format\": () => (/* binding */ RGBA_ETC2_EAC_Format),\n/* harmony export */   \"RGBA_PVRTC_2BPPV1_Format\": () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),\n/* harmony export */   \"RGBA_PVRTC_4BPPV1_Format\": () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),\n/* harmony export */   \"RGBA_S3TC_DXT1_Format\": () => (/* binding */ RGBA_S3TC_DXT1_Format),\n/* harmony export */   \"RGBA_S3TC_DXT3_Format\": () => (/* binding */ RGBA_S3TC_DXT3_Format),\n/* harmony export */   \"RGBA_S3TC_DXT5_Format\": () => (/* binding */ RGBA_S3TC_DXT5_Format),\n/* harmony export */   \"RGBDEncoding\": () => (/* binding */ RGBDEncoding),\n/* harmony export */   \"RGBEEncoding\": () => (/* binding */ RGBEEncoding),\n/* harmony export */   \"RGBEFormat\": () => (/* binding */ RGBEFormat),\n/* harmony export */   \"RGBFormat\": () => (/* binding */ RGBFormat),\n/* harmony export */   \"RGBIntegerFormat\": () => (/* binding */ RGBIntegerFormat),\n/* harmony export */   \"RGBM16Encoding\": () => (/* binding */ RGBM16Encoding),\n/* harmony export */   \"RGBM7Encoding\": () => (/* binding */ RGBM7Encoding),\n/* harmony export */   \"RGB_ETC1_Format\": () => (/* binding */ RGB_ETC1_Format),\n/* harmony export */   \"RGB_ETC2_Format\": () => (/* binding */ RGB_ETC2_Format),\n/* harmony export */   \"RGB_PVRTC_2BPPV1_Format\": () => (/* binding */ RGB_PVRTC_2BPPV1_Format),\n/* harmony export */   \"RGB_PVRTC_4BPPV1_Format\": () => (/* binding */ RGB_PVRTC_4BPPV1_Format),\n/* harmony export */   \"RGB_S3TC_DXT1_Format\": () => (/* binding */ RGB_S3TC_DXT1_Format),\n/* harmony export */   \"RGFormat\": () => (/* binding */ RGFormat),\n/* harmony export */   \"RGIntegerFormat\": () => (/* binding */ RGIntegerFormat),\n/* harmony export */   \"RawShaderMaterial\": () => (/* binding */ RawShaderMaterial),\n/* harmony export */   \"Ray\": () => (/* binding */ Ray),\n/* harmony export */   \"Raycaster\": () => (/* binding */ Raycaster),\n/* harmony export */   \"RectAreaLight\": () => (/* binding */ RectAreaLight),\n/* harmony export */   \"RedFormat\": () => (/* binding */ RedFormat),\n/* harmony export */   \"RedIntegerFormat\": () => (/* binding */ RedIntegerFormat),\n/* harmony export */   \"ReinhardToneMapping\": () => (/* binding */ ReinhardToneMapping),\n/* harmony export */   \"RepeatWrapping\": () => (/* binding */ RepeatWrapping),\n/* harmony export */   \"ReplaceStencilOp\": () => (/* binding */ ReplaceStencilOp),\n/* harmony export */   \"ReverseSubtractEquation\": () => (/* binding */ ReverseSubtractEquation),\n/* harmony export */   \"RingBufferGeometry\": () => (/* binding */ RingGeometry),\n/* harmony export */   \"RingGeometry\": () => (/* binding */ RingGeometry),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x10_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x10_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x6_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x6_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x8_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x8_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_12x10_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_12x10_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_12x12_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_12x12_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_4x4_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_4x4_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_5x4_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_5x4_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_5x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_5x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_6x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_6x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_6x6_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_6x6_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_8x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_8x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_8x6_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_8x6_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_8x8_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_8x8_Format),\n/* harmony export */   \"Scene\": () => (/* binding */ Scene),\n/* harmony export */   \"SceneUtils\": () => (/* binding */ SceneUtils),\n/* harmony export */   \"ShaderChunk\": () => (/* binding */ ShaderChunk),\n/* harmony export */   \"ShaderLib\": () => (/* binding */ ShaderLib),\n/* harmony export */   \"ShaderMaterial\": () => (/* binding */ ShaderMaterial),\n/* harmony export */   \"ShadowMaterial\": () => (/* binding */ ShadowMaterial),\n/* harmony export */   \"Shape\": () => (/* binding */ Shape),\n/* harmony export */   \"ShapeBufferGeometry\": () => (/* binding */ ShapeGeometry),\n/* harmony export */   \"ShapeGeometry\": () => (/* binding */ ShapeGeometry),\n/* harmony export */   \"ShapePath\": () => (/* binding */ ShapePath),\n/* harmony export */   \"ShapeUtils\": () => (/* binding */ ShapeUtils),\n/* harmony export */   \"ShortType\": () => (/* binding */ ShortType),\n/* harmony export */   \"Skeleton\": () => (/* binding */ Skeleton),\n/* harmony export */   \"SkeletonHelper\": () => (/* binding */ SkeletonHelper),\n/* harmony export */   \"SkinnedMesh\": () => (/* binding */ SkinnedMesh),\n/* harmony export */   \"SmoothShading\": () => (/* binding */ SmoothShading),\n/* harmony export */   \"Sphere\": () => (/* binding */ Sphere),\n/* harmony export */   \"SphereBufferGeometry\": () => (/* binding */ SphereGeometry),\n/* harmony export */   \"SphereGeometry\": () => (/* binding */ SphereGeometry),\n/* harmony export */   \"Spherical\": () => (/* binding */ Spherical),\n/* harmony export */   \"SphericalHarmonics3\": () => (/* binding */ SphericalHarmonics3),\n/* harmony export */   \"SplineCurve\": () => (/* binding */ SplineCurve),\n/* harmony export */   \"SpotLight\": () => (/* binding */ SpotLight),\n/* harmony export */   \"SpotLightHelper\": () => (/* binding */ SpotLightHelper),\n/* harmony export */   \"Sprite\": () => (/* binding */ Sprite),\n/* harmony export */   \"SpriteMaterial\": () => (/* binding */ SpriteMaterial),\n/* harmony export */   \"SrcAlphaFactor\": () => (/* binding */ SrcAlphaFactor),\n/* harmony export */   \"SrcAlphaSaturateFactor\": () => (/* binding */ SrcAlphaSaturateFactor),\n/* harmony export */   \"SrcColorFactor\": () => (/* binding */ SrcColorFactor),\n/* harmony export */   \"StaticCopyUsage\": () => (/* binding */ StaticCopyUsage),\n/* harmony export */   \"StaticDrawUsage\": () => (/* binding */ StaticDrawUsage),\n/* harmony export */   \"StaticReadUsage\": () => (/* binding */ StaticReadUsage),\n/* harmony export */   \"StereoCamera\": () => (/* binding */ StereoCamera),\n/* harmony export */   \"StreamCopyUsage\": () => (/* binding */ StreamCopyUsage),\n/* harmony export */   \"StreamDrawUsage\": () => (/* binding */ StreamDrawUsage),\n/* harmony export */   \"StreamReadUsage\": () => (/* binding */ StreamReadUsage),\n/* harmony export */   \"StringKeyframeTrack\": () => (/* binding */ StringKeyframeTrack),\n/* harmony export */   \"SubtractEquation\": () => (/* binding */ SubtractEquation),\n/* harmony export */   \"SubtractiveBlending\": () => (/* binding */ SubtractiveBlending),\n/* harmony export */   \"TOUCH\": () => (/* binding */ TOUCH),\n/* harmony export */   \"TangentSpaceNormalMap\": () => (/* binding */ TangentSpaceNormalMap),\n/* harmony export */   \"TetrahedronBufferGeometry\": () => (/* binding */ TetrahedronGeometry),\n/* harmony export */   \"TetrahedronGeometry\": () => (/* binding */ TetrahedronGeometry),\n/* harmony export */   \"TextBufferGeometry\": () => (/* binding */ TextGeometry),\n/* harmony export */   \"TextGeometry\": () => (/* binding */ TextGeometry),\n/* harmony export */   \"Texture\": () => (/* binding */ Texture),\n/* harmony export */   \"TextureLoader\": () => (/* binding */ TextureLoader),\n/* harmony export */   \"TorusBufferGeometry\": () => (/* binding */ TorusGeometry),\n/* harmony export */   \"TorusGeometry\": () => (/* binding */ TorusGeometry),\n/* harmony export */   \"TorusKnotBufferGeometry\": () => (/* binding */ TorusKnotGeometry),\n/* harmony export */   \"TorusKnotGeometry\": () => (/* binding */ TorusKnotGeometry),\n/* harmony export */   \"Triangle\": () => (/* binding */ Triangle),\n/* harmony export */   \"TriangleFanDrawMode\": () => (/* binding */ TriangleFanDrawMode),\n/* harmony export */   \"TriangleStripDrawMode\": () => (/* binding */ TriangleStripDrawMode),\n/* harmony export */   \"TrianglesDrawMode\": () => (/* binding */ TrianglesDrawMode),\n/* harmony export */   \"TubeBufferGeometry\": () => (/* binding */ TubeGeometry),\n/* harmony export */   \"TubeGeometry\": () => (/* binding */ TubeGeometry),\n/* harmony export */   \"UVMapping\": () => (/* binding */ UVMapping),\n/* harmony export */   \"Uint16Attribute\": () => (/* binding */ Uint16Attribute),\n/* harmony export */   \"Uint16BufferAttribute\": () => (/* binding */ Uint16BufferAttribute),\n/* harmony export */   \"Uint32Attribute\": () => (/* binding */ Uint32Attribute),\n/* harmony export */   \"Uint32BufferAttribute\": () => (/* binding */ Uint32BufferAttribute),\n/* harmony export */   \"Uint8Attribute\": () => (/* binding */ Uint8Attribute),\n/* harmony export */   \"Uint8BufferAttribute\": () => (/* binding */ Uint8BufferAttribute),\n/* harmony export */   \"Uint8ClampedAttribute\": () => (/* binding */ Uint8ClampedAttribute),\n/* harmony export */   \"Uint8ClampedBufferAttribute\": () => (/* binding */ Uint8ClampedBufferAttribute),\n/* harmony export */   \"Uniform\": () => (/* binding */ Uniform),\n/* harmony export */   \"UniformsLib\": () => (/* binding */ UniformsLib),\n/* harmony export */   \"UniformsUtils\": () => (/* binding */ UniformsUtils),\n/* harmony export */   \"UnsignedByteType\": () => (/* binding */ UnsignedByteType),\n/* harmony export */   \"UnsignedInt248Type\": () => (/* binding */ UnsignedInt248Type),\n/* harmony export */   \"UnsignedIntType\": () => (/* binding */ UnsignedIntType),\n/* harmony export */   \"UnsignedShort4444Type\": () => (/* binding */ UnsignedShort4444Type),\n/* harmony export */   \"UnsignedShort5551Type\": () => (/* binding */ UnsignedShort5551Type),\n/* harmony export */   \"UnsignedShort565Type\": () => (/* binding */ UnsignedShort565Type),\n/* harmony export */   \"UnsignedShortType\": () => (/* binding */ UnsignedShortType),\n/* harmony export */   \"VSMShadowMap\": () => (/* binding */ VSMShadowMap),\n/* harmony export */   \"Vector2\": () => (/* binding */ Vector2),\n/* harmony export */   \"Vector3\": () => (/* binding */ Vector3),\n/* harmony export */   \"Vector4\": () => (/* binding */ Vector4),\n/* harmony export */   \"VectorKeyframeTrack\": () => (/* binding */ VectorKeyframeTrack),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex),\n/* harmony export */   \"VertexColors\": () => (/* binding */ VertexColors),\n/* harmony export */   \"VideoTexture\": () => (/* binding */ VideoTexture),\n/* harmony export */   \"WebGL1Renderer\": () => (/* binding */ WebGL1Renderer),\n/* harmony export */   \"WebGLCubeRenderTarget\": () => (/* binding */ WebGLCubeRenderTarget),\n/* harmony export */   \"WebGLMultipleRenderTargets\": () => (/* binding */ WebGLMultipleRenderTargets),\n/* harmony export */   \"WebGLMultisampleRenderTarget\": () => (/* binding */ WebGLMultisampleRenderTarget),\n/* harmony export */   \"WebGLRenderTarget\": () => (/* binding */ WebGLRenderTarget),\n/* harmony export */   \"WebGLRenderTargetCube\": () => (/* binding */ WebGLRenderTargetCube),\n/* harmony export */   \"WebGLRenderer\": () => (/* binding */ WebGLRenderer),\n/* harmony export */   \"WebGLUtils\": () => (/* binding */ WebGLUtils),\n/* harmony export */   \"WireframeGeometry\": () => (/* binding */ WireframeGeometry),\n/* harmony export */   \"WireframeHelper\": () => (/* binding */ WireframeHelper),\n/* harmony export */   \"WrapAroundEnding\": () => (/* binding */ WrapAroundEnding),\n/* harmony export */   \"XHRLoader\": () => (/* binding */ XHRLoader),\n/* harmony export */   \"ZeroCurvatureEnding\": () => (/* binding */ ZeroCurvatureEnding),\n/* harmony export */   \"ZeroFactor\": () => (/* binding */ ZeroFactor),\n/* harmony export */   \"ZeroSlopeEnding\": () => (/* binding */ ZeroSlopeEnding),\n/* harmony export */   \"ZeroStencilOp\": () => (/* binding */ ZeroStencilOp),\n/* harmony export */   \"sRGBEncoding\": () => (/* binding */ sRGBEncoding)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '130';\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst FlatShading = 1;\nconst SmoothShading = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst CubeUVRefractionMapping = 307;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedShort565Type = 1019;\nconst UnsignedInt248Type = 1020;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst RGBEFormat = RGBAFormat;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\nconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\nconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\nconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\nconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\nconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\nconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\nconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\nconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\nconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\nconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\nconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\nconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\nconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\nconst GammaEncoding = 3007;\nconst RGBEEncoding = 3002;\nconst LogLuvEncoding = 3003;\nconst RGBM7Encoding = 3004;\nconst RGBM16Encoding = 3005;\nconst RGBDEncoding = 3006;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [];\n\nfor ( let i = 0; i < 256; i ++ ) {\n\n\t_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\n\n}\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toUpperCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidian modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t\t } else {\n\n\t\treturn 0;\n\n\t\t }\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s % 2147483647;\n\n\t// Park-Miller algorithm\n\n\t_seed = _seed * 16807 % 2147483647;\n\n\treturn ( _seed - 1 ) / 2147483646;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nvar MathUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler\n});\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector2.prototype.isVector2 = true;\n\nclass Matrix3 {\n\n\tconstructor() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tscale( sx, sy ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tconst te = this.elements;\n\n\t\tconst a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\tconst a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\n\t\tte[ 0 ] = c * a11 + s * a21;\n\t\tte[ 3 ] = c * a12 + s * a22;\n\t\tte[ 6 ] = c * a13 + s * a23;\n\n\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\tte[ 7 ] = - s * a13 + c * a23;\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nMatrix3.prototype.isMatrix3 = true;\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement == 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n}\n\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.image = image;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tconst image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tlet url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( let i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t// check cube texture with data textures\n\n\t\t\t\t\t\tif ( image[ i ].isDataTexture ) {\n\n\t\t\t\t\t\t\turl.push( serializeImage( image[ i ].image ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\turl.push( serializeImage( image[ i ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = serializeImage( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype.isTexture = true;\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.prototype.slice.call( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\t\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector4.prototype.isVector4 = true;\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass WebGLRenderTarget extends EventDispatcher {\n\n\tconstructor( width, height, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tthis.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.texture.image = { width: width, height: height, depth: 1 };\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tsetTexture( texture ) {\n\n\t\ttexture.image = {\n\t\t\twidth: this.width,\n\t\t\theight: this.height,\n\t\t\tdepth: this.depth\n\t\t};\n\n\t\tthis.texture = texture;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\t\t\tthis.texture.image.depth = depth;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\t\tthis.texture.image = { ...this.texture.image }; // See #20328.\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n\n\tconstructor( width, height, count ) {\n\n\t\tsuper( width, height );\n\n\t\tconst texture = this.texture;\n\n\t\tthis.texture = [];\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.texture[ i ] = texture.clone();\n\n\t\t}\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.texture.length; i < il; i ++ ) {\n\n\t\t\t\tthis.texture[ i ].image.width = width;\n\t\t\t\tthis.texture[ i ].image.height = height;\n\t\t\t\tthis.texture[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.dispose();\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.viewport.set( 0, 0, this.width, this.height );\n\t\tthis.scissor.set( 0, 0, this.width, this.height );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\tthis.texture.length = 0;\n\n\t\tfor ( let i = 0, il = source.texture.length; i < il; i ++ ) {\n\n\t\t\tthis.texture[ i ] = source.texture[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nWebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;\n\nclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width, height, options ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.samples = 4;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy.call( this, source );\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n}\n\nWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerp( qa, qb, qm, t ) {\n\n\t\tconsole.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );\n\t\treturn qm.slerpQuaternions( qa, qb, t );\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize();\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\tthis.copy( qa ).slerp( qb, t );\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n}\n\nQuaternion.prototype.isQuaternion = true;\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector3.prototype.isVector3 = true;\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst x = array[ i ];\n\t\t\tconst y = array[ i + 1 ];\n\t\t\tconst z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\tconst x = attribute.getX( i );\n\t\t\tconst y = attribute.getY( i );\n\t\t\tconst z = attribute.getZ( i );\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\t_box$3.copy( geometry.boundingBox );\n\t\t\t_box$3.applyMatrix4( object.matrixWorld );\n\n\t\t\tthis.union( _box$3 );\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$3.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$3, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$3 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );\n\n\t\treturn clampedPoint.sub( point ).length();\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tthis.getCenter( target.center );\n\n\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nBox3.prototype.isBox3 = true;\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$3 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the seperating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is seperating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _toFarthestPoint = /*@__PURE__*/ new Vector3();\nconst _toPoint = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$2.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\n\t\t_toPoint.subVectors( point, this.center );\n\n\t\tconst lengthSq = _toPoint.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\t\t\tconst missingRadiusHalf = ( length - this.radius ) * 0.5;\n\n\t\t\t// Nudge this sphere towards the target point. Add half the missing distance to radius,\n\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\n\t\t\t// the whole missing distance were just added to radius.\n\n\t\t\tthis.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );\n\t\t\tthis.radius += missingRadiusHalf;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\n\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\n\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\n\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\n\n\t\t_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );\n\n\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );\n\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$2.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far ) {\n\n\t\tif ( far === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n\t\t}\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\t\tconst c = - ( far + near ) / ( far - near );\n\t\tconst d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\t\tconst z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nMatrix4.prototype.isMatrix4 = true;\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$1.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$1, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\ttoVector3( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n}\n\nEuler.prototype.isEuler = true;\n\nEuler.DefaultOrder = 'XYZ';\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = 1 << channel | 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeRender() {}\n\tonAfterRender() {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\tconst object = this.children[ i ];\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t}\n\n\t\tthis.children.length = 0;\n\n\t\treturn this;\n\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$1 );\n\n\t\tthis.add( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast() {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\nObject3D.DefaultMatrixAutoUpdate = true;\n\nObject3D.prototype.isObject3D = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$1 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\tthis.getBarycoord( point, a, b, c, _v3$1 );\n\n\t\treturn ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );\n\n\t}\n\n\tstatic getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\tthis.getBarycoord( point, p1, p2, p3, _v3$1 );\n\n\t\ttarget.set( 0, 0 );\n\t\ttarget.addScaledVector( uv1, _v3$1.x );\n\t\ttarget.addScaledVector( uv2, _v3$1.y );\n\t\ttarget.addScaledVector( uv3, _v3$1.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetUV( point, uv1, uv2, uv3, target ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nlet materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// for backward compatability if shading is set in the constructor\n\t\t\tif ( key === 'shading' ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\tdata.depthFunc = this.depthFunc;\n\t\tdata.depthTest = this.depthTest;\n\t\tdata.depthWrite = this.depthWrite;\n\t\tdata.colorWrite = this.colorWrite;\n\n\t\tdata.stencilWrite = this.stencilWrite;\n\t\tdata.stencilWriteMask = this.stencilWriteMask;\n\t\tdata.stencilFunc = this.stencilFunc;\n\t\tdata.stencilRef = this.stencilRef;\n\t\tdata.stencilFuncMask = this.stencilFuncMask;\n\t\tdata.stencilFail = this.stencilFail;\n\t\tdata.stencilZFail = this.stencilZFail;\n\t\tdata.stencilZPass = this.stencilZPass;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.morphTargets === true ) data.morphTargets = true;\n\t\tif ( this.morphNormals === true ) data.morphNormals = true;\n\n\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nMaterial.prototype.isMaterial = true;\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tset( value ) {\n\n\t\tif ( value && value.isColor ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tconst h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tconst s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tconst l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopyGammaToLinear( color, gammaFactor = 2.0 ) {\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToGamma( color, gammaFactor = 2.0 ) {\n\n\t\tconst safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t}\n\n\tconvertGammaToLinear( gammaFactor ) {\n\n\t\tthis.copyGammaToLinear( this, gammaFactor );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToGamma( gammaFactor ) {\n\n\t\tthis.copyLinearToGamma( this, gammaFactor );\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex() {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t}\n\n\tgetHexString() {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle() {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\t_hslA.h += h; _hslA.s += s; _hslA.l += l;\n\n\t\tthis.setHSL( _hslA.h, _hslA.s, _hslA.l );\n\n\t\treturn this;\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\tif ( attribute.normalized === true ) {\n\n\t\t\t// assuming Uint8Array\n\n\t\t\tthis.r /= 255;\n\t\t\tthis.g /= 255;\n\t\t\tthis.b /= 255;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n}\n\nColor.NAMES = _colorKeywords;\n\nColor.prototype.isColor = true;\nColor.prototype.r = 1;\nColor.prototype.g = 1;\nColor.prototype.b = 1;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  morphTargets: <bool>\n * }\n */\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tcopyColorsArray( colors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tlet color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyVector2sArray( vectors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tlet vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyVector3sArray( vectors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tlet vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyVector4sArray( vectors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tlet vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.x = this.getX( i );\n\t\t\t_vector$9.y = this.getY( i );\n\t\t\t_vector$9.z = this.getZ( i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.x = this.getX( i );\n\t\t\t_vector$9.y = this.getY( i );\n\t\t\t_vector$9.z = this.getZ( i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.x = this.getX( i );\n\t\t\t_vector$9.y = this.getY( i );\n\t\t\t_vector$9.z = this.getZ( i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.prototype.slice.call( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\t\tif ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;\n\n\t\treturn data;\n\n\t}\n\n}\n\nBufferAttribute.prototype.isBufferAttribute = true;\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float64BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float64Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tlet max = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$1.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$1.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$1.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$1.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$1.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$1.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$1.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$1.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$1.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$1.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$1.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeFaceNormals() {\n\n\t\t// backwards compatibility\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst indices = index.array;\n\t\tconst positions = attributes.position.array;\n\t\tconst normals = attributes.normal.array;\n\t\tconst uvs = attributes.uv.array;\n\n\t\tconst nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tconst tangents = attributes.tangent.array;\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tmerge( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tconst attribute1 = attributes[ key ];\n\t\t\tconst attributeArray1 = attribute1.array;\n\n\t\t\tconst attribute2 = geometry.attributes[ key ];\n\t\t\tconst attributeArray2 = attribute2.array;\n\n\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\tconst length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nBufferGeometry.prototype.isBufferGeometry = true;\n\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _tempB = /*@__PURE__*/ new Vector3();\nconst _tempC = /*@__PURE__*/ new Vector3();\n\nconst _morphA = /*@__PURE__*/ new Vector3();\nconst _morphB = /*@__PURE__*/ new Vector3();\nconst _morphC = /*@__PURE__*/ new Vector3();\n\nconst _uvA$1 = /*@__PURE__*/ new Vector2();\nconst _uvB$1 = /*@__PURE__*/ new Vector2();\nconst _uvC$1 = /*@__PURE__*/ new Vector2();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$3.copy( geometry.boundingSphere );\n\t\t_sphere$3.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// Check boundingBox before continuing\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\tlet intersection;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst uv = geometry.attributes.uv;\n\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t}\n\n}\n\nMesh.prototype.isMesh = true;\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\n\n\t_vA$1.fromBufferAttribute( position, a );\n\t_vB$1.fromBufferAttribute( position, b );\n\t_vC$1.fromBufferAttribute( position, c );\n\n\tconst morphInfluences = object.morphTargetInfluences;\n\n\tif ( material.morphTargets && morphPosition && morphInfluences ) {\n\n\t\t_morphA.set( 0, 0, 0 );\n\t\t_morphB.set( 0, 0, 0 );\n\t\t_morphC.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\tconst influence = morphInfluences[ i ];\n\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );\n\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );\n\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_vA$1.add( _morphA );\n\t\t_vB$1.add( _morphB );\n\t\t_vC$1.add( _morphC );\n\n\t}\n\n\tif ( object.isSkinnedMesh ) {\n\n\t\tobject.boneTransform( a, _vA$1 );\n\t\tobject.boneTransform( b, _vB$1 );\n\t\tobject.boneTransform( c, _vC$1 );\n\n\t}\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv2 ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv2, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv2, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv2, c );\n\n\t\t\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nCamera.prototype.isCamera = true;\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\nconst fov = 90, aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget !== true ) {\n\n\t\t\tconsole.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.renderTarget = renderTarget;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst renderTarget = this.renderTarget;\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0 );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1 );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2 );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3 );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4 );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5 );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\tformat = format !== undefined ? format : RGBFormat;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\t// Why CubeTexture._needsFlipEnvMap is necessary:\n\t\t//\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)\n\t\t// when using WebGLCubeRenderTarget.texture as a cube texture.\n\n\t\tthis._needsFlipEnvMap = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nCubeTexture.prototype.isCubeTexture = true;\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size, options, dummy ) {\n\n\t\tif ( Number.isInteger( options ) ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );\n\n\t\t\toptions = dummy;\n\n\t\t}\n\n\t\tsuper( size, size, options );\n\n\t\toptions = options || {};\n\n\t\tthis.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t\tthis.texture._needsFlipEnvMap = false;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.format = RGBAFormat; // see #18859\n\t\tthis.texture.encoding = texture.encoding;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nPlane.prototype.isPlane = true;\n\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$2 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$2.center.set( 0, 0, 0 );\n\t\t_sphere$2.radius = 0.7071067811865476;\n\t\t_sphere$2.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$2 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$7 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction WebGLAnimation() {\n\n\tlet context = null;\n\tlet isAnimating = false;\n\tlet animationLoop = null;\n\tlet requestId = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tanimationLoop( time, frame );\n\n\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tcontext.cancelAnimationFrame( requestId );\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLAttributes( gl, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type = 5126;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = 5126;\n\n\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\ttype = 5131;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttype = 5123;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = 5122;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = 5125;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = 5124;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = 5120;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = 5121;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = 5121;\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRange = attribute.updateRange;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, updateRange.offset, updateRange.count );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\t}\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\\tfloat invAlpha = 1.0 / roughness;\\n\\tfloat cos2h = NoH * NoH;\\n\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 H = normalize( V + L );\\n\\tfloat dotNH = saturate( dot( N, H ) );\\n\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = - mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\";\n\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n#ifdef CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheen;\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularRoughness;\\n\\tvec3 specularColor;\\n#ifdef CLEARCOAT\\n\\tfloat clearcoat;\\n\\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tccIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\\t\\t\\tmaterial.specularRoughness,\\n\\t\\t\\tdirectLight.direction,\\n\\t\\t\\tgeometry,\\n\\t\\t\\tmaterial.sheenColor\\n\\t\\t);\\n\\t#else\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\n\\t#endif\\n\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t\\tfloat ccDotNL = ccDotNV;\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\\t#ifdef CLEARCOAT\\n\\t\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\nvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\n\nvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\";\n\nvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\n\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\";\n\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\tfloat transmissionFactor = transmission;\\n\\tfloat thicknessFactor = thickness;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSNMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\\n\\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\\n\\t\\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationColor, attenuationDistance );\\n\\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\\n#endif\";\n\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec4 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\\n\\t\\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\\n\\t\\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\\n\\t\\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\\n\\t\\treturn normalize(refractionVector) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness(float roughness, float ior) {\\n\\t\\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\\n\\t}\\n\\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\\n\\t\\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\\n\\t\\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\\n\\t}\\n\\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tif (attenuationDistance == 0.0) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\\n\\t\\tvec3 attenuationColor, float attenuationDistance) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\\n\\t\\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\\n\\t}\\n#endif\";\n\nvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\nvar uv_vertex = \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\";\n\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define REFLECTIVITY\\n\\t#define CLEARCOAT\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform vec3 attenuationColor;\\n\\tuniform float attenuationDistance;\\n#endif\\n#ifdef REFLECTIVITY\\n\\tuniform float reflectivity;\\n#endif\\n#ifdef CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <transmission_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec4 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition;\\n#endif\\n}\";\n\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst ShaderChunk = {\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tencodings_fragment: encodings_fragment,\n\tencodings_pars_fragment: encodings_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_fragment: lightmap_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_vertex: lights_lambert_vertex,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_toon_fragment: lights_toon_fragment,\n\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\ttransmission_fragment: transmission_fragment,\n\ttransmission_pars_fragment: transmission_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tuv2_pars_fragment: uv2_pars_fragment,\n\tuv2_pars_vertex: uv2_pars_vertex,\n\tuv2_vertex: uv2_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_frag: background_frag,\n\tbackground_vert: background_vert,\n\tcube_frag: cube_frag,\n\tcube_vert: cube_vert,\n\tdepth_frag: depth_frag,\n\tdepth_vert: depth_vert,\n\tdistanceRGBA_frag: distanceRGBA_frag,\n\tdistanceRGBA_vert: distanceRGBA_vert,\n\tequirect_frag: equirect_frag,\n\tequirect_vert: equirect_vert,\n\tlinedashed_frag: linedashed_frag,\n\tlinedashed_vert: linedashed_vert,\n\tmeshbasic_frag: meshbasic_frag,\n\tmeshbasic_vert: meshbasic_vert,\n\tmeshlambert_frag: meshlambert_frag,\n\tmeshlambert_vert: meshlambert_vert,\n\tmeshmatcap_frag: meshmatcap_frag,\n\tmeshmatcap_vert: meshmatcap_vert,\n\tmeshtoon_frag: meshtoon_frag,\n\tmeshtoon_vert: meshtoon_vert,\n\tmeshphong_frag: meshphong_frag,\n\tmeshphong_vert: meshphong_vert,\n\tmeshphysical_frag: meshphysical_frag,\n\tmeshphysical_vert: meshphysical_vert,\n\tnormal_frag: normal_frag,\n\tnormal_vert: normal_vert,\n\tpoints_frag: points_frag,\n\tpoints_vert: points_vert,\n\tshadow_frag: shadow_frag,\n\tshadow_vert: shadow_vert,\n\tsprite_frag: sprite_frag,\n\tsprite_vert: sprite_vert\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() },\n\t\tuv2Transform: { value: new Matrix3() },\n\n\t\talphaMap: { value: null },\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 },\n\t\trefractionRatio: { value: 0.98 },\n\t\tmaxMipLevel: { value: 0 }\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {}\n\t\t} },\n\n\t\tdirectionalLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {}\n\t\t} },\n\n\t\tspotLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotShadowMap: { value: [] },\n\t\tspotShadowMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {}\n\t\t} },\n\n\t\tpointLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} },\n\n\t\tltc_1: { value: null },\n\t\tltc_2: { value: null }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t}\n\n};\n\nconst ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 1.0 },\n\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\ttoon: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.normal_vert,\n\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\tcube: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.envmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearcoat: { value: 0 },\n\t\t\tclearcoatMap: { value: null },\n\t\t\tclearcoatRoughness: { value: 0 },\n\t\t\tclearcoatRoughnessMap: { value: null },\n\t\t\tclearcoatNormalScale: { value: new Vector2( 1, 1 ) },\n\t\t\tclearcoatNormalMap: { value: null },\n\t\t\tsheen: { value: new Color( 0x000000 ) },\n\t\t\ttransmission: { value: 0 },\n\t\t\ttransmissionMap: { value: null },\n\t\t\ttransmissionSamplerSize: { value: new Vector2() },\n\t\t\ttransmissionSamplerMap: { value: null },\n\t\t\tthickness: { value: 0 },\n\t\t\tthicknessMap: { value: null },\n\t\t\tattenuationDistance: { value: 0 },\n\t\t\tattenuationColor: { value: new Color( 0x000000 ) }\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\nfunction WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = 0;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction render( renderList, scene ) {\n\n\t\tlet forceClear = false;\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tbackground = cubemaps.get( background );\n\n\t\t}\n\n\t\t// Ignore background in AR\n\t\t// TODO: Reconsider this.\n\n\t\tconst xr = renderer.xr;\n\t\tconst session = xr.getSession && xr.getSession();\n\n\t\tif ( session && session.environmentBlendMode === 'additive' ) {\n\n\t\t\tbackground = null;\n\n\t\t}\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.cube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render\n\n\t};\n\n}\n\nfunction WebGLBindingStates( gl, extensions, attributes, capabilities ) {\n\n\tconst maxVertexAttributes = gl.getParameter( 34921 );\n\n\tconst extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );\n\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tif ( vaoAvailable ) {\n\n\t\t\tconst state = getBindingState( geometry, program, material );\n\n\t\t\tif ( currentState !== state ) {\n\n\t\t\t\tcurrentState = state;\n\t\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t\t}\n\n\t\t\tupdateBuffers = needsUpdate( geometry, index );\n\n\t\t\tif ( updateBuffers ) saveCache( geometry, index );\n\n\t\t} else {\n\n\t\t\tconst wireframe = ( material.wireframe === true );\n\n\t\t\tif ( currentState.geometry !== geometry.id ||\n\t\t\t\tcurrentState.program !== program.id ||\n\t\t\t\tcurrentState.wireframe !== wireframe ) {\n\n\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\tcurrentState.program = program.id;\n\t\t\t\tcurrentState.wireframe = wireframe;\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh === true ) {\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, 34963 );\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( 34963, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.createVertexArray();\n\n\t\treturn extension.createVertexArrayOES();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );\n\n\t\treturn extension.bindVertexArrayOES( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\n\n\t\treturn extension.deleteVertexArrayOES( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( geometry, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tfor ( const key in geometryAttributes ) {\n\n\t\t\tconst cachedAttribute = cachedAttributes[ key ];\n\t\t\tconst geometryAttribute = geometryAttributes[ key ];\n\n\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\tif ( cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\tattributesNum ++;\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( geometry, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tconst data = {};\n\t\t\tdata.attribute = attribute;\n\n\t\t\tif ( attribute.data ) {\n\n\t\t\t\tdata.data = attribute.data;\n\n\t\t\t}\n\n\t\t\tcache[ key ] = data;\n\n\t\t\tattributesNum ++;\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset ) {\n\n\t\tif ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\n\n\t\t}\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tconst geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\tvertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\tvertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( name === 'instanceMatrix' ) {\n\n\t\t\t\t\tconst attribute = attributes.get( object.instanceMatrix );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 0, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 1, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 2, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 3, 1 );\n\n\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );\n\n\t\t\t\t} else if ( name === 'instanceColor' ) {\n\n\t\t\t\t\tconst attribute = attributes.get( object.instanceColor );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute, 1 );\n\n\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatilibity\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tlet extension, methodName;\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\textension = gl;\n\t\t\tmethodName = 'drawArraysInstanced';\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\tmethodName = 'drawArraysInstancedANGLE';\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ methodName ]( mode, start, count, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\tlet maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\t/* eslint-disable no-undef */\n\tconst isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||\n\t\t( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );\n\t/* eslint-enable no-undef */\n\n\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tconst maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tconst drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );\n\n\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tconst maxTextures = gl.getParameter( 34930 );\n\tconst maxVertexTextures = gl.getParameter( 35660 );\n\tconst maxTextureSize = gl.getParameter( 3379 );\n\tconst maxCubemapSize = gl.getParameter( 34076 );\n\n\tconst maxAttributes = gl.getParameter( 34921 );\n\tconst maxVertexUniforms = gl.getParameter( 36347 );\n\tconst maxVaryings = gl.getParameter( 36348 );\n\tconst maxFragmentUniforms = gl.getParameter( 36349 );\n\n\tconst vertexTextures = maxVertexTextures > 0;\n\tconst floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );\n\tconst floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\tconst maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;\n\n\treturn {\n\n\t\tisWebGL2: isWebGL2,\n\n\t\tdrawBuffers: drawBuffers,\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\tfloatVertexTextures: floatVertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\nfunction WebGLCubeMaps( renderer ) {\n\n\tlet cubemaps = new WeakMap();\n\n\tfunction mapTextureMapping( texture, mapping ) {\n\n\t\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\t\ttexture.mapping = CubeReflectionMapping;\n\n\t\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\t\ttexture.mapping = CubeRefractionMapping;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\tif ( cubemaps.has( texture ) ) {\n\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\tif ( image && image.height > 0 ) {\n\n\t\t\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget( image.height / 2 );\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\n\n\t\t\t\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemap = cubemaps.get( texture );\n\n\t\tif ( cubemap !== undefined ) {\n\n\t\t\tcubemaps.delete( texture );\n\t\t\tcubemap.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubemaps = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n\tconst extensions = {};\n\n\tfunction getExtension( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tlet extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t}\n\n\treturn {\n\n\t\thas: function ( name ) {\n\n\t\t\treturn getExtension( name ) !== null;\n\n\t\t},\n\n\t\tinit: function ( capabilities ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tgetExtension( 'EXT_color_buffer_float' );\n\n\t\t\t} else {\n\n\t\t\t\tgetExtension( 'WEBGL_depth_texture' );\n\t\t\t\tgetExtension( 'OES_texture_float' );\n\t\t\t\tgetExtension( 'OES_texture_half_float' );\n\t\t\t\tgetExtension( 'OES_texture_half_float_linear' );\n\t\t\t\tgetExtension( 'OES_standard_derivatives' );\n\t\t\t\tgetExtension( 'OES_element_index_uint' );\n\t\t\t\tgetExtension( 'OES_vertex_array_object' );\n\t\t\t\tgetExtension( 'ANGLE_instanced_arrays' );\n\n\t\t\t}\n\n\t\t\tgetExtension( 'OES_texture_float_linear' );\n\t\t\tgetExtension( 'EXT_color_buffer_half_float' );\n\n\t\t},\n\n\t\tget: function ( name ) {\n\n\t\t\tconst extension = getExtension( name );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = {};\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\tattributes.remove( geometry.index );\n\n\t\t}\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tattributes.remove( geometry.attributes[ name ] );\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tconst attribute = wireframeAttributes.get( geometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( geometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tif ( geometries[ geometry.id ] === true ) return geometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries[ geometry.id ] = true;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], 34962 );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], 34962 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tlet type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tlet extension, methodName;\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\textension = gl;\n\t\t\tmethodName = 'drawElementsInstanced';\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\tmethodName = 'drawElementsInstancedANGLE';\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\nfunction WebGLInfo( gl ) {\n\n\tconst memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tconst render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase 4:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.frame ++;\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\nfunction numericalSort( a, b ) {\n\n\treturn a[ 0 ] - b[ 0 ];\n\n}\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl ) {\n\n\tconst influencesList = {};\n\tconst morphInfluences = new Float32Array( 8 );\n\n\tconst workInfluences = [];\n\n\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\tworkInfluences[ i ] = [ i, 0 ];\n\n\t}\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\n\t\tlet influences = influencesList[ geometry.id ];\n\n\t\tif ( influences === undefined || influences.length !== length ) {\n\n\t\t\t// initialise list\n\n\t\t\tinfluences = [];\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t}\n\n\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t}\n\n\t\t// Collect influences\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst influence = influences[ i ];\n\n\t\t\tinfluence[ 0 ] = i;\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t}\n\n\t\tinfluences.sort( absNumericalSort );\n\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tif ( i < length && influences[ i ][ 1 ] ) {\n\n\t\t\t\tworkInfluences[ i ][ 0 ] = influences[ i ][ 0 ];\n\t\t\t\tworkInfluences[ i ][ 1 ] = influences[ i ][ 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tworkInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;\n\t\t\t\tworkInfluences[ i ][ 1 ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tworkInfluences.sort( numericalSort );\n\n\t\tconst morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\tconst morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst influence = workInfluences[ i ];\n\t\t\tconst index = influence[ 0 ];\n\t\t\tconst value = influence[ 1 ];\n\n\t\t\tif ( index !== Number.MAX_SAFE_INTEGER && value ) {\n\n\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\tmorphInfluencesSum += value;\n\n\t\t\t} else {\n\n\t\t\t\tif ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'morphTarget' + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\nfunction WebGLObjects( gl, geometries, attributes, info ) {\n\n\tlet updateMap = new WeakMap();\n\n\tfunction update( object ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\tconst geometry = object.geometry;\n\t\tconst buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateMap.get( buffergeometry ) !== frame ) {\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateMap.set( buffergeometry, frame );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\tif ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {\n\n\t\t\t\tobject.addEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\t\t}\n\n\t\t\tattributes.update( object.instanceMatrix, 34962 );\n\n\t\t\tif ( object.instanceColor !== null ) {\n\n\t\t\t\tattributes.update( object.instanceColor, 34962 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateMap = new WeakMap();\n\n\t}\n\n\tfunction onInstancedMeshDispose( event ) {\n\n\t\tconst instancedMesh = event.target;\n\n\t\tinstancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\tattributes.remove( instancedMesh.instanceMatrix );\n\n\t\tif ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass DataTexture2DArray extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\nclass DataTexture3D extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nDataTexture3D.prototype.isDataTexture3D = true;\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\nconst emptyTexture = new Texture();\nconst emptyTexture2dArray = new DataTexture2DArray();\nconst emptyTexture3d = new DataTexture3D();\nconst emptyCubeTexture = new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array( 16 );\nconst mat3array = new Float32Array( 9 );\nconst mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tconst firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tconst n = nBlocks * blockSize;\n\tlet r = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tlet r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\t}\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single integer / boolean\n\nfunction setValueV1i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single integer / boolean vector (from flat array)\n\nfunction setValueV2i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform2iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform3iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform4iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1ui( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single unsigned integer vector (from flat array)\n\nfunction setValueV2ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform2uiv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV3ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform3uiv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV4ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform4uiv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.safeSetTexture2D( v || emptyTexture, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || emptyTexture3d, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.safeSetTextureCube( v || emptyCubeTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyTexture2dArray, unit );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t\tcase 0x1405: return setValueV1ui; // UINT\n\t\tcase 0x8dc6: return setValueV2ui; // _VEC2\n\t\tcase 0x8dc7: return setValueV3ui; // _VEC3\n\t\tcase 0x8dc8: return setValueV4ui; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3D1;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArray1;\n\n\t}\n\n}\n\n\n// Array of scalars\n\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray( gl, v ) {\n\n\tgl.uniform1uiv( this.addr, v );\n\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray( gl, v ) {\n\n\tgl.uniform2uiv( this.addr, v );\n\n}\n\nfunction setValueV3uiArray( gl, v ) {\n\n\tgl.uniform3uiv( this.addr, v );\n\n}\n\nfunction setValueV4uiArray( gl, v ) {\n\n\tgl.uniform4uiv( this.addr, v );\n\n}\n\n\n// Array of textures (2D / Cube)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tgl.uniform1iv( this.addr, units );\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tgl.uniform1iv( this.addr, units );\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t\tcase 0x1405: return setValueV1uiArray; // UINT\n\t\tcase 0x8dc6: return setValueV2uiArray; // _VEC2\n\t\tcase 0x8dc7: return setValueV3uiArray; // _VEC3\n\t\tcase 0x8dc8: return setValueV4uiArray; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1Array;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6Array;\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nfunction SingleUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.size = activeInfo.size;\n\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nPureArrayUniform.prototype.updateCache = function ( data ) {\n\n\tconst cache = this.cache;\n\n\tif ( data instanceof Float32Array && cache.length !== data.length ) {\n\n\t\tthis.cache = new Float32Array( data.length );\n\n\t}\n\n\tcopyArray( cache, data );\n\n};\n\nfunction StructuredUniform( id ) {\n\n\tthis.id = id;\n\n\tthis.seq = [];\n\tthis.map = {};\n\n}\n\nStructuredUniform.prototype.setValue = function ( gl, value, textures ) {\n\n\tconst seq = this.seq;\n\n\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tconst u = seq[ i ];\n\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t}\n\n};\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tconst path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tconst match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex;\n\n\t\tlet id = match[ 1 ];\n\t\tconst idIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tconst map = container.map;\n\t\t\tlet next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nfunction WebGLUniforms( gl, program ) {\n\n\tthis.seq = [];\n\tthis.map = {};\n\n\tconst n = gl.getProgramParameter( program, 35718 );\n\n\tfor ( let i = 0; i < n; ++ i ) {\n\n\t\tconst info = gl.getActiveUniform( program, i ),\n\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\tparseUniform( info, addr, this );\n\n\t}\n\n}\n\nWebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {\n\n\tconst u = this.map[ name ];\n\n\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n};\n\nWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\n\n\tconst v = object[ name ];\n\n\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n};\n\n\n// Static interface\n\nWebGLUniforms.upload = function ( gl, seq, values, textures ) {\n\n\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tconst u = seq[ i ],\n\t\t\tv = values[ u.id ];\n\n\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t}\n\n\t}\n\n};\n\nWebGLUniforms.seqWithValue = function ( seq, values ) {\n\n\tconst r = [];\n\n\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tconst u = seq[ i ];\n\t\tif ( u.id in values ) r.push( u );\n\n\t}\n\n\treturn r;\n\n};\n\nfunction WebGLShader( gl, type, string ) {\n\n\tconst shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\nlet programIdCount = 0;\n\nfunction addLineNumbers( string ) {\n\n\tconst lines = string.split( '\\n' );\n\n\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t}\n\n\treturn lines.join( '\\n' );\n\n}\n\nfunction getEncodingComponents( encoding ) {\n\n\tswitch ( encoding ) {\n\n\t\tcase LinearEncoding:\n\t\t\treturn [ 'Linear', '( value )' ];\n\t\tcase sRGBEncoding:\n\t\t\treturn [ 'sRGB', '( value )' ];\n\t\tcase RGBEEncoding:\n\t\t\treturn [ 'RGBE', '( value )' ];\n\t\tcase RGBM7Encoding:\n\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\n\t\tcase RGBM16Encoding:\n\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\n\t\tcase RGBDEncoding:\n\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\n\t\tcase GammaEncoding:\n\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\n\t\tcase LogLuvEncoding:\n\t\t\treturn [ 'LogLuv', '( value )' ];\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );\n\t\t\treturn [ 'Linear', '( value )' ];\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tconst status = gl.getShaderParameter( shader, 35713 );\n\tconst log = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && log === '' ) return '';\n\n\t// --enable-privileged-webgl-extension\n\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\tconst source = gl.getShaderSource( shader );\n\n\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers( source );\n\n}\n\nfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\tconst components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\n\n}\n\nfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\tconst components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tlet toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tcase CustomToneMapping:\n\t\t\ttoneMappingName = 'Custom';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );\n\t\t\ttoneMappingName = 'Linear';\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateExtensions( parameters ) {\n\n\tconst chunks = [\n\t\t( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0 ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tconst chunks = [];\n\n\tfor ( const name in defines ) {\n\n\t\tconst value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tconst attributes = {};\n\n\tconst n = gl.getProgramParameter( program, 35721 );\n\n\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\tconst info = gl.getActiveAttrib( program, i );\n\t\tconst name = info.name;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\n\t\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\n\t\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes( string ) {\n\n\treturn string.replace( includePattern, includeReplacer );\n\n}\n\nfunction includeReplacer( match, include ) {\n\n\tconst string = ShaderChunk[ include ];\n\n\tif ( string === undefined ) {\n\n\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t}\n\n\treturn resolveIncludes( string );\n\n}\n\n// Unroll Loops\n\nconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops( string ) {\n\n\treturn string\n\t\t.replace( unrollLoopPattern, loopReplacer )\n\t\t.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );\n\n}\n\nfunction deprecatedLoopReplacer( match, start, end, snippet ) {\n\n\tconsole.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );\n\treturn loopReplacer( match, start, end, snippet );\n\n}\n\nfunction loopReplacer( match, start, end, snippet ) {\n\n\tlet string = '';\n\n\tfor ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\tstring += snippet\n\t\t\t.replace( /\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]' )\n\t\t\t.replace( /UNROLLED_LOOP_INDEX/g, i );\n\n\t}\n\n\treturn string;\n\n}\n\n//\n\nfunction generatePrecision( parameters ) {\n\n\tlet precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n\tif ( parameters.precision === 'highp' ) {\n\n\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\n\t} else if ( parameters.precision === 'mediump' ) {\n\n\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\n\t} else if ( parameters.precision === 'lowp' ) {\n\n\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\n\t}\n\n\treturn precisionstring;\n\n}\n\nfunction generateShadowMapTypeDefine( parameters ) {\n\n\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t} else if ( parameters.shadowMapType === VSMShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\n\t}\n\n\treturn shadowMapTypeDefine;\n\n}\n\nfunction generateEnvMapTypeDefine( parameters ) {\n\n\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapTypeDefine;\n\n}\n\nfunction generateEnvMapModeDefine( parameters ) {\n\n\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeRefractionMapping:\n\t\t\tcase CubeUVRefractionMapping:\n\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapModeDefine;\n\n}\n\nfunction generateEnvMapBlendingDefine( parameters ) {\n\n\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapBlendingDefine;\n\n}\n\nfunction WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {\n\n\tconst gl = renderer.getContext();\n\n\tconst defines = parameters.defines;\n\n\tlet vertexShader = parameters.vertexShader;\n\tlet fragmentShader = parameters.fragmentShader;\n\n\tconst shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\n\tconst envMapTypeDefine = generateEnvMapTypeDefine( parameters );\n\tconst envMapModeDefine = generateEnvMapModeDefine( parameters );\n\tconst envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\n\n\n\tconst gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\tconst customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );\n\n\tconst customDefines = generateDefines( defines );\n\n\tconst program = gl.createProgram();\n\n\tlet prefixVertex, prefixFragment;\n\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\tif ( parameters.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.instancing ? '#define USE_INSTANCING' : '',\n\t\t\tparameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\n\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',\n\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUvs ? '#define USE_UV' : '',\n\t\t\tparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t'#ifdef USE_INSTANCING',\n\n\t\t\t'\tattribute mat4 instanceMatrix;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_COLOR',\n\n\t\t\t'\tattribute vec3 instanceColor;',\n\n\t\t\t'#endif',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if defined( USE_COLOR_ALPHA )',\n\n\t\t\t'\tattribute vec4 color;',\n\n\t\t\t'#elif defined( USE_COLOR )',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\n\t\t\tparameters.sheen ? '#define USE_SHEEN' : '',\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUvs ? '#define USE_UV' : '',\n\t\t\tparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\n\t\t\tShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\tparameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',\n\t\t\tparameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\tparameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\tparameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',\n\t\t\tgetTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),\n\n\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = resolveIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = resolveIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {\n\n\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n\t\tversionString = '#version 300 es\\n';\n\n\t\tprefixVertex = [\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#define varying in',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tconst glVertexShader = WebGLShader( gl, 35633, vertexGlsl );\n\tconst glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( parameters.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\t// check for link errors\n\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\tconst programLog = gl.getProgramInfoLog( program ).trim();\n\t\tconst vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\tconst fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\tlet runnable = true;\n\t\tlet haveDiagnostics = true;\n\n\t\tif ( gl.getProgramParameter( program, 35714 ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconst vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\tconst fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// Clean up\n\n\t// Crashes in iOS9 and iOS10. #18402\n\t// gl.detachShader( program, glVertexShader );\n\t// gl.detachShader( program, glFragmentShader );\n\n\tgl.deleteShader( glVertexShader );\n\tgl.deleteShader( glFragmentShader );\n\n\t// set up caching for uniform locations\n\n\tlet cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tlet cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tbindingStates.releaseStatesOfProgram( this );\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.name = parameters.shaderName;\n\tthis.id = programIdCount ++;\n\tthis.cacheKey = cacheKey;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\nfunction WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {\n\n\tconst programs = [];\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\tconst floatVertexTextures = capabilities.floatVertexTextures;\n\tconst maxVertexUniforms = capabilities.maxVertexUniforms;\n\tconst vertexTextures = capabilities.vertexTextures;\n\n\tlet precision = capabilities.precision;\n\n\tconst shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'toon',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tconst parameterNames = [\n\t\t'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',\n\t\t'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',\n\t\t'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',\n\t\t'roughnessMap', 'metalnessMap', 'gradientMap',\n\t\t'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',\n\t\t'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',\n\t\t'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',\n\t\t'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',\n\t\t'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',\n\t\t'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',\n\t\t'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',\n\t\t'sheen', 'transmission', 'transmissionMap', 'thicknessMap'\n\t];\n\n\tfunction getMaxBones( object ) {\n\n\t\tconst skeleton = object.skeleton;\n\t\tconst bones = skeleton.bones;\n\n\t\tif ( floatVertexTextures ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tconst nVertexUniforms = maxVertexUniforms;\n\t\t\tconst nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tconst maxBones = Math.min( nVertexMatrices, bones.length );\n\n\t\t\tif ( maxBones < bones.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map ) {\n\n\t\tlet encoding;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\\'t use render targets as textures. Use their .texture property instead.' );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t} else {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tfunction getParameters( material, lights, shadows, scene, object ) {\n\n\t\tconst fog = scene.fog;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\n\t\tconst envMap = cubemaps.get( material.envMap || environment );\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tconst maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet vertexShader, fragmentShader;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\n\t\t\tvertexShader = shader.vertexShader;\n\t\t\tfragmentShader = shader.fragmentShader;\n\n\t\t} else {\n\n\t\t\tvertexShader = material.vertexShader;\n\t\t\tfragmentShader = material.fragmentShader;\n\n\t\t}\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tconst parameters = {\n\n\t\t\tisWebGL2: isWebGL2,\n\n\t\t\tshaderID: shaderID,\n\t\t\tshaderName: material.type,\n\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tdefines: material.defines,\n\n\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\tglslVersion: material.glslVersion,\n\n\t\t\tprecision: precision,\n\n\t\t\tinstancing: object.isInstancedMesh === true,\n\t\t\tinstancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n\n\t\t\tsupportsVertexTextures: vertexTextures,\n\t\t\toutputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map ),\n\t\t\tmatcap: !! material.matcap,\n\t\t\tmatcapEncoding: getTextureEncodingFromMap( material.matcap ),\n\t\t\tenvMap: !! envMap,\n\t\t\tenvMapMode: envMap && envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( envMap ),\n\t\t\tenvMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\tlightMapEncoding: getTextureEncodingFromMap( material.lightMap ),\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\ttangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n\t\t\tclearcoatMap: !! material.clearcoatMap,\n\t\t\tclearcoatRoughnessMap: !! material.clearcoatRoughnessMap,\n\t\t\tclearcoatNormalMap: !! material.clearcoatNormalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tgradientMap: !! material.gradientMap,\n\n\t\t\tsheen: !! material.sheen,\n\n\t\t\ttransmission: !! material.transmission,\n\t\t\ttransmissionMap: !! material.transmissionMap,\n\t\t\tthicknessMap: !! material.thicknessMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexTangents: ( material.normalMap && material.vertexTangents ),\n\t\t\tvertexColors: material.vertexColors,\n\t\t\tvertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n\t\t\tvertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap,\n\t\t\tuvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmission || !! material.transmissionMap || !! material.thicknessMap ) && !! material.displacementMap,\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp2: ( fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: !! material.flatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tskinning: object.isSkinnedMesh === true && maxBones > 0,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: floatVertexTextures,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\n\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\tnumClipIntersection: clipping.numIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,\n\n\t\t\tindex0AttributeName: material.index0AttributeName,\n\n\t\t\textensionDerivatives: material.extensions && material.extensions.derivatives,\n\t\t\textensionFragDepth: material.extensions && material.extensions.fragDepth,\n\t\t\textensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n\t\t\textensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n\n\t\t\trendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),\n\t\t\trendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),\n\t\t\trendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),\n\n\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\n\t\t};\n\n\t\treturn parameters;\n\n\t}\n\n\tfunction getProgramCacheKey( parameters ) {\n\n\t\tconst array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( parameters.fragmentShader );\n\t\t\tarray.push( parameters.vertexShader );\n\n\t\t}\n\n\t\tif ( parameters.defines !== undefined ) {\n\n\t\t\tfor ( const name in parameters.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( parameters.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.isRawShaderMaterial === false ) {\n\n\t\t\tfor ( let i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\tarray.push( renderer.outputEncoding );\n\t\t\tarray.push( renderer.gammaFactor );\n\n\t\t}\n\n\t\tarray.push( parameters.customProgramCacheKey );\n\n\t\treturn array.join();\n\n\t}\n\n\tfunction getUniforms( material ) {\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\t\tlet uniforms;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\t\t\tuniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t} else {\n\n\t\t\tuniforms = material.uniforms;\n\n\t\t}\n\n\t\treturn uniforms;\n\n\t}\n\n\tfunction acquireProgram( parameters, cacheKey ) {\n\n\t\tlet program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( let p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tconst preexistingProgram = programs[ p ];\n\n\t\t\tif ( preexistingProgram.cacheKey === cacheKey ) {\n\n\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\tfunction releaseProgram( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tconst i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tgetParameters: getParameters,\n\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\tgetUniforms: getUniforms,\n\t\tacquireProgram: acquireProgram,\n\t\treleaseProgram: releaseProgram,\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tprograms: programs\n\t};\n\n}\n\nfunction WebGLProperties() {\n\n\tlet properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tlet map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.program !== b.program ) {\n\n\t\treturn a.program.id - b.program.id;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList( properties ) {\n\n\tconst renderItems = [];\n\tlet renderItemsIndex = 0;\n\n\tconst opaque = [];\n\tconst transmissive = [];\n\tconst transparent = [];\n\n\tconst defaultProgram = { id: - 1 };\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransmissive.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tlet renderItem = renderItems[ renderItemsIndex ];\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tprogram: materialProperties.program || defaultProgram,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.program = materialProperties.program || defaultProgram;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.push( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.unshift( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction sort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfunction finish() {\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.program = null;\n\t\t\trenderItem.group = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\topaque: opaque,\n\t\ttransmissive: transmissive,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\t\tfinish: finish,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists( properties ) {\n\n\tlet lists = new WeakMap();\n\n\tfunction get( scene, renderCallDepth ) {\n\n\t\tlet list;\n\n\t\tif ( lists.has( scene ) === false ) {\n\n\t\t\tlist = new WebGLRenderList( properties );\n\t\t\tlists.set( scene, [ list ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= lists.get( scene ).length ) {\n\n\t\t\t\tlist = new WebGLRenderList( properties );\n\t\t\t\tlists.get( scene ).push( list );\n\n\t\t\t} else {\n\n\t\t\t\tlist = lists.get( scene )[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions, capabilities ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: []\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tconst vector3 = new Vector3();\n\tconst matrix4 = new Matrix4();\n\tconst matrix42 = new Matrix4();\n\n\tfunction setup( lights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\n\t\tlights.sort( shadowCastingLightsFirst );\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\t// (a) intensity is the total visible light emitted\n\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\n\t\t\t\t// (b) intensity is the brightness of the light\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t// WebGL 2\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\t// WebGL 1\n\n\t\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t\t} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotShadowMatrix.length = numSpotShadows;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\nfunction WebGLRenderState( extensions, capabilities ) {\n\n\tconst lights = new WebGLLights( extensions, capabilities );\n\n\tconst lightsArray = [];\n\tconst shadowsArray = [];\n\n\tfunction init() {\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights() {\n\n\t\tlights.setup( lightsArray );\n\n\t}\n\n\tfunction setupLightsView( camera ) {\n\n\t\tlights.setupView( lightsArray, camera );\n\n\t}\n\n\tconst state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tlights: lights\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\t\tsetupLightsView: setupLightsView,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates( extensions, capabilities ) {\n\n\tlet renderStates = new WeakMap();\n\n\tfunction get( scene, renderCallDepth = 0 ) {\n\n\t\tlet renderState;\n\n\t\tif ( renderStates.has( scene ) === false ) {\n\n\t\t\trenderState = new WebGLRenderState( extensions, capabilities );\n\t\t\trenderStates.set( scene, [ renderState ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= renderStates.get( scene ).length ) {\n\n\t\t\t\trenderState = new WebGLRenderState( extensions, capabilities );\n\t\t\t\trenderStates.get( scene ).push( renderState );\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStates.get( scene )[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n/**\n * parameters = {\n *\n *  referencePosition: <float>,\n *  nearDistance: <float>,\n *  farDistance: <float>,\n *\n *  morphTargets: <bool>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>\n *\n * }\n */\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.referencePosition = new Vector3();\n\t\tthis.nearDistance = 1;\n\t\tthis.farDistance = 1000;\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.fog = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.referencePosition.copy( source.referencePosition );\n\t\tthis.nearDistance = source.nearDistance;\n\t\tthis.farDistance = source.farDistance;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\nvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean * HALF_SAMPLE_RATE;\\n\\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\nvar vsm_vert = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nfunction WebGLShadowMap( _renderer, _objects, _capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterials = [],\n\t\t_distanceMaterials = [],\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\tconst shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\n\t\tdefines: {\n\t\t\tSAMPLE_RATE: 2.0 / 8.0,\n\t\t\tHALF_SAMPLE_RATE: 1.0 / 8.0\n\t\t},\n\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vsm_vert,\n\n\t\tfragmentShader: vsm_frag\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\tconst _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\n\n\t\t\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tconst pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadow.map );\n\t\t\t_renderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\tscope.needsUpdate = false;\n\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = _objects.update( fullScreenMesh );\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.mapPass );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.map );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterialVariant( useMorphing ) {\n\n\t\tconst index = useMorphing << 0;\n\n\t\tlet material = _depthMaterials[ index ];\n\n\t\tif ( material === undefined ) {\n\n\t\t\tmaterial = new MeshDepthMaterial( {\n\n\t\t\t\tdepthPacking: RGBADepthPacking,\n\n\t\t\t\tmorphTargets: useMorphing\n\n\t\t\t} );\n\n\t\t\t_depthMaterials[ index ] = material;\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tfunction getDistanceMaterialVariant( useMorphing ) {\n\n\t\tconst index = useMorphing << 0;\n\n\t\tlet material = _distanceMaterials[ index ];\n\n\t\tif ( material === undefined ) {\n\n\t\t\tmaterial = new MeshDistanceMaterial( {\n\n\t\t\t\tmorphTargets: useMorphing\n\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ index ] = material;\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tfunction getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {\n\n\t\tlet result = null;\n\n\t\tlet getMaterialVariant = getDepthMaterialVariant;\n\t\tlet customMaterial = object.customDepthMaterial;\n\n\t\tif ( light.isPointLight === true ) {\n\n\t\t\tgetMaterialVariant = getDistanceMaterialVariant;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( customMaterial === undefined ) {\n\n\t\t\tlet useMorphing = false;\n\n\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t}\n\n\t\t\tresult = getMaterialVariant( useMorphing );\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tresult.referencePosition.setFromMatrixPosition( light.matrixWorld );\n\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = _objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n}\n\nfunction WebGLState( gl, extensions, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tfunction ColorBuffer() {\n\n\t\tlet locked = false;\n\n\t\tconst color = new Vector4();\n\t\tlet currentColorMask = null;\n\t\tconst currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentDepthMask = null;\n\t\tlet currentDepthFunc = null;\n\t\tlet currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( 2929 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( 2929 );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 512 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 519 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 513 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 514 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 518 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 516 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 517 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentStencilMask = null;\n\t\tlet currentStencilFunc = null;\n\t\tlet currentStencilRef = null;\n\t\tlet currentStencilFuncMask = null;\n\t\tlet currentStencilFail = null;\n\t\tlet currentStencilZFail = null;\n\t\tlet currentStencilZPass = null;\n\t\tlet currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( ! locked ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( 2960 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( 2960 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef !== stencilRef ||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail !== stencilFail ||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tconst colorBuffer = new ColorBuffer();\n\tconst depthBuffer = new DepthBuffer();\n\tconst stencilBuffer = new StencilBuffer();\n\n\tlet enabledCapabilities = {};\n\n\tlet xrFramebuffer = null;\n\tlet currentBoundFramebuffers = {};\n\n\tlet currentProgram = null;\n\n\tlet currentBlendingEnabled = false;\n\tlet currentBlending = null;\n\tlet currentBlendEquation = null;\n\tlet currentBlendSrc = null;\n\tlet currentBlendDst = null;\n\tlet currentBlendEquationAlpha = null;\n\tlet currentBlendSrcAlpha = null;\n\tlet currentBlendDstAlpha = null;\n\tlet currentPremultipledAlpha = false;\n\n\tlet currentFlipSided = null;\n\tlet currentCullFace = null;\n\n\tlet currentLineWidth = null;\n\n\tlet currentPolygonOffsetFactor = null;\n\tlet currentPolygonOffsetUnits = null;\n\n\tconst maxTextures = gl.getParameter( 35661 );\n\n\tlet lineWidthAvailable = false;\n\tlet version = 0;\n\tconst glVersion = gl.getParameter( 7938 );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL ES (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tlet currentTextureSlot = null;\n\tlet currentBoundTextures = {};\n\n\tconst scissorParam = gl.getParameter( 3088 );\n\tconst viewportParam = gl.getParameter( 2978 );\n\n\tconst currentScissor = new Vector4().fromArray( scissorParam );\n\tconst currentViewport = new Vector4().fromArray( viewportParam );\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tconst data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tconst texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, 10241, 9728 );\n\t\tgl.texParameteri( type, 10240, 9728 );\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tconst emptyTextures = {};\n\temptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );\n\temptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( 2929 );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( 2884 );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction bindXRFramebuffer( framebuffer ) {\n\n\t\tif ( framebuffer !== xrFramebuffer ) {\n\n\t\t\tgl.bindFramebuffer( 36160, framebuffer );\n\n\t\t\txrFramebuffer = framebuffer;\n\n\t\t}\n\n\t}\n\n\tfunction bindFramebuffer( target, framebuffer ) {\n\n\t\tif ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t// 36009 is equivalent to 36160\n\n\t\t\t\tif ( target === 36009 ) {\n\n\t\t\t\t\tcurrentBoundFramebuffers[ 36160 ] = framebuffer;\n\n\t\t\t\t}\n\n\t\t\t\tif ( target === 36160 ) {\n\n\t\t\t\t\tcurrentBoundFramebuffers[ 36009 ] = framebuffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst equationToGL = {\n\t\t[ AddEquation ]: 32774,\n\t\t[ SubtractEquation ]: 32778,\n\t\t[ ReverseSubtractEquation ]: 32779\n\t};\n\n\tif ( isWebGL2 ) {\n\n\t\tequationToGL[ MinEquation ] = 32775;\n\t\tequationToGL[ MaxEquation ] = 32776;\n\n\t} else {\n\n\t\tconst extension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tequationToGL[ MinEquation ] = extension.MIN_EXT;\n\t\t\tequationToGL[ MaxEquation ] = extension.MAX_EXT;\n\n\t\t}\n\n\t}\n\n\tconst factorToGL = {\n\t\t[ ZeroFactor ]: 0,\n\t\t[ OneFactor ]: 1,\n\t\t[ SrcColorFactor ]: 768,\n\t\t[ SrcAlphaFactor ]: 770,\n\t\t[ SrcAlphaSaturateFactor ]: 776,\n\t\t[ DstColorFactor ]: 774,\n\t\t[ DstAlphaFactor ]: 772,\n\t\t[ OneMinusSrcColorFactor ]: 769,\n\t\t[ OneMinusSrcAlphaFactor ]: 771,\n\t\t[ OneMinusDstColorFactor ]: 775,\n\t\t[ OneMinusDstAlphaFactor ]: 773\n\t};\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled === true ) {\n\n\t\t\t\tdisable( 3042 );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( currentBlendingEnabled === false ) {\n\n\t\t\tenable( 3042 );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( 32774 );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 1, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 0, 769, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 768, 0, 770 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 770, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 770, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 769 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 768 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = null;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( 2884 )\n\t\t\t: enable( 2884 );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tstencilBuffer.setTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( material.stencilWriteMask );\n\t\t\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true\n\t\t\t? enable( 32926 )\n\t\t\t: disable( 32926 );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( 2304 );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( 2305 );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( 2884 );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( 1029 );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( 1028 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( 1032 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 2884 );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( 32823 );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 32823 );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( 3089 );\n\n\t\t} else {\n\n\t\t\tdisable( 3089 );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\tactiveTexture();\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction unbindTexture() {\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\t// reset state\n\n\t\tgl.disable( 3042 );\n\t\tgl.disable( 2884 );\n\t\tgl.disable( 2929 );\n\t\tgl.disable( 32823 );\n\t\tgl.disable( 3089 );\n\t\tgl.disable( 2960 );\n\t\tgl.disable( 32926 );\n\n\t\tgl.blendEquation( 32774 );\n\t\tgl.blendFunc( 1, 0 );\n\t\tgl.blendFuncSeparate( 1, 0, 1, 0 );\n\n\t\tgl.colorMask( true, true, true, true );\n\t\tgl.clearColor( 0, 0, 0, 0 );\n\n\t\tgl.depthMask( true );\n\t\tgl.depthFunc( 513 );\n\t\tgl.clearDepth( 1 );\n\n\t\tgl.stencilMask( 0xffffffff );\n\t\tgl.stencilFunc( 519, 0, 0xffffffff );\n\t\tgl.stencilOp( 7680, 7680, 7680 );\n\t\tgl.clearStencil( 0 );\n\n\t\tgl.cullFace( 1029 );\n\t\tgl.frontFace( 2305 );\n\n\t\tgl.polygonOffset( 0, 0 );\n\n\t\tgl.activeTexture( 33984 );\n\n\t\tgl.bindFramebuffer( 36160, null );\n\n\t\tif ( isWebGL2 === true ) {\n\n\t\t\tgl.bindFramebuffer( 36009, null );\n\t\t\tgl.bindFramebuffer( 36008, null );\n\n\t\t}\n\n\t\tgl.useProgram( null );\n\n\t\tgl.lineWidth( 1 );\n\n\t\tgl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tgl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\t// reset internals\n\n\t\tenabledCapabilities = {};\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\txrFramebuffer = null;\n\t\tcurrentBoundFramebuffers = {};\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlendingEnabled = false;\n\t\tcurrentBlending = null;\n\t\tcurrentBlendEquation = null;\n\t\tcurrentBlendSrc = null;\n\t\tcurrentBlendDst = null;\n\t\tcurrentBlendEquationAlpha = null;\n\t\tcurrentBlendSrcAlpha = null;\n\t\tcurrentBlendDstAlpha = null;\n\t\tcurrentPremultipledAlpha = false;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcurrentLineWidth = null;\n\n\t\tcurrentPolygonOffsetFactor = null;\n\t\tcurrentPolygonOffsetUnits = null;\n\n\t\tcurrentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tcurrentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tenable: enable,\n\t\tdisable: disable,\n\n\t\tbindFramebuffer: bindFramebuffer,\n\t\tbindXRFramebuffer: bindXRFramebuffer,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tunbindTexture: unbindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\tconst maxTextures = capabilities.maxTextures;\n\tconst maxCubemapSize = capabilities.maxCubemapSize;\n\tconst maxTextureSize = capabilities.maxTextureSize;\n\tconst maxSamples = capabilities.maxSamples;\n\n\tconst _videoTextures = new WeakMap();\n\tlet _canvas;\n\n\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\tlet useOffscreenCanvas = false;\n\n\ttry {\n\n\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\n\t\t\t&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;\n\n\t} catch ( err ) {\n\n\t\t// Ignore any errors\n\n\t}\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\tnew OffscreenCanvas( width, height ) :\n\t\t\tdocument.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {\n\n\t\tlet scale = 1;\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( image.width, image.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 || needsPowerOfTwo === true ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\tconst floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n\n\t\t\t\tconst width = floor( scale * image.width );\n\t\t\t\tconst height = floor( scale * image.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tconst canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo$1( image ) {\n\n\t\treturn isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( isWebGL2 ) return false;\n\n\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture, supportsMips ) {\n\n\t\treturn texture.generateMipmaps && supportsMips &&\n\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target, texture, width, height, depth = 1 ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\ttextureProperties.__maxMipLevel = Math.log2( Math.max( width, height, depth ) );\n\n\t}\n\n\tfunction getInternalFormat( internalFormatName, glFormat, glType ) {\n\n\t\tif ( isWebGL2 === false ) return glFormat;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === 6403 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 33326;\n\t\t\tif ( glType === 5131 ) internalFormat = 33325;\n\t\t\tif ( glType === 5121 ) internalFormat = 33321;\n\n\t\t}\n\n\t\tif ( glFormat === 6407 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34837;\n\t\t\tif ( glType === 5131 ) internalFormat = 34843;\n\t\t\tif ( glType === 5121 ) internalFormat = 32849;\n\n\t\t}\n\n\t\tif ( glFormat === 6408 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34836;\n\t\t\tif ( glType === 5131 ) internalFormat = 34842;\n\t\t\tif ( glType === 5121 ) internalFormat = 32856;\n\n\t\t}\n\n\t\tif ( internalFormat === 33325 || internalFormat === 33326 ||\n\t\t\tinternalFormat === 34842 || internalFormat === 34836 ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback( f ) {\n\n\t\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\n\n\t\t\treturn 9728;\n\n\t\t}\n\n\t\treturn 9729;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t_videoTextures.delete( texture );\n\n\t\t}\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tconst renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\tinfo.memory.textures --;\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\t\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLMultipleRenderTargets ) {\n\n\t\t\tfor ( let i = 0, il = texture.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachmentProperties = properties.get( texture[ i ] );\n\n\t\t\t\tif ( attachmentProperties.__webglTexture ) {\n\n\t\t\t\t\t_gl.deleteTexture( attachmentProperties.__webglTexture );\n\n\t\t\t\t\tinfo.memory.textures --;\n\n\t\t\t\t}\n\n\t\t\t\tproperties.remove( texture[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tlet textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tconst textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tconst image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 3553, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 35866, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 32879, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadCubeTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\n\t}\n\n\tconst wrappingToGL = {\n\t\t[ RepeatWrapping ]: 10497,\n\t\t[ ClampToEdgeWrapping ]: 33071,\n\t\t[ MirroredRepeatWrapping ]: 33648\n\t};\n\n\tconst filterToGL = {\n\t\t[ NearestFilter ]: 9728,\n\t\t[ NearestMipmapNearestFilter ]: 9984,\n\t\t[ NearestMipmapLinearFilter ]: 9986,\n\n\t\t[ LinearFilter ]: 9729,\n\t\t[ LinearMipmapNearestFilter ]: 9985,\n\t\t[ LinearMipmapLinearFilter ]: 9987\n\t};\n\n\tfunction setTextureParameters( textureType, texture, supportsMips ) {\n\n\t\tif ( supportsMips ) {\n\n\t\t\t_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );\n\t\t\t_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );\n\n\t\t\tif ( textureType === 32879 || textureType === 35866 ) {\n\n\t\t\t\t_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );\n\t\t\t_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, 10242, 33071 );\n\t\t\t_gl.texParameteri( textureType, 10243, 33071 );\n\n\t\t\tif ( textureType === 32879 || textureType === 35866 ) {\n\n\t\t\t\t_gl.texParameteri( textureType, 32882, 33071 );\n\n\t\t\t}\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\t\t\tif ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tlet textureType = 3553;\n\n\t\tif ( texture.isDataTexture2DArray ) textureType = 35866;\n\t\tif ( texture.isDataTexture3D ) textureType = 32879;\n\n\t\tinitTexture( textureProperties, texture );\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( 37440, texture.flipY );\n\t\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, texture.unpackAlignment );\n\t\t_gl.pixelStorei( 37443, 0 );\n\n\t\tconst needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;\n\t\tconst image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );\n\n\t\tconst supportsMips = isPowerOfTwo$1( image ) || isWebGL2,\n\t\t\tglFormat = utils.convert( texture.format );\n\n\t\tlet glType = utils.convert( texture.type ),\n\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\tsetTextureParameters( textureType, texture, supportsMips );\n\n\t\tlet mipmap;\n\t\tconst mipmaps = texture.mipmaps;\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tglInternalFormat = 6402;\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tglInternalFormat = 36012;\n\n\t\t\t\t} else if ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\tglInternalFormat = 33190;\n\n\t\t\t\t} else if ( texture.type === UnsignedInt248Type ) {\n\n\t\t\t\t\tglInternalFormat = 35056;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tconsole.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// validation checks for WebGL 1\n\n\t\t\tif ( texture.format === DepthFormat && glInternalFormat === 6402 ) {\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tglInternalFormat = 34041;\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t} else if ( texture.isDataTexture2DArray ) {\n\n\t\t\tstate.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else if ( texture.isDataTexture3D ) {\n\n\t\t\tstate.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tgenerateMipmap( textureType, texture, image.width, image.height );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\tfunction uploadCubeTexture( textureProperties, texture, slot ) {\n\n\t\tif ( texture.image.length !== 6 ) return;\n\n\t\tinitTexture( textureProperties, texture );\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( 37440, texture.flipY );\n\t\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, texture.unpackAlignment );\n\t\t_gl.pixelStorei( 37443, 0 );\n\n\t\tconst isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );\n\t\tconst isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\tconst cubeImage = [];\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );\n\n\t\t\t} else {\n\n\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst image = cubeImage[ 0 ],\n\t\t\tsupportsMips = isPowerOfTwo$1( image ) || isWebGL2,\n\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\tglType = utils.convert( texture.type ),\n\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\tsetTextureParameters( 34067, texture, supportsMips );\n\n\t\tlet mipmaps;\n\n\t\tif ( isCompressed ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tmipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t} else {\n\n\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\t\tconst mipmapImage = mipmap.image[ i ].image;\n\n\t\t\t\t\t\tstate.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\tstate.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length;\n\n\t\t}\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t// We assume images for cube map have the same size.\n\t\t\tgenerateMipmap( 34067, texture, image.width, image.height );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {\n\n\t\tconst glFormat = utils.convert( texture.format );\n\t\tconst glType = utils.convert( texture.type );\n\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\tif ( textureTarget === 32879 || textureTarget === 35866 ) {\n\n\t\t\tstate.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );\n\n\t\t} else {\n\n\t\t\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( 36160, framebuffer );\n\t\t_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );\n\t\tstate.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( 36161, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = 33189;\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === FloatType ) {\n\n\t\t\t\t\t\tglInternalFormat = 36012;\n\n\t\t\t\t\t} else if ( depthTexture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\tglInternalFormat = 33190;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// Use the first texture for MRT so far\n\t\t\tconst texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;\n\n\t\t\tconst glFormat = utils.convert( texture.format );\n\t\t\tconst glType = utils.convert( texture.type );\n\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tconst isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tconst webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tif ( renderTarget.isWebGLMultipleRenderTargets !== true ) {\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\t\tconst isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );\n\t\tconst isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );\n\t\tconst isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n\t\tconst supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;\n\n\t\t// Handles WebGL2 RGBFormat fallback - #18858\n\n\t\tif ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {\n\n\t\t\ttexture.format = RGBAFormat;\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );\n\n\t\t}\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tif ( capabilities.drawBuffers ) {\n\n\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\t\t\t\tif ( attachmentProperties.__webglTexture === undefined ) {\n\n\t\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );\n\n\t\t\t\t}\n\n\t\t\t} else if ( isMultisample ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );\n\n\t\t\t\t\tconst glFormat = utils.convert( texture.format );\n\t\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\t\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.bindFramebuffer( 36160, null );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( 34067, texture, supportsMips );\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 34067, texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 34067, null );\n\n\t\t} else if ( isMultipleRenderTargets ) {\n\n\t\t\tconst textures = renderTarget.texture;\n\n\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachment = textures[ i ];\n\t\t\t\tconst attachmentProperties = properties.get( attachment );\n\n\t\t\t\tstate.bindTexture( 3553, attachmentProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( 3553, attachment, supportsMips );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {\n\n\t\t\t\t\tgenerateMipmap( 3553, attachment, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 3553, null );\n\n\t\t} else {\n\n\t\t\tlet glTextureType = 3553;\n\n\t\t\tif ( isRenderTarget3D ) {\n\n\t\t\t\t// Render targets containing layers, i.e: Texture 3D and 2d arrays\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\tconst isTexture3D = texture.isDataTexture3D;\n\t\t\t\t\tglTextureType = isTexture3D ? 32879 : 35866;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( glTextureType, texture, supportsMips );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tconst supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;\n\n\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\n\t\t\t\tconst webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\tgenerateMipmap( target, texture, renderTarget.width, renderTarget.height );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tconst width = renderTarget.width;\n\t\t\t\tconst height = renderTarget.height;\n\t\t\t\tlet mask = 16384;\n\n\t\t\t\tif ( renderTarget.depthBuffer ) mask |= 256;\n\t\t\t\tif ( renderTarget.stencilBuffer ) mask |= 1024;\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tstate.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\tstate.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );\n\n\t\t\t\tstate.bindFramebuffer( 36008, null );\n\t\t\t\tstate.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?\n\t\t\tMath.min( maxSamples, renderTarget.samples ) : 0;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures.get( texture ) !== frame ) {\n\n\t\t\t_videoTextures.set( texture, frame );\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\t// backwards compatibility\n\n\tlet warnedTexture2D = false;\n\tlet warnedTextureCube = false;\n\n\tfunction safeSetTexture2D( texture, slot ) {\n\n\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\tif ( warnedTexture2D === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.' );\n\t\t\t\twarnedTexture2D = true;\n\n\t\t\t}\n\n\t\t\ttexture = texture.texture;\n\n\t\t}\n\n\t\tsetTexture2D( texture, slot );\n\n\t}\n\n\tfunction safeSetTextureCube( texture, slot ) {\n\n\t\tif ( texture && texture.isWebGLCubeRenderTarget ) {\n\n\t\t\tif ( warnedTextureCube === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.' );\n\t\t\t\twarnedTextureCube = true;\n\n\t\t\t}\n\n\t\t\ttexture = texture.texture;\n\n\t\t}\n\n\n\t\tsetTextureCube( texture, slot );\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\n\tthis.safeSetTexture2D = safeSetTexture2D;\n\tthis.safeSetTextureCube = safeSetTextureCube;\n\n}\n\nfunction WebGLUtils( gl, extensions, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tfunction convert( p ) {\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return 5121;\n\t\tif ( p === UnsignedShort4444Type ) return 32819;\n\t\tif ( p === UnsignedShort5551Type ) return 32820;\n\t\tif ( p === UnsignedShort565Type ) return 33635;\n\n\t\tif ( p === ByteType ) return 5120;\n\t\tif ( p === ShortType ) return 5122;\n\t\tif ( p === UnsignedShortType ) return 5123;\n\t\tif ( p === IntType ) return 5124;\n\t\tif ( p === UnsignedIntType ) return 5125;\n\t\tif ( p === FloatType ) return 5126;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\tif ( isWebGL2 ) return 5131;\n\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.HALF_FLOAT_OES;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return 6406;\n\t\tif ( p === RGBFormat ) return 6407;\n\t\tif ( p === RGBAFormat ) return 6408;\n\t\tif ( p === LuminanceFormat ) return 6409;\n\t\tif ( p === LuminanceAlphaFormat ) return 6410;\n\t\tif ( p === DepthFormat ) return 6402;\n\t\tif ( p === DepthStencilFormat ) return 34041;\n\t\tif ( p === RedFormat ) return 6403;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedIntegerFormat ) return 36244;\n\t\tif ( p === RGFormat ) return 33319;\n\t\tif ( p === RGIntegerFormat ) return 33320;\n\t\tif ( p === RGBIntegerFormat ) return 36248;\n\t\tif ( p === RGBAIntegerFormat ) return 36249;\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\t// TODO Complete?\n\n\t\t\t\treturn p;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\t// TODO Complete?\n\n\t\t\t\treturn p;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\tif ( isWebGL2 ) return 34042;\n\n\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nArrayCamera.prototype.isArrayCamera = true;\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nGroup.prototype.isGroup = true;\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n\n\tconstructor() {\n\n\t\tthis._targetRay = null;\n\t\tthis._grip = null;\n\t\tthis._hand = null;\n\n\t}\n\n\tgetHandSpace() {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t}\n\n\tgetTargetRaySpace() {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t}\n\n\tgetGripSpace() {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\tthis._grip.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdate( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\n\t\t\t\t\tif ( inputPose.linearVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\ttargetRay.linearVelocity.copy( inputPose.linearVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( inputPose.angularVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\ttargetRay.angularVelocity.copy( inputPose.angularVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _moveEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\t\tconst joint = new Group();\n\t\t\t\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\t\t\t\tjoint.visible = false;\n\t\t\t\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\t\t\t\t\t\t// ??\n\t\t\t\t\t\thand.add( joint );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst joint = hand.joints[ inputjoint.jointName ];\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\n\t\t\t\t\t\tif ( gripPose.linearVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\tgrip.linearVelocity.copy( gripPose.linearVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( gripPose.angularVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\tgrip.angularVelocity.copy( gripPose.angularVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass WebXRManager extends EventDispatcher {\n\n\tconstructor( renderer, gl ) {\n\n\t\tsuper();\n\n\t\tconst scope = this;\n\t\tconst state = renderer.state;\n\n\t\tlet session = null;\n\t\tlet framebufferScaleFactor = 1.0;\n\n\t\tlet referenceSpace = null;\n\t\tlet referenceSpaceType = 'local-floor';\n\n\t\tlet pose = null;\n\t\tlet glBinding = null;\n\t\tlet glFramebuffer = null;\n\t\tlet glProjLayer = null;\n\n\t\tconst controllers = [];\n\t\tconst inputSourcesMap = new Map();\n\n\t\t//\n\n\t\tconst cameraL = new PerspectiveCamera();\n\t\tcameraL.layers.enable( 1 );\n\t\tcameraL.viewport = new Vector4();\n\n\t\tconst cameraR = new PerspectiveCamera();\n\t\tcameraR.layers.enable( 2 );\n\t\tcameraR.viewport = new Vector4();\n\n\t\tconst cameras = [ cameraL, cameraR ];\n\n\t\tconst cameraVR = new ArrayCamera();\n\t\tcameraVR.layers.enable( 1 );\n\t\tcameraVR.layers.enable( 2 );\n\n\t\tlet _currentDepthNear = null;\n\t\tlet _currentDepthFar = null;\n\n\t\t//\n\n\t\tthis.cameraAutoUpdate = true;\n\t\tthis.enabled = false;\n\n\t\tthis.isPresenting = false;\n\n\t\tthis.getController = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getTargetRaySpace();\n\n\t\t};\n\n\t\tthis.getControllerGrip = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getGripSpace();\n\n\t\t};\n\n\t\tthis.getHand = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getHandSpace();\n\n\t\t};\n\n\t\t//\n\n\t\tfunction onSessionEvent( event ) {\n\n\t\t\tconst controller = inputSourcesMap.get( event.inputSource );\n\n\t\t\tif ( controller ) {\n\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onSessionEnd() {\n\n\t\t\tinputSourcesMap.forEach( function ( controller, inputSource ) {\n\n\t\t\t\tcontroller.disconnect( inputSource );\n\n\t\t\t} );\n\n\t\t\tinputSourcesMap.clear();\n\n\t\t\t_currentDepthNear = null;\n\t\t\t_currentDepthFar = null;\n\n\t\t\t// restore framebuffer/rendering state\n\n\t\t\tstate.bindXRFramebuffer( null );\n\t\t\trenderer.setRenderTarget( renderer.getRenderTarget() );\n\n\t\t\t//\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.isPresenting = false;\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\t\tframebufferScaleFactor = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\t\treferenceSpaceType = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getReferenceSpace = function () {\n\n\t\t\treturn referenceSpace;\n\n\t\t};\n\n\t\tthis.getSession = function () {\n\n\t\t\treturn session;\n\n\t\t};\n\n\t\tthis.setSession = async function ( value ) {\n\n\t\t\tsession = value;\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\t\tconst attributes = gl.getContextAttributes();\n\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t\t}\n\n\t\t\t\tif ( session.renderState.layers === undefined ) {\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: attributes.alpha,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\tconst baseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\t\t\tsession.updateRenderState( { baseLayer: baseLayer } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet depthFormat = 0;\n\n\t\t\t\t\tif ( attributes.depth ) {\n\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? 34041 : 6402;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\t\tcolorFormat: attributes.alpha ? 6408 : 6407,\n\t\t\t\t\t\tdepthFormat: depthFormat,\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\n\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\t\tglFramebuffer = gl.createFramebuffer();\n\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\t}\n\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t\tscope.isPresenting = true;\n\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction onInputSourcesChange( event ) {\n\n\t\t\tconst inputSources = session.inputSources;\n\n\t\t\t// Assign inputSources to available controllers\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tinputSourcesMap.set( inputSources[ i ], controllers[ i ] );\n\n\t\t\t}\n\n\t\t\t// Notify disconnected\n\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.removed[ i ];\n\t\t\t\tconst controller = inputSourcesMap.get( inputSource );\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\t\t\t\t\tinputSourcesMap.delete( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Notify connected\n\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.added[ i ];\n\t\t\t\tconst controller = inputSourcesMap.get( inputSource );\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst cameraLPos = new Vector3();\n\t\tconst cameraRPos = new Vector3();\n\n\t\t/**\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t * the cameras' projection and world matrices have already been set.\n\t\t * And that near and far planes are identical for both cameras.\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t */\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t\t// VR systems will have identical far and near planes, and\n\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t// Use the left camera for these values.\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\t\tconst left = near * leftFov;\n\t\t\tconst right = near * rightFov;\n\n\t\t\t// Calculate the new camera's position offset from the\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t\t// TODO: Better way to apply this offset?\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.translateX( xOffset );\n\t\t\tcamera.translateZ( zOffset );\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t\t// Find the union of the frustum values of the cameras and scale\n\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t// although must now be relative to the new union camera.\n\t\t\tconst near2 = near + zOffset;\n\t\t\tconst far2 = far + zOffset;\n\t\t\tconst left2 = left - xOffset;\n\t\t\tconst right2 = right + ( ipd - xOffset );\n\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\n\t\t}\n\n\t\tfunction updateCamera( camera, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t\t}\n\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t}\n\n\t\tthis.updateCamera = function ( camera ) {\n\n\t\t\tif ( session === null ) return;\n\n\t\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\tif ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {\n\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\tdepthNear: cameraVR.near,\n\t\t\t\t\tdepthFar: cameraVR.far\n\t\t\t\t} );\n\n\t\t\t\t_currentDepthNear = cameraVR.near;\n\t\t\t\t_currentDepthFar = cameraVR.far;\n\n\t\t\t}\n\n\t\t\tconst parent = camera.parent;\n\t\t\tconst cameras = cameraVR.cameras;\n\n\t\t\tupdateCamera( cameraVR, parent );\n\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\tcameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );\n\n\t\t\t// update user camera and its children\n\n\t\t\tcamera.position.copy( cameraVR.position );\n\t\t\tcamera.quaternion.copy( cameraVR.quaternion );\n\t\t\tcamera.scale.copy( cameraVR.scale );\n\t\t\tcamera.matrix.copy( cameraVR.matrix );\n\t\t\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\n\n\t\t\tconst children = camera.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\t// update projection matrix for proper view frustum culling\n\n\t\t\tif ( cameras.length === 2 ) {\n\n\t\t\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t\t} else {\n\n\t\t\t\t// assume single camera setup (AR)\n\n\t\t\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getCamera = function () {\n\n\t\t\treturn cameraVR;\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time, frame ) {\n\n\t\t\tpose = frame.getViewerPose( referenceSpace );\n\n\t\t\tif ( pose !== null ) {\n\n\t\t\t\tconst views = pose.views;\n\n\t\t\t\tconst baseLayer = session.renderState.baseLayer;\n\n\t\t\t\tif ( session.renderState.layers === undefined ) {\n\n\t\t\t\t\tstate.bindXRFramebuffer( baseLayer.framebuffer );\n\n\t\t\t\t}\n\n\t\t\t\tlet cameraVRNeedsUpdate = false;\n\n\t\t\t\t// check if it's necessary to rebuild cameraVR's camera list\n\n\t\t\t\tif ( views.length !== cameraVR.cameras.length ) {\n\n\t\t\t\t\tcameraVR.cameras.length = 0;\n\n\t\t\t\t\tcameraVRNeedsUpdate = true;\n\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\t\tconst view = views[ i ];\n\n\t\t\t\t\tlet viewport = null;\n\n\t\t\t\t\tif ( session.renderState.layers === undefined ) {\n\n\t\t\t\t\t\tviewport = baseLayer.getViewport( view );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\n\n\t\t\t\t\t\tstate.bindXRFramebuffer( glFramebuffer );\n\n\t\t\t\t\t\tgl.framebufferTexture2D( 36160, 36064, 3553, glSubImage.colorTexture, 0 );\n\n\t\t\t\t\t\tif ( glSubImage.depthStencilTexture !== undefined ) {\n\n\t\t\t\t\t\t\tgl.framebufferTexture2D( 36160, 36096, 3553, glSubImage.depthStencilTexture, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst camera = cameras[ i ];\n\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cameraVRNeedsUpdate === true ) {\n\n\t\t\t\t\t\tcameraVR.cameras.push( camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst inputSources = session.inputSources;\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst controller = controllers[ i ];\n\t\t\t\tconst inputSource = inputSources[ i ];\n\n\t\t\t\tcontroller.update( inputSource, frame, referenceSpace );\n\n\t\t\t}\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\n\t\t};\n\n\t\tthis.dispose = function () {};\n\n\t}\n\n}\n\nfunction WebGLMaterials( properties ) {\n\n\tfunction refreshFogUniforms( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value.copy( fog.color );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {\n\n\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsLambert( uniforms, material );\n\n\t\t} else if ( material.isMeshToonMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsToon( uniforms, material );\n\n\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( uniforms, material, transmissionRenderTarget );\n\n\t\t\t} else {\n\n\t\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsMatcap( uniforms, material );\n\n\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDepth( uniforms, material );\n\n\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDistance( uniforms, material );\n\n\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsNormal( uniforms, material );\n\n\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\trefreshUniformsLine( uniforms, material );\n\n\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsDash( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\n\n\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\trefreshUniformsSprites( uniforms, material );\n\n\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\tuniforms.color.value.copy( material.color );\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t} else if ( material.isShaderMaterial ) {\n\n\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t}\n\n\t\tconst envMap = properties.get( material ).envMap;\n\n\t\tif ( envMap ) {\n\n\t\t\tuniforms.envMap.value = envMap;\n\n\t\t\tuniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\tconst maxMipLevel = properties.get( envMap ).__maxMipLevel;\n\n\t\t\tif ( maxMipLevel !== undefined ) {\n\n\t\t\t\tuniforms.maxMipLevel.value = maxMipLevel;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. displacementMap map\n\t\t// 4. normal map\n\t\t// 5. bump map\n\t\t// 6. roughnessMap map\n\t\t// 7. metalnessMap map\n\t\t// 8. alphaMap map\n\t\t// 9. emissiveMap map\n\t\t// 10. clearcoat map\n\t\t// 11. clearcoat normal map\n\t\t// 12. clearcoat roughnessMap map\n\n\t\tlet uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t} else if ( material.clearcoatMap ) {\n\n\t\t\tuvScaleMap = material.clearcoatMap;\n\n\t\t} else if ( material.clearcoatNormalMap ) {\n\n\t\t\tuvScaleMap = material.clearcoatNormalMap;\n\n\t\t} else if ( material.clearcoatRoughnessMap ) {\n\n\t\t\tuvScaleMap = material.clearcoatRoughnessMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities for uv2\n\t\t// 1. ao map\n\t\t// 2. light map\n\n\t\tlet uv2ScaleMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuv2ScaleMap = material.aoMap;\n\n\t\t} else if ( material.lightMap ) {\n\n\t\t\tuv2ScaleMap = material.lightMap;\n\n\t\t}\n\n\t\tif ( uv2ScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uv2ScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\tuv2ScaleMap = uv2ScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tif ( uv2ScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuv2ScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * pixelRatio;\n\t\tuniforms.scale.value = height * 0.5;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. alpha map\n\n\t\tlet uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. alpha map\n\n\t\tlet uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tconst envMap = properties.get( material ).envMap;\n\n\t\tif ( envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n\t\tif ( material.sheen ) uniforms.sheen.value.copy( material.sheen );\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\n\t\t}\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\n\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\n\t\t\t}\n\n\t\t}\n\n\t\tuniforms.transmission.value = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\n\t\t}\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\tuniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );\n\n\t\t}\n\n\t\tuniforms.thickness.value = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\n\t\t}\n\n\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\tuniforms.attenuationColor.value.copy( material.attenuationColor );\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDepth( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tuniforms.referencePosition.value.copy( material.referencePosition );\n\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\tuniforms.farDistance.value = material.farDistance;\n\n\t}\n\n\tfunction refreshUniformsNormal( uniforms, material ) {\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\trefreshFogUniforms: refreshFogUniforms,\n\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t};\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nfunction WebGLRenderer( parameters = {} ) {\n\n\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\tlet currentRenderList = null;\n\tlet currentRenderState = null;\n\n\t// render() can be called from within a callback triggered by another render.\n\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\tconst renderListStack = [];\n\tconst renderStateStack = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\n\t// Debug configuration container\n\tthis.debug = {\n\n\t\t/**\n\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t * @type {boolean}\n\t\t */\n\t\tcheckShaderErrors: true\n\t};\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.outputEncoding = LinearEncoding;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = NoToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\n\t// internal properties\n\n\tconst _this = this;\n\n\tlet _isContextLost = false;\n\n\t// internal state cache\n\n\tlet _currentActiveCubeFace = 0;\n\tlet _currentActiveMipmapLevel = 0;\n\tlet _currentRenderTarget = null;\n\tlet _currentMaterialId = - 1;\n\n\tlet _currentCamera = null;\n\n\tconst _currentViewport = new Vector4();\n\tconst _currentScissor = new Vector4();\n\tlet _currentScissorTest = null;\n\n\t//\n\n\tlet _width = _canvas.width;\n\tlet _height = _canvas.height;\n\n\tlet _pixelRatio = 1;\n\tlet _opaqueSort = null;\n\tlet _transparentSort = null;\n\n\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\tlet _scissorTest = false;\n\n\t//\n\n\tconst _currentDrawBuffers = [];\n\n\t// frustum\n\n\tconst _frustum = new Frustum();\n\n\t// clipping\n\n\tlet _clippingEnabled = false;\n\tlet _localClippingEnabled = false;\n\n\t// transmission\n\n\tlet _transmissionRenderTarget = null;\n\n\t// camera matrices cache\n\n\tconst _projScreenMatrix = new Matrix4();\n\n\tconst _vector3 = new Vector3();\n\n\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\t// initialize\n\n\tlet _gl = _context;\n\n\tfunction getContext( contextNames, contextAttributes ) {\n\n\t\tfor ( let i = 0; i < contextNames.length; i ++ ) {\n\n\t\t\tconst contextName = contextNames[ i ];\n\t\t\tconst context = _canvas.getContext( contextName, contextAttributes );\n\t\t\tif ( context !== null ) return context;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\ttry {\n\n\t\tconst contextAttributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\tpowerPreference: _powerPreference,\n\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n\t\t};\n\n\t\t// event listeners must be registered before WebGL context is created, see #12753\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tconst contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];\n\n\t\t\tif ( _this.isWebGL1Renderer === true ) {\n\n\t\t\t\tcontextNames.shift();\n\n\t\t\t}\n\n\t\t\t_gl = getContext( contextNames, contextAttributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( getContext( contextNames ) ) {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\tthrow error;\n\n\t}\n\n\tlet extensions, capabilities, state, info;\n\tlet properties, textures, cubemaps, attributes, geometries, objects;\n\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\tlet utils, bindingStates;\n\n\tfunction initGLContext() {\n\n\t\textensions = new WebGLExtensions( _gl );\n\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\textensions.init( capabilities );\n\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\n\n\t\tstate = new WebGLState( _gl, extensions, capabilities );\n\n\t\t_currentDrawBuffers[ 0 ] = 1029;\n\n\t\tinfo = new WebGLInfo( _gl );\n\t\tproperties = new WebGLProperties();\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\tattributes = new WebGLAttributes( _gl, capabilities );\n\t\tbindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\tmorphtargets = new WebGLMorphtargets( _gl );\n\t\tclipping = new WebGLClipping( properties );\n\t\tprogramCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );\n\t\tmaterials = new WebGLMaterials( properties );\n\t\trenderLists = new WebGLRenderLists( properties );\n\t\trenderStates = new WebGLRenderStates( extensions, capabilities );\n\t\tbackground = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );\n\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\n\n\t\tinfo.programs = programCache.programs;\n\n\t\t_this.capabilities = capabilities;\n\t\t_this.extensions = extensions;\n\t\t_this.properties = properties;\n\t\t_this.renderLists = renderLists;\n\t\t_this.shadowMap = shadowMap;\n\t\t_this.state = state;\n\t\t_this.info = info;\n\n\t}\n\n\tinitGLContext();\n\n\t// xr\n\n\tconst xr = new WebXRManager( _this, _gl );\n\n\tthis.xr = xr;\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t};\n\n\tthis.forceContextRestore = function () {\n\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.restoreContext();\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _width, _height, false );\n\n\t};\n\n\tthis.getSize = function ( target ) {\n\n\t\treturn target.set( _width, _height );\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\tif ( xr.isPresenting ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = Math.floor( width * _pixelRatio );\n\t\t_canvas.height = Math.floor( height * _pixelRatio );\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t};\n\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_pixelRatio = pixelRatio;\n\n\t\t_canvas.width = Math.floor( width * pixelRatio );\n\t\t_canvas.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getCurrentViewport = function ( target ) {\n\n\t\treturn target.copy( _currentViewport );\n\n\t};\n\n\tthis.getViewport = function ( target ) {\n\n\t\treturn target.copy( _viewport );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_viewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissor = function ( target ) {\n\n\t\treturn target.copy( _scissor );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_scissor.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn _scissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\tthis.setOpaqueSort = function ( method ) {\n\n\t\t_opaqueSort = method;\n\n\t};\n\n\tthis.setTransparentSort = function ( method ) {\n\n\t\t_transparentSort = method;\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function ( target ) {\n\n\t\treturn target.copy( background.getClearColor() );\n\n\t};\n\n\tthis.setClearColor = function () {\n\n\t\tbackground.setClearColor.apply( background, arguments );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn background.getClearAlpha();\n\n\t};\n\n\tthis.setClearAlpha = function () {\n\n\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tlet bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= 16384;\n\t\tif ( depth === undefined || depth ) bits |= 256;\n\t\tif ( stencil === undefined || stencil ) bits |= 1024;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\t//\n\n\tthis.dispose = function () {\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\trenderLists.dispose();\n\t\trenderStates.dispose();\n\t\tproperties.dispose();\n\t\tcubemaps.dispose();\n\t\tobjects.dispose();\n\t\tbindingStates.dispose();\n\n\t\txr.dispose();\n\n\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\tif ( _transmissionRenderTarget ) {\n\n\t\t\t_transmissionRenderTarget.dispose();\n\t\t\t_transmissionRenderTarget = null;\n\n\t\t}\n\n\t\tanimation.stop();\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t_isContextLost = true;\n\n\t}\n\n\tfunction onContextRestore( /* event */ ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t_isContextLost = false;\n\n\t\tconst infoAutoReset = info.autoReset;\n\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\tconst shadowMapType = shadowMap.type;\n\n\t\tinitGLContext();\n\n\t\tinfo.autoReset = infoAutoReset;\n\t\tshadowMap.enabled = shadowMapEnabled;\n\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\tshadowMap.type = shadowMapType;\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReferences( material );\n\n\t\tproperties.remove( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\tconst programs = properties.get( material ).programs;\n\n\t\tif ( programs !== undefined ) {\n\n\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tfunction renderObjectImmediate( object, program ) {\n\n\t\tobject.render( function ( object ) {\n\n\t\t\t_this.renderBufferImmediate( object, program );\n\n\t\t} );\n\n\t}\n\n\tthis.renderBufferImmediate = function ( object, program ) {\n\n\t\tbindingStates.initAttributes();\n\n\t\tconst buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.position );\n\t\t\t_gl.bufferData( 34962, object.positionArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.position );\n\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.normal );\n\t\t\t_gl.bufferData( 34962, object.normalArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.normal );\n\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.uv );\n\t\t\t_gl.bufferData( 34962, object.uvArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.uv );\n\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.color );\n\t\t\t_gl.bufferData( 34962, object.colorArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.color );\n\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tbindingStates.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( 4, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tconst program = setProgram( camera, scene, material, object );\n\n\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t//\n\n\t\tlet index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\n\t\t//\n\n\t\tif ( index === null ) {\n\n\t\t\tif ( position === undefined || position.count === 0 ) return;\n\n\t\t} else if ( index.count === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tif ( material.morphTargets || material.morphNormals ) {\n\n\t\t\tmorphtargets.update( object, geometry, material, program );\n\n\t\t}\n\n\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\tlet attribute;\n\t\tlet renderer = bufferRenderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattribute = attributes.get( index );\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( attribute );\n\n\t\t}\n\n\t\t//\n\n\t\tconst dataCount = ( index !== null ) ? index.count : position.count;\n\n\t\tconst rangeStart = geometry.drawRange.start * rangeFactor;\n\t\tconst rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\tconst groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\tconst groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\tconst drawStart = Math.max( rangeStart, groupStart );\n\t\tconst drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tconst drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\t//\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( 4 );\n\n\t\t\t}\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\trenderer.setMode( 2 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( 3 );\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\trenderer.setMode( 0 );\n\n\t\t} else if ( object.isSprite ) {\n\n\t\t\trenderer.setMode( 4 );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\tconst instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );\n\n\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\t// Compile\n\n\tthis.compile = function ( scene, camera ) {\n\n\t\tcurrentRenderState = renderStates.get( scene );\n\t\tcurrentRenderState.init();\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcurrentRenderState.setupLights();\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tconst material = object.material;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\tgetProgram( material2, scene, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t};\n\n\t// Animation Loop\n\n\tlet onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time ) {\n\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tfunction onXRSessionStart() {\n\n\t\tanimation.stop();\n\n\t}\n\n\tfunction onXRSessionEnd() {\n\n\t\tanimation.start();\n\n\t}\n\n\tconst animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tif ( typeof window !== 'undefined' ) animation.setContext( window );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\t\txr.setAnimationLoop( callback );\n\n\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t};\n\n\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( _isContextLost === true ) return;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t}\n\n\t\t//\n\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\tcurrentRenderState.init();\n\n\t\trenderStateStack.push( currentRenderState );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\tcurrentRenderList.init();\n\n\t\trenderListStack.push( currentRenderList );\n\n\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\tcurrentRenderList.finish();\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\tcurrentRenderState.setupLights();\n\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t//\n\n\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t//\n\n\t\tbackground.render( currentRenderList, scene );\n\n\t\t// render scene\n\n\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\tif ( transmissiveObjects.length > 0 ) renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera );\n\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t//\n\n\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.buffers.depth.setTest( true );\n\t\tstate.buffers.depth.setMask( true );\n\t\tstate.buffers.color.setMask( true );\n\n\t\tstate.setPolygonOffset( false );\n\n\t\t// _gl.finish();\n\n\t\tbindingStates.resetDefaultState();\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\trenderStateStack.pop();\n\n\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t} else {\n\n\t\t\tcurrentRenderState = null;\n\n\t\t}\n\n\t\trenderListStack.pop();\n\n\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t} else {\n\n\t\t\tcurrentRenderList = null;\n\n\t\t}\n\n\t};\n\n\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t// update skeleton only once in a frame\n\n\t\t\t\t\tif ( object.skeleton.frame !== info.render.frame ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t}\n\n\t}\n\n\tfunction renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera ) {\n\n\t\tif ( _transmissionRenderTarget === null ) {\n\n\t\t\tconst needsAntialias = _antialias === true && capabilities.isWebGL2 === true;\n\t\t\tconst renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;\n\n\t\t\t_transmissionRenderTarget = new renderTargetType( 1024, 1024, {\n\t\t\t\tgenerateMipmaps: true,\n\t\t\t\ttype: utils.convert( HalfFloatType ) !== null ? HalfFloatType : UnsignedByteType,\n\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\twrapS: ClampToEdgeWrapping,\n\t\t\t\twrapT: ClampToEdgeWrapping\n\t\t\t} );\n\n\t\t}\n\n\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t_this.setRenderTarget( _transmissionRenderTarget );\n\t\t_this.clear();\n\n\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\tconst currentToneMapping = _this.toneMapping;\n\t\t_this.toneMapping = NoToneMapping;\n\n\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t_this.toneMapping = currentToneMapping;\n\n\t\ttextures.updateMultisampleRenderTarget( _transmissionRenderTarget );\n\t\ttextures.updateRenderTargetMipmap( _transmissionRenderTarget );\n\n\t\t_this.setRenderTarget( currentRenderTarget );\n\n\t\trenderObjects( transmissiveObjects, scene, camera );\n\n\t}\n\n\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\tconst object = renderItem.object;\n\t\t\tconst geometry = renderItem.geometry;\n\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\tconst group = renderItem.group;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tstate.viewport( _currentViewport.copy( camera2.viewport ) );\n\n\t\t\t\t\t\tcurrentRenderState.setupLightsView( camera2 );\n\n\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\tconst program = setProgram( camera, scene, material, object );\n\n\t\t\tstate.setMaterial( material );\n\n\t\t\tbindingStates.reset();\n\n\t\t\trenderObjectImmediate( object, program );\n\n\t\t} else {\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t}\n\n\tfunction getProgram( material, scene, object ) {\n\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tconst lights = currentRenderState.state.lights;\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tconst lightsStateVersion = lights.state.version;\n\n\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\tlet programs = materialProperties.programs;\n\n\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\tmaterialProperties.fog = scene.fog;\n\t\tmaterialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );\n\n\t\tif ( programs === undefined ) {\n\n\t\t\t// new material\n\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tprograms = new Map();\n\t\t\tmaterialProperties.programs = programs;\n\n\t\t}\n\n\t\tlet program = programs.get( programCacheKey );\n\n\t\tif ( program !== undefined ) {\n\n\t\t\t// early out if program and light state is identical\n\n\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\treturn program;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\tmaterial.onBuild( parameters, _this );\n\n\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t}\n\n\t\tconst uniforms = materialProperties.uniforms;\n\n\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t}\n\n\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t// store the light setup it was created for\n\n\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t}\n\n\t\tconst progUniforms = program.getUniforms();\n\t\tconst uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.currentProgram = program;\n\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\treturn program;\n\n\t}\n\n\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\n\t\tmaterialProperties.instancing = parameters.instancing;\n\t\tmaterialProperties.skinning = parameters.skinning;\n\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\n\t}\n\n\tfunction setProgram( camera, scene, material, object ) {\n\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\ttextures.resetTextureUnits();\n\n\t\tconst fog = scene.fog;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\tconst encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n\t\tconst envMap = cubemaps.get( material.envMap || environment );\n\t\tconst vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n\n\t\tconst materialProperties = properties.get( material );\n\t\tconst lights = currentRenderState.state.lights;\n\n\t\tif ( _clippingEnabled === true ) {\n\n\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\tconst useCache =\n\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet needsProgramChange = false;\n\n\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.outputEncoding !== encoding ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tneedsProgramChange = true;\n\t\t\tmaterialProperties.__version = material.version;\n\n\t\t}\n\n\t\t//\n\n\t\tlet program = materialProperties.currentProgram;\n\n\t\tif ( needsProgramChange === true ) {\n\n\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t}\n\n\t\tlet refreshProgram = false;\n\t\tlet refreshMaterial = false;\n\t\tlet refreshLights = false;\n\n\t\tconst p_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\tmaterial.isShadowMaterial ||\n\t\t\t\tobject.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// otherwise textures used for skinning can take over texture units reserved for other material textures\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\n\t\t}\n\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t}\n\n\t\t// common matrices\n\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\treturn program;\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\tfunction materialNeedsLights( material ) {\n\n\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t}\n\n\tthis.getActiveCubeFace = function () {\n\n\t\treturn _currentActiveCubeFace;\n\n\t};\n\n\tthis.getActiveMipmapLevel = function () {\n\n\t\treturn _currentActiveMipmapLevel;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tlet framebuffer = null;\n\t\tlet isCube = false;\n\t\tlet isRenderTarget3D = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tconst texture = renderTarget.texture;\n\n\t\t\tif ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {\n\n\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t}\n\n\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\t\t\t\tisCube = true;\n\n\t\t\t} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t} else {\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t}\n\n\t\tconst framebufferBound = state.bindFramebuffer( 36160, framebuffer );\n\n\t\tif ( framebufferBound && capabilities.drawBuffers ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tif ( renderTarget.isWebGLMultipleRenderTargets ) {\n\n\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\tif ( _currentDrawBuffers.length !== textures.length || _currentDrawBuffers[ 0 ] !== 36064 ) {\n\n\t\t\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t_currentDrawBuffers[ i ] = 36064 + i;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_currentDrawBuffers.length = textures.length;\n\n\t\t\t\t\t\tneedsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 36064 ) {\n\n\t\t\t\t\t\t_currentDrawBuffers[ 0 ] = 36064;\n\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\n\t\t\t\t\t\tneedsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 1029 ) {\n\n\t\t\t\t\t_currentDrawBuffers[ 0 ] = 1029;\n\t\t\t\t\t_currentDrawBuffers.length = 1;\n\n\t\t\t\t\tneedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t\t_gl.drawBuffers( _currentDrawBuffers );\n\n\t\t\t\t} else {\n\n\t\t\t\t\textensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( _currentDrawBuffers );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport );\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tif ( isCube ) {\n\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\tconst layer = activeCubeFace || 0;\n\t\t\t_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t}\n\n\t\tif ( framebuffer ) {\n\n\t\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\t\ttry {\n\n\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );\n\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t! halfFloatSupportedByExt ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.copyFramebufferToTexture = function ( position, texture, level = 0 ) {\n\n\t\tconst levelScale = Math.pow( 2, - level );\n\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\tlet glFormat = utils.convert( texture.format );\n\n\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100\n\t\t\t// Not needed in Chrome 93+\n\n\t\t\tif ( glFormat === 6407 ) glFormat = 32849;\n\t\t\tif ( glFormat === 6408 ) glFormat = 32856;\n\n\t\t}\n\n\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {\n\n\t\tconst width = srcTexture.image.width;\n\t\tconst height = srcTexture.image.height;\n\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\tconst glType = utils.convert( dstTexture.type );\n\n\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\t_gl.pixelStorei( 37440, dstTexture.flipY );\n\t\t_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, dstTexture.unpackAlignment );\n\n\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {\n\n\t\tif ( _this.isWebGL1Renderer ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst width = sourceBox.max.x - sourceBox.min.x + 1;\n\t\tconst height = sourceBox.max.y - sourceBox.min.y + 1;\n\t\tconst depth = sourceBox.max.z - sourceBox.min.z + 1;\n\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\tconst glType = utils.convert( dstTexture.type );\n\t\tlet glTarget;\n\n\t\tif ( dstTexture.isDataTexture3D ) {\n\n\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\tglTarget = 32879;\n\n\t\t} else if ( dstTexture.isDataTexture2DArray ) {\n\n\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\tglTarget = 35866;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_gl.pixelStorei( 37440, dstTexture.flipY );\n\t\t_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, dstTexture.unpackAlignment );\n\n\t\tconst unpackRowLen = _gl.getParameter( 3314 );\n\t\tconst unpackImageHeight = _gl.getParameter( 32878 );\n\t\tconst unpackSkipPixels = _gl.getParameter( 3316 );\n\t\tconst unpackSkipRows = _gl.getParameter( 3315 );\n\t\tconst unpackSkipImages = _gl.getParameter( 32877 );\n\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;\n\n\t\t_gl.pixelStorei( 3314, image.width );\n\t\t_gl.pixelStorei( 32878, image.height );\n\t\t_gl.pixelStorei( 3316, sourceBox.min.x );\n\t\t_gl.pixelStorei( 3315, sourceBox.min.y );\n\t\t_gl.pixelStorei( 32877, sourceBox.min.z );\n\n\t\tif ( srcTexture.isDataTexture || srcTexture.isDataTexture3D ) {\n\n\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );\n\t\t\t\t_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.pixelStorei( 3314, unpackRowLen );\n\t\t_gl.pixelStorei( 32878, unpackImageHeight );\n\t\t_gl.pixelStorei( 3316, unpackSkipPixels );\n\t\t_gl.pixelStorei( 3315, unpackSkipRows );\n\t\t_gl.pixelStorei( 32877, unpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.initTexture = function ( texture ) {\n\n\t\ttextures.setTexture2D( texture, 0 );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.resetState = function () {\n\n\t\t_currentActiveCubeFace = 0;\n\t\t_currentActiveMipmapLevel = 0;\n\t\t_currentRenderTarget = null;\n\n\t\tstate.reset();\n\t\tbindingStates.reset();\n\n\t};\n\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\n\n\t}\n\n}\n\nclass WebGL1Renderer extends WebGLRenderer {}\n\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nFogExp2.prototype.isFogExp2 = true;\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nFog.prototype.isFog = true;\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nScene.prototype.isScene = true;\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nInterleavedBuffer.prototype.isInterleavedBuffer = true;\n\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.x = this.getX( i );\n\t\t\t_vector$6.y = this.getY( i );\n\t\t\t_vector$6.z = this.getZ( i );\n\n\t\t\t_vector$6.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.x = this.getX( i );\n\t\t\t_vector$6.y = this.getY( i );\n\t\t\t_vector$6.z = this.getZ( i );\n\n\t\t\t_vector$6.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.x = this.getX( i );\n\t\t\t_vector$6.y = this.getY( i );\n\t\t\t_vector$6.z = this.getZ( i );\n\n\t\t\t_vector$6.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t}\n\n\tgetY( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t}\n\n\tgetZ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t}\n\n\tgetW( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// deinterleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interlaved attribtue\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *  rotation: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nSpriteMaterial.prototype.isSpriteMaterial = true;\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nSprite.prototype.isSprite = true;\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass SkinnedMesh extends Mesh {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = 'attached';\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\treturn this;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.x = skinWeight.getX( i );\n\t\t\tvector.y = skinWeight.getY( i );\n\t\t\tvector.z = skinWeight.getZ( i );\n\t\t\tvector.w = skinWeight.getW( i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tboneTransform( index, target ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );\n\n\t\ttarget.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\ttarget.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nSkinnedMesh.prototype.isSkinnedMesh = true;\n\nclass Bone extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nBone.prototype.isBone = true;\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nDataTexture.prototype.isDataTexture = true;\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\t\tthis.boneTextureSize = 0;\n\n\t\tthis.frame = - 1;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = ceilPowerOfTwo( size );\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\t\tthis.boneTextureSize = size;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = /*@__PURE__*/ new Mesh();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\n\t\tthis.count = count;\n\n\t\tthis.frustumCulled = false;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nInstancedMesh.prototype.isInstancedMesh = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\nconst _start$1 = /*@__PURE__*/ new Vector3();\nconst _end$1 = /*@__PURE__*/ new Vector3();\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t_start$1.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t_end$1.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i ] += _start$1.distanceTo( _end$1 );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst vStart = new Vector3();\n\t\tconst vEnd = new Vector3();\n\t\tconst interSegment = new Vector3();\n\t\tconst interRay = new Vector3();\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, a );\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, b );\n\n\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nLine.prototype.isLine = true;\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\tconst lineDistances = [];\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineSegments.prototype.isLineSegments = true;\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nLineLoop.prototype.isLineLoop = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n *  morphTargets: <bool>\n * }\n */\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t}\n\n}\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nPoints.prototype.isPoints = true;\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.format = format !== undefined ? format : RGBFormat;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nVideoTexture.prototype.isVideoTexture = true;\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nCompressedTexture.prototype.isCompressedTexture = true;\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nCanvasTexture.prototype.isCanvasTexture = true;\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\n}\n\nDepthTexture.prototype.isDepthTexture = true;\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices, indices, radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, 1/, )\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = new Vector3();\nconst _v1$1 = new Vector3();\nconst _normal = new Vector3();\nconst _triangle = new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry, thresholdAngle ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\tconsole.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst precisionPoints = 4;\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\tconst indexAttr = geometry.getIndex();\n\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\tconst indexArr = [ 0, 0, 0 ];\n\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\tconst hashes = new Array( 3 );\n\n\t\tconst edgeData = {};\n\t\tconst vertices = [];\n\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t} else {\n\n\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = _triangle;\n\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t// create hashes for the edge from the vertices\n\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t// skip degenerate triangles\n\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// iterate over every edge\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\tfor ( const key in edgeData ) {\n\n\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\t\t\ttangents[ i ].normalize();\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst point = optionalTarget || new Vector2();\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\nArcCurve.prototype.isArcCurve = true;\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = new Vector3();\nconst px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n/**\n * Bezier Curves formulas obtained from\n * http://en.wikipedia.org/wiki/Bzier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst tangent = optionalTarget || new Vector2();\n\n\t\ttangent.copy( this.v2 ).sub( this.v1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineCurve.prototype.isLineCurve = true;\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineCurve3';\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nSplineCurve.prototype.isSplineCurve = true;\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.2)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim );\n\t\t\ttriangles.push( ear.i / dim );\n\t\t\ttriangles.push( next.i / dim );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tlet p = ear.next.next;\n\n\twhile ( p !== ear.prev ) {\n\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( minTX, minTY, minX, minY, invSize ),\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n !== ear.prev && n !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\n\t\t\tarea( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n !== ear.prev && n !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\n\t\t\tarea( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim );\n\t\t\ttriangles.push( p.i / dim );\n\t\t\ttriangles.push( b.i / dim );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\teliminateHole( queue[ i ], outerNode );\n\t\touterNode = filterPoints( outerNode, outerNode.next );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\touterNode = findHoleBridge( hole, outerNode );\n\tif ( outerNode ) {\n\n\t\tconst b = splitPolygon( outerNode, hole );\n\n\t\t// filter collinear points around the cuts\n\t\tfilterPoints( outerNode, outerNode.next );\n\t\tfilterPoints( b, b.next );\n\n\t}\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode;\n\tconst hx = hole.x;\n\tconst hy = hole.y;\n\tlet qx = - Infinity, m;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tif ( x === hx ) {\n\n\t\t\t\t\tif ( hy === p.y ) return p;\n\t\t\t\t\tif ( hy === p.next.y ) return p.next;\n\n\t\t\t\t}\n\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\tif ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = 32767 * ( x - minX ) * invSize;\n\ty = 32767 * ( y - minY ) * invSize;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\n\t\t\t( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\n\t\t\t( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n\t\t( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n\t\t( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n\t\tequals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = null;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes, options ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tlet depth = options.depth !== undefined ? options.depth : 100;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t// deprecated options\n\n\t\t\tif ( options.amount !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\n\t\t\t\tdepth = options.amount;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif ( phiLength === Math.PI * 2 ) {\n\n\t\t\tconst normals = this.attributes.normal.array;\n\t\t\tconst n1 = new Vector3();\n\t\t\tconst n2 = new Vector3();\n\t\t\tconst n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\n\t\t\tconst base = segments * points.length * 3;\n\n\t\t\tfor ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\n/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nclass ParametricGeometry extends BufferGeometry {\n\n\tconstructor( func, slices, stacks ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tconst EPS = 0.00001;\n\n\t\tconst normal = new Vector3();\n\n\t\tconst p0 = new Vector3(), p1 = new Vector3();\n\t\tconst pu = new Vector3(), pv = new Vector3();\n\n\t\tif ( func.length < 3 ) {\n\n\t\t\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\n\n\t\t}\n\n\t\t// generate vertices, normals and uvs\n\n\t\tconst sliceCount = slices + 1;\n\n\t\tfor ( let i = 0; i <= stacks; i ++ ) {\n\n\t\t\tconst v = i / stacks;\n\n\t\t\tfor ( let j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tconst u = j / slices;\n\n\t\t\t\t// vertex\n\n\t\t\t\tfunc( u, v, p0 );\n\t\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t\t// normal\n\n\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < slices; j ++ ) {\n\n\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\tconst c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\tconst d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes, curveSegments = 12 ) {\n\n\t\tsuper();\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// incides\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy == 0 && thetaStart == 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\n/**\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n *  bevelOffset: <float> // how far from text outline does bevel start\n * }\n */\n\nclass TextGeometry extends ExtrudeGeometry {\n\n\tconstructor( text, parameters = {} ) {\n\n\t\tconst font = parameters.font;\n\n\t\tif ( ! ( font && font.isFont ) ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new BufferGeometry();\n\n\t\t}\n\n\t\tconst shapes = font.generateShapes( text, parameters.size );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.depth = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tsuper( shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry ) {\n\n\t\tsuper();\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\tconsole.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\n\t\t// helper variables\n\n\t\tconst edge = [ 0, 0 ], edges = {};\n\n\t\tconst vertex = new Vector3();\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// indexed BufferGeometry\n\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst indices = geometry.index;\n\t\t\tlet groups = geometry.groups;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t}\n\n\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tconst edge1 = indices.getX( i + j );\n\t\t\t\t\t\tconst edge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\tconst key = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( const key in edges ) {\n\n\t\t\t\tconst e = edges[ key ];\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tBoxBufferGeometry: BoxGeometry,\n\tCircleGeometry: CircleGeometry,\n\tCircleBufferGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tConeBufferGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tCylinderBufferGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tDodecahedronBufferGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tExtrudeBufferGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tIcosahedronBufferGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tLatheBufferGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tOctahedronBufferGeometry: OctahedronGeometry,\n\tParametricGeometry: ParametricGeometry,\n\tParametricBufferGeometry: ParametricGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPlaneBufferGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tPolyhedronBufferGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tRingBufferGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tShapeBufferGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tSphereBufferGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTetrahedronBufferGeometry: TetrahedronGeometry,\n\tTextGeometry: TextGeometry,\n\tTextBufferGeometry: TextGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusBufferGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTorusKnotBufferGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tTubeBufferGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\n/**\n * parameters = {\n *  color: <THREE.Color>\n * }\n */\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\treturn this;\n\n\t}\n\n}\n\nShadowMaterial.prototype.isShadowMaterial = true;\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshStandardMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.vertexTangents = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.vertexTangents = source.vertexTangents;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n/**\n * parameters = {\n *  clearcoat: <float>,\n *  clearcoatMap: new THREE.Texture( <Image> ),\n *  clearcoatRoughness: <float>,\n *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),\n *  clearcoatNormalScale: <Vector2>,\n *  clearcoatNormalMap: new THREE.Texture( <Image> ),\n *\n *  reflectivity: <float>,\n *  ior: <float>,\n *\n *  sheen: <Color>,\n *\n *  transmission: <float>,\n *  transmissionMap: new THREE.Texture( <Image> ),\n *\n *  thickness: <float>,\n *  thicknessMap: new THREE.Texture( <Image> ),\n *  attenuationDistance: <float>,\n *  attenuationColor: <Color>\n * }\n */\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.clearcoat = 0.0;\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tObject.defineProperty( this, 'ior', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );\n\n\t\t\t},\n\t\t\tset: function ( ior ) {\n\n\t\t\t\tthis.reflectivity = clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.sheen = null; // null will disable sheen bsdf\n\n\t\tthis.transmission = 0.0;\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0.01;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = 0.0;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tif ( source.sheen ) {\n\n\t\t\tthis.sheen = ( this.sheen || new Color() ).copy( source.sheen );\n\n\t\t} else {\n\n\t\t\tthis.sheen = null;\n\n\t\t}\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.MultiplyOperation,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *\n *  map: new THREE.Texture( <Image> ),\n *  gradientMap: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n/**\n * parameters = {\n *  opacity: <float>,\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  matcap: new THREE.Texture( <Image> ),\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\nvar Materials = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tShadowMaterial: ShadowMaterial,\n\tSpriteMaterial: SpriteMaterial,\n\tRawShaderMaterial: RawShaderMaterial,\n\tShaderMaterial: ShaderMaterial,\n\tPointsMaterial: PointsMaterial,\n\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\tMeshStandardMaterial: MeshStandardMaterial,\n\tMeshPhongMaterial: MeshPhongMaterial,\n\tMeshToonMaterial: MeshToonMaterial,\n\tMeshNormalMaterial: MeshNormalMaterial,\n\tMeshLambertMaterial: MeshLambertMaterial,\n\tMeshDepthMaterial: MeshDepthMaterial,\n\tMeshDistanceMaterial: MeshDistanceMaterial,\n\tMeshBasicMaterial: MeshBasicMaterial,\n\tMeshMatcapMaterial: MeshMatcapMaterial,\n\tLineDashedMaterial: LineDashedMaterial,\n\tLineBasicMaterial: LineBasicMaterial,\n\tMaterial: Material\n});\n\nconst AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function ( array, from, to ) {\n\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function ( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function ( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function ( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tconst n = times.length;\n\t\tconst result = new Array( n );\n\t\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function ( values, stride, order ) {\n\n\t\tconst nValues = values.length;\n\t\tconst result = new values.constructor( nValues );\n\n\t\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tconst srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tlet i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tlet value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t},\n\n\tsubclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\t\tconst clip = sourceClip.clone();\n\n\t\tclip.name = name;\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tconst track = clip.tracks[ i ];\n\t\t\tconst valueSize = track.getValueSize();\n\n\t\t\tconst times = [];\n\t\t\tconst values = [];\n\n\t\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( times.length === 0 ) continue;\n\n\t\t\ttrack.times = AnimationUtils.convertArray( times, track.times.constructor );\n\t\t\ttrack.values = AnimationUtils.convertArray( values, track.values.constructor );\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\t// find minimum .times value across all tracks in the trimmed clip\n\n\t\tlet minStartTime = Infinity;\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// shift all tracks such that clip begins at t=0\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t\t}\n\n\t\tclip.resetDuration();\n\n\t\treturn clip;\n\n\t},\n\n\tmakeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\t\tif ( fps <= 0 ) fps = 30;\n\n\t\tconst numTracks = referenceClip.tracks.length;\n\t\tconst referenceTime = referenceFrame / fps;\n\n\t\t// Make each track's values relative to the values at the reference frame\n\t\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t\t// Skip this track if it's non-numeric\n\t\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t\t} );\n\n\t\t\tif ( targetTrack === undefined ) continue;\n\n\t\t\tlet referenceOffset = 0;\n\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t\t}\n\n\t\t\tlet targetOffset = 0;\n\t\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t\t}\n\n\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\tlet referenceValue;\n\n\t\t\t// Find the value to subtract out of the track\n\t\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t\t} else {\n\n\t\t\t\t// Interpolate to the reference value\n\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );\n\n\t\t\t}\n\n\t\t\t// Conjugate the quaternion\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t\t}\n\n\t\t\t// Subtract the reference value from all of the track values\n\n\t\t\tconst numTimes = targetTrack.times.length;\n\t\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart,\n\t\t\t\t\t\treferenceValue,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\t\treturn targetClip;\n\n\t}\n\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n// ALIAS DEFINITIONS\n\nInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\nInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = AnimationUtils.arraySlice( this.times ),\n\t\t\tvalues = AnimationUtils.arraySlice( this.values ),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tconst values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nconst loading = {};\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Check for data: URI\n\t\tconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\tconst dataUriRegexResult = url.match( dataUriRegex );\n\t\tlet request;\n\n\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\tif ( dataUriRegexResult ) {\n\n\t\t\tconst mimeType = dataUriRegexResult[ 1 ];\n\t\t\tconst isBase64 = !! dataUriRegexResult[ 2 ];\n\n\t\t\tlet data = dataUriRegexResult[ 3 ];\n\t\t\tdata = decodeURIComponent( data );\n\n\t\t\tif ( isBase64 ) data = atob( data );\n\n\t\t\ttry {\n\n\t\t\t\tlet response;\n\t\t\t\tconst responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\tconst view = new Uint8Array( data.length );\n\n\t\t\t\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tresponse = view.buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Initialise array for duplicate requests\n\n\t\t\tloading[ url ] = [];\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\trequest = new XMLHttpRequest();\n\n\t\t\trequest.open( 'GET', url, true );\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tconst response = this.response;\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tif ( this.status === 200 || this.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'abort', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n\t\t\tfor ( const header in this.requestHeader ) {\n\n\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\n\t\t\t}\n\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tconst texData = scope.parse( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.encoding !== undefined ) {\n\n\t\t\t\ttexture.encoding = texData.encoding;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tconst isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nLight.prototype.isLight = true;\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nHemisphereLight.prototype.isHemisphereLight = true;\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nSpotLightShadow.prototype.isSpotLightShadow = true;\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nSpotLight.prototype.isSpotLight = true;\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nPointLightShadow.prototype.isPointLightShadow = true;\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 1 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nPointLight.prototype.isPointLight = true;\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nOrthographicCamera.prototype.isOrthographicCamera = true;\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n}\n\nDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nDirectionalLight.prototype.isDirectionalLight = true;\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nAmbientLight.prototype.isAmbientLight = true;\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\nRectAreaLight.prototype.isRectAreaLight = true;\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nLightProbe.prototype.isLightProbe = true;\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = new Materials[ json.type ]();\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\tif ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\n\t\tif ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Deprecated\n\n\t\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) {\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.substr( 0, index + 1 );\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON( this );\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\nclass InstancedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tif ( typeof normalized === 'number' ) {\n\n\t\t\tmeshPerAttribute = normalized;\n\n\t\t\tnormalized = false;\n\n\t\t\tconsole.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );\n\n\t\t}\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tif ( attribute.updateRange !== undefined ) {\n\n\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ] instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: The legacy Geometry type is no longer supported.' );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.type === 'MultiMaterial' ) {\n\n\t\t\t\t\t// Deprecated\n\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor ( let j = 0; j < data.materials.length; j ++ ) {\n\n\t\t\t\t\t\tconst material = data.materials[ j ];\n\n\t\t\t\t\t\tif ( cache[ material.uuid ] === undefined ) {\n\n\t\t\t\t\t\t\tcache[ material.uuid ] = loader.parse( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push( cache[ material.uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = array;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\timages[ image.uuid ] = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timages[ image.uuid ].push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timages[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\n\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\timages[ image.uuid ] = deserializedImage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\timages[ image.uuid ] = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timages[ image.uuid ].push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timages[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\n\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\timages[ image.uuid ] = deserializedImage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tlet texture;\n\t\t\t\tconst image = images[ data.image ];\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture( image );\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture( image.data, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture( image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) object.environment = getTexture( data.environment );\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new BufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/* DEPRECATED */\n\n\tsetTexturePath( value ) {\n\n\t\tconsole.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );\n\t\treturn this.setResourcePath( value );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\tCubeUVRefractionMapping: CubeUVRefractionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tfetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nImageBitmapLoader.prototype.isImageBitmapLoader = true;\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW, noHoles ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tconst toChange = [];\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass Font {\n\n\tconstructor( data ) {\n\n\t\tthis.type = 'Font';\n\n\t\tthis.data = data;\n\n\t}\n\n\tgenerateShapes( text, size = 100 ) {\n\n\t\tconst shapes = [];\n\t\tconst paths = createPaths( text, size, this.data );\n\n\t\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nfunction createPaths( text, size, data ) {\n\n\tconst chars = Array.from( text );\n\tconst scale = size / data.resolution;\n\tconst line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tconst paths = [];\n\n\tlet offsetX = 0, offsetY = 0;\n\n\tfor ( let i = 0; i < chars.length; i ++ ) {\n\n\t\tconst char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tconst ret = createPath( char, scale, offsetX, offsetY, data );\n\t\t\toffsetX += ret.offsetX;\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tconst glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) {\n\n\t\tconsole.error( 'THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.' );\n\n\t\treturn;\n\n\t}\n\n\tconst path = new ShapePath();\n\n\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tconst outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( let i = 0, l = outline.length; i < l; ) {\n\n\t\t\tconst action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\nFont.prototype.isFont = true;\n\nclass FontLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tconst font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\treturn new Font( json );\n\n\t}\n\n}\n\nlet _context;\n\nconst AudioContext = {\n\n\tgetContext: function () {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t},\n\n\tsetContext: function ( value ) {\n\n\t\t_context = value;\n\n\t}\n\n};\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n}\n\nclass HemisphereLightProbe extends LightProbe {\n\n\tconstructor( skyColor, groundColor, intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tconst color1 = new Color().set( skyColor );\n\t\tconst color2 = new Color().set( groundColor );\n\n\t\tconst sky = new Vector3( color1.r, color1.g, color1.b );\n\t\tconst ground = new Vector3( color2.r, color2.g, color2.b );\n\n\t\t// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\t\tconst c0 = Math.sqrt( Math.PI );\n\t\tconst c1 = c0 * Math.sqrt( 0.75 );\n\n\t\tthis.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );\n\t\tthis.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );\n\n\t}\n\n}\n\nHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\nclass AmbientLightProbe extends LightProbe {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tconst color1 = new Color().set( color );\n\n\t\t// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\t\tthis.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );\n\n\t}\n\n}\n\nAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tthis.source.stop();\n\t\tthis.source.onended = null;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.source.detune === undefined ) return; // only set detune when available\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nGLBufferAttribute.prototype.isGLBufferAttribute = true;\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera && camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera && camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tintersectObject( object, recursive = false, intersects = [] ) {\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = false, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t}\n\n\tif ( recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst clampedPoint = _vector$4.copy( point ).clamp( this.min, this.max );\n\t\treturn clampedPoint.sub( point ).length();\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nBox2.prototype.isBox2 = true;\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass ImmediateRenderObject extends Object3D {\n\n\tconstructor( material ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.render = function ( /* renderCallback */ ) {};\n\n\t\tthis.hasPositions = false;\n\t\tthis.hasNormals = false;\n\t\tthis.hasColors = false;\n\t\tthis.hasUvs = false;\n\n\t\tthis.positionArray = null;\n\t\tthis.normalArray = null;\n\t\tthis.colorArray = null;\n\t\tthis.uvArray = null;\n\n\t\tthis.count = 0;\n\n\t}\n\n}\n\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateMatrixWorld();\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'SkeletonHelper';\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object && object.isBone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the radials\n\n\t\tfor ( let i = 0; i <= radials; i ++ ) {\n\n\t\t\tconst v = ( i / radials ) * ( Math.PI * 2 );\n\n\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tvertices.push( x, 0, z );\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t}\n\n\t\t// create the circles\n\n\t\tfor ( let i = 0; i <= circles; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / circles * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2', colorFrustum );\n\t\taddLine( 'n2', 'n4', colorFrustum );\n\t\taddLine( 'n4', 'n3', colorFrustum );\n\t\taddLine( 'n3', 'n1', colorFrustum );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2', colorFrustum );\n\t\taddLine( 'f2', 'f4', colorFrustum );\n\t\taddLine( 'f4', 'f3', colorFrustum );\n\t\taddLine( 'f3', 'f1', colorFrustum );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1', colorFrustum );\n\t\taddLine( 'n2', 'f2', colorFrustum );\n\t\taddLine( 'n3', 'f3', colorFrustum );\n\t\taddLine( 'n4', 'f4', colorFrustum );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1', colorCone );\n\t\taddLine( 'p', 'n2', colorCone );\n\t\taddLine( 'p', 'n3', colorCone );\n\t\taddLine( 'p', 'n4', colorCone );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2', colorUp );\n\t\taddLine( 'u2', 'u3', colorUp );\n\t\taddLine( 'u3', 'u1', colorUp );\n\n\t\t// target\n\n\t\taddLine( 'c', 't', colorTarget );\n\t\taddLine( 'p', 'c', colorCross );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2', colorCross );\n\t\taddLine( 'cn3', 'cn4', colorCross );\n\n\t\taddLine( 'cf1', 'cf2', colorCross );\n\t\taddLine( 'cf3', 'cf4', colorCross );\n\n\t\tfunction addLine( a, b, color ) {\n\n\t\t\taddPoint( a, color );\n\t\t\taddPoint( b, color );\n\n\t\t}\n\n\t\tfunction addPoint( id, color ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tLineSegments.prototype.copy.call( this, source );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tlet scale = - this.plane.constant;\n\n\t\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\n\n\t\tthis.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _floatView = new Float32Array( 1 );\nconst _int32View = new Int32Array( _floatView.buffer );\n\nclass DataUtils {\n\n\t// Converts float32 to float16 (stored as uint16 value).\n\n\tstatic toHalfFloat( val ) {\n\n\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t* used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t* by James Tursa?s half-precision code. */\n\n\t\t_floatView[ 0 ] = val;\n\t\tconst x = _int32View[ 0 ];\n\n\t\tlet bits = ( x >> 16 ) & 0x8000; /* Get the sign */\n\t\tlet m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */\n\t\tconst e = ( x >> 23 ) & 0xff; /* Using int is faster here */\n\n\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t* half, return signed zero. */\n\t\tif ( e < 103 ) return bits;\n\n\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\tif ( e > 142 ) {\n\n\t\t\tbits |= 0x7c00;\n\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\n\t\t\treturn bits;\n\n\t\t}\n\n\t\t/* If exponent underflows but not too much, return a denormal */\n\t\tif ( e < 113 ) {\n\n\t\t\tm |= 0x0800;\n\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t* to 1, which is OK. */\n\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\n\t\t\treturn bits;\n\n\t\t}\n\n\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\n\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t* the exponent, which is OK. */\n\t\tbits += m & 1;\n\t\treturn bits;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow( 2, LOD_MAX );\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst ENCODINGS = {\n\t[ LinearEncoding ]: 0,\n\t[ sRGBEncoding ]: 1,\n\t[ RGBEEncoding ]: 2,\n\t[ RGBM7Encoding ]: 3,\n\t[ RGBM16Encoding ]: 4,\n\t[ RGBDEncoding ]: 5,\n\t[ GammaEncoding ]: 6\n};\n\nconst backgroundMaterial = new MeshBasicMaterial( {\n\tside: BackSide,\n\tdepthWrite: false,\n\tdepthTest: false,\n} );\nconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nfunction convertLinearToRGBE( color ) {\n\n\tconst maxComponent = Math.max( color.r, color.g, color.b );\n\tconst fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\n\tcolor.multiplyScalar( Math.pow( 2.0, - fExp ) );\n\n\tconst alpha = ( fExp + 128.0 ) / 255.0;\n\treturn alpha;\n\n}\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._blurMaterial = _getBlurShader( MAX_SAMPLES );\n\t\tthis._equirectShader = null;\n\t\tthis._cubemapShader = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular ) {\n\n\t\treturn this._fromTexture( equirectangular );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap ) {\n\n\t\treturn this._fromTexture( cubemap );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapShader === null ) {\n\n\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\tthis._compileMaterial( this._cubemapShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectShader === null ) {\n\n\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\tthis._compileMaterial( this._equirectShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._blurMaterial.dispose();\n\n\t\tif ( this._cubemapShader !== null ) this._cubemapShader.dispose();\n\t\tif ( this._equirectShader !== null ) this._equirectShader.dispose();\n\n\t\tfor ( let i = 0; i < _lodPlanes.length; i ++ ) {\n\n\t\t\t_lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._pingPongRenderTarget.dispose();\n\t\tthis._renderer.setRenderTarget( _oldTarget );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets( texture );\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets( texture ) { // warning: null texture is valid\n\n\t\tconst params = {\n\t\t\tmagFilter: NearestFilter,\n\t\t\tminFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: UnsignedByteType,\n\t\t\tformat: RGBEFormat,\n\t\t\tencoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( params );\n\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\tthis._pingPongRenderTarget = _createRenderTarget( params );\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( _lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst outputEncoding = renderer.outputEncoding;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputEncoding = LinearEncoding;\n\t\trenderer.autoClear = false;\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background ).convertSRGBToLinear();\n\t\t\t\tscene.background = null;\n\n\t\t\t\tconst alpha = convertLinearToRGBE( backgroundMaterial.color );\n\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();\n\n\t\t\tconst alpha = convertLinearToRGBE( backgroundMaterial.color );\n\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\t\t\tif ( col == 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col == 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\t_setViewport( cubeUVRenderTarget,\n\t\t\t\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputEncoding = outputEncoding;\n\t\trenderer.autoClear = originalAutoClear;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( this._cubemapShader == null ) {\n\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectShader == null ) {\n\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\tconst mesh = new Mesh( _lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tif ( ! texture.isCubeTexture ) {\n\n\t\t\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\n\n\t\t}\n\n\t\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\t\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tfor ( let i = 1; i < TOTAL_LODS; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = _sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i == 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\n\t\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\t\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\n\t\tconst outputSize = _sizeLods[ lodOut ];\n\t\tconst x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\n\t\tconst y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _isLDR( texture ) {\n\n\tif ( texture === undefined || texture.type !== UnsignedByteType ) return false;\n\n\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\n}\n\nfunction _createPlanes() {\n\n\tconst _lodPlanes = [];\n\tconst _sizeLods = [];\n\tconst _sigmas = [];\n\n\tlet lod = LOD_MAX;\n\n\tfor ( let i = 0; i < TOTAL_LODS; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\t_sizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > LOD_MAX - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\n\n\t\t} else if ( i == 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\t_sigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 1 );\n\t\tconst min = - texelSize / 2;\n\t\tconst max = 1 + texelSize / 2;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\t_lodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { _lodPlanes, _sizeLods, _sigmas };\n\n}\n\nfunction _createRenderTarget( params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( maxSamples ) {\n\n\tconst weights = new Float32Array( maxSamples );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: { 'n': maxSamples },\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectShader() {\n\n\tconst texelSize = new Vector2( 1, 1 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'texelSize': { value: texelSize },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCubemapShader() {\n\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction _getEncodings() {\n\n\treturn /* glsl */`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`;\n\n}\n\nconst LineStrip = 0;\nconst LinePieces = 1;\nconst NoColors = 0;\nconst FaceColors = 1;\nconst VertexColors = 2;\n\nfunction MeshFaceMaterial( materials ) {\n\n\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\n\treturn materials;\n\n}\n\nfunction MultiMaterial( materials = [] ) {\n\n\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\n\tmaterials.isMultiMaterial = true;\n\tmaterials.materials = materials;\n\tmaterials.clone = function () {\n\n\t\treturn materials.slice();\n\n\t};\n\n\treturn materials;\n\n}\n\nfunction PointCloud( geometry, material ) {\n\n\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction Particle( material ) {\n\n\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n\treturn new Sprite( material );\n\n}\n\nfunction ParticleSystem( geometry, material ) {\n\n\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction PointCloudMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleBasicMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleSystemMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction Vertex( x, y, z ) {\n\n\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\treturn new Vector3( x, y, z );\n\n}\n\n//\n\nfunction DynamicBufferAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );\n\treturn new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );\n\n}\n\nfunction Int8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n\treturn new Int8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n\treturn new Uint8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n\treturn new Uint8ClampedBufferAttribute( array, itemSize );\n\n}\n\nfunction Int16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n\treturn new Int16BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n\treturn new Uint16BufferAttribute( array, itemSize );\n\n}\n\nfunction Int32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n\treturn new Int32BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n\treturn new Uint32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n\treturn new Float32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float64Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n\treturn new Float64BufferAttribute( array, itemSize );\n\n}\n\n//\n\nCurve.create = function ( construct, getPoint ) {\n\n\tconsole.log( 'THREE.Curve.create() has been deprecated' );\n\n\tconstruct.prototype = Object.create( Curve.prototype );\n\tconstruct.prototype.constructor = construct;\n\tconstruct.prototype.getPoint = getPoint;\n\n\treturn construct;\n\n};\n\n//\n\nPath.prototype.fromPoints = function ( points ) {\n\n\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\n\treturn this.setFromPoints( points );\n\n};\n\n//\n\nfunction AxisHelper( size ) {\n\n\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\n\treturn new AxesHelper( size );\n\n}\n\nfunction BoundingBoxHelper( object, color ) {\n\n\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n\treturn new BoxHelper( object, color );\n\n}\n\nfunction EdgesHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\nGridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\nSkeletonHelper.prototype.update = function () {\n\n\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\n\n};\n\nfunction WireframeHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\n//\n\nLoader.prototype.extractUrlBase = function ( url ) {\n\n\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\n\treturn LoaderUtils.extractUrlBase( url );\n\n};\n\nLoader.Handlers = {\n\n\tadd: function ( /* regex, loader */ ) {\n\n\t\tconsole.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );\n\n\t},\n\n\tget: function ( /* file */ ) {\n\n\t\tconsole.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );\n\n\t}\n\n};\n\nfunction XHRLoader( manager ) {\n\n\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n\treturn new FileLoader( manager );\n\n}\n\nfunction BinaryTextureLoader( manager ) {\n\n\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n\treturn new DataTextureLoader( manager );\n\n}\n\n//\n\nBox2.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\nBox2.prototype.empty = function () {\n\n\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\treturn this.isEmpty();\n\n};\n\nBox2.prototype.isIntersectionBox = function ( box ) {\n\n\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\treturn this.intersectsBox( box );\n\n};\n\nBox2.prototype.size = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\treturn this.getSize( optionalTarget );\n\n};\n\n//\n\nBox3.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\nBox3.prototype.empty = function () {\n\n\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\treturn this.isEmpty();\n\n};\n\nBox3.prototype.isIntersectionBox = function ( box ) {\n\n\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\treturn this.intersectsBox( box );\n\n};\n\nBox3.prototype.isIntersectionSphere = function ( sphere ) {\n\n\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\treturn this.intersectsSphere( sphere );\n\n};\n\nBox3.prototype.size = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\treturn this.getSize( optionalTarget );\n\n};\n\n//\n\nSphere.prototype.empty = function () {\n\n\tconsole.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );\n\treturn this.isEmpty();\n\n};\n\n//\n\nFrustum.prototype.setFromMatrix = function ( m ) {\n\n\tconsole.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );\n\treturn this.setFromProjectionMatrix( m );\n\n};\n\n//\n\nLine3.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\n//\n\nMatrix3.prototype.flattenToArrayOffset = function ( array, offset ) {\n\n\tconsole.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );\n\treturn this.toArray( array, offset );\n\n};\n\nMatrix3.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\treturn vector.applyMatrix3( this );\n\n};\n\nMatrix3.prototype.multiplyVector3Array = function ( /* a */ ) {\n\n\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\n\n};\n\nMatrix3.prototype.applyToBufferAttribute = function ( attribute ) {\n\n\tconsole.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );\n\treturn attribute.applyMatrix3( this );\n\n};\n\nMatrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {\n\n\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\n};\n\nMatrix3.prototype.getInverse = function ( matrix ) {\n\n\tconsole.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );\n\treturn this.copy( matrix ).invert();\n\n};\n\n//\n\nMatrix4.prototype.extractPosition = function ( m ) {\n\n\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\treturn this.copyPosition( m );\n\n};\n\nMatrix4.prototype.flattenToArrayOffset = function ( array, offset ) {\n\n\tconsole.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );\n\treturn this.toArray( array, offset );\n\n};\n\nMatrix4.prototype.getPosition = function () {\n\n\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\treturn new Vector3().setFromMatrixColumn( this, 3 );\n\n};\n\nMatrix4.prototype.setRotationFromQuaternion = function ( q ) {\n\n\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\treturn this.makeRotationFromQuaternion( q );\n\n};\n\nMatrix4.prototype.multiplyToArray = function () {\n\n\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\n\n};\n\nMatrix4.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\treturn vector.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.multiplyVector4 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\treturn vector.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.multiplyVector3Array = function ( /* a */ ) {\n\n\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateAxis = function ( v ) {\n\n\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\tv.transformDirection( this );\n\n};\n\nMatrix4.prototype.crossVector = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\treturn vector.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.translate = function () {\n\n\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateX = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateY = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateZ = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateByAxis = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\n};\n\nMatrix4.prototype.applyToBufferAttribute = function ( attribute ) {\n\n\tconsole.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );\n\treturn attribute.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {\n\n\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\n};\n\nMatrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {\n\n\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n\treturn this.makePerspective( left, right, top, bottom, near, far );\n\n};\n\nMatrix4.prototype.getInverse = function ( matrix ) {\n\n\tconsole.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );\n\treturn this.copy( matrix ).invert();\n\n};\n\n//\n\nPlane.prototype.isIntersectionLine = function ( line ) {\n\n\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\treturn this.intersectsLine( line );\n\n};\n\n//\n\nQuaternion.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\treturn vector.applyQuaternion( this );\n\n};\n\nQuaternion.prototype.inverse = function ( ) {\n\n\tconsole.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );\n\treturn this.invert();\n\n};\n\n//\n\nRay.prototype.isIntersectionBox = function ( box ) {\n\n\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\treturn this.intersectsBox( box );\n\n};\n\nRay.prototype.isIntersectionPlane = function ( plane ) {\n\n\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\treturn this.intersectsPlane( plane );\n\n};\n\nRay.prototype.isIntersectionSphere = function ( sphere ) {\n\n\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\treturn this.intersectsSphere( sphere );\n\n};\n\n//\n\nTriangle.prototype.area = function () {\n\n\tconsole.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );\n\treturn this.getArea();\n\n};\n\nTriangle.prototype.barycoordFromPoint = function ( point, target ) {\n\n\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\treturn this.getBarycoord( point, target );\n\n};\n\nTriangle.prototype.midpoint = function ( target ) {\n\n\tconsole.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );\n\treturn this.getMidpoint( target );\n\n};\n\nTriangle.prototypenormal = function ( target ) {\n\n\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\treturn this.getNormal( target );\n\n};\n\nTriangle.prototype.plane = function ( target ) {\n\n\tconsole.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );\n\treturn this.getPlane( target );\n\n};\n\nTriangle.barycoordFromPoint = function ( point, a, b, c, target ) {\n\n\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\treturn Triangle.getBarycoord( point, a, b, c, target );\n\n};\n\nTriangle.normal = function ( a, b, c, target ) {\n\n\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\treturn Triangle.getNormal( a, b, c, target );\n\n};\n\n//\n\nShape.prototype.extractAllPoints = function ( divisions ) {\n\n\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\n\treturn this.extractPoints( divisions );\n\n};\n\nShape.prototype.extrude = function ( options ) {\n\n\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\treturn new ExtrudeGeometry( this, options );\n\n};\n\nShape.prototype.makeGeometry = function ( options ) {\n\n\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\treturn new ShapeGeometry( this, options );\n\n};\n\n//\n\nVector2.prototype.fromAttribute = function ( attribute, index, offset ) {\n\n\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\treturn this.fromBufferAttribute( attribute, index, offset );\n\n};\n\nVector2.prototype.distanceToManhattan = function ( v ) {\n\n\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\treturn this.manhattanDistanceTo( v );\n\n};\n\nVector2.prototype.lengthManhattan = function () {\n\n\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\n\treturn this.manhattanLength();\n\n};\n\n//\n\nVector3.prototype.setEulerFromRotationMatrix = function () {\n\n\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\n};\n\nVector3.prototype.setEulerFromQuaternion = function () {\n\n\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\n};\n\nVector3.prototype.getPositionFromMatrix = function ( m ) {\n\n\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\treturn this.setFromMatrixPosition( m );\n\n};\n\nVector3.prototype.getScaleFromMatrix = function ( m ) {\n\n\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\treturn this.setFromMatrixScale( m );\n\n};\n\nVector3.prototype.getColumnFromMatrix = function ( index, matrix ) {\n\n\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\treturn this.setFromMatrixColumn( matrix, index );\n\n};\n\nVector3.prototype.applyProjection = function ( m ) {\n\n\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n\treturn this.applyMatrix4( m );\n\n};\n\nVector3.prototype.fromAttribute = function ( attribute, index, offset ) {\n\n\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\treturn this.fromBufferAttribute( attribute, index, offset );\n\n};\n\nVector3.prototype.distanceToManhattan = function ( v ) {\n\n\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\treturn this.manhattanDistanceTo( v );\n\n};\n\nVector3.prototype.lengthManhattan = function () {\n\n\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\n\treturn this.manhattanLength();\n\n};\n\n//\n\nVector4.prototype.fromAttribute = function ( attribute, index, offset ) {\n\n\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\treturn this.fromBufferAttribute( attribute, index, offset );\n\n};\n\nVector4.prototype.lengthManhattan = function () {\n\n\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\n\treturn this.manhattanLength();\n\n};\n\n//\n\nObject3D.prototype.getChildByName = function ( name ) {\n\n\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\treturn this.getObjectByName( name );\n\n};\n\nObject3D.prototype.renderDepth = function () {\n\n\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\n};\n\nObject3D.prototype.translate = function ( distance, axis ) {\n\n\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\treturn this.translateOnAxis( axis, distance );\n\n};\n\nObject3D.prototype.getWorldRotation = function () {\n\n\tconsole.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );\n\n};\n\nObject3D.prototype.applyMatrix = function ( matrix ) {\n\n\tconsole.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );\n\treturn this.applyMatrix4( matrix );\n\n};\n\nObject.defineProperties( Object3D.prototype, {\n\n\teulerOrder: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t}\n\t}\n\n} );\n\nMesh.prototype.setDrawMode = function () {\n\n\tconsole.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );\n\n};\n\nObject.defineProperties( Mesh.prototype, {\n\n\tdrawMode: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );\n\t\t\treturn TrianglesDrawMode;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );\n\n\t\t}\n\t}\n\n} );\n\nSkinnedMesh.prototype.initBones = function () {\n\n\tconsole.error( 'THREE.SkinnedMesh: initBones() has been removed.' );\n\n};\n\n//\n\nPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +\n\t\t\t'Use .setFocalLength and .filmGauge for a photographic setup.' );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( Light.prototype, {\n\tonlyShadow: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( BufferAttribute.prototype, {\n\n\tlength: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n\t\t\treturn this.array.length;\n\n\t\t}\n\t},\n\tdynamic: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );\n\t\t\treturn this.usage === DynamicDrawUsage;\n\n\t\t},\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );\n\t\t\tthis.setUsage( DynamicDrawUsage );\n\n\t\t}\n\t}\n\n} );\n\nBufferAttribute.prototype.setDynamic = function ( value ) {\n\n\tconsole.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );\n\tthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );\n\treturn this;\n\n};\n\nBufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {\n\n\tconsole.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );\n\n},\n\nBufferAttribute.prototype.setArray = function ( /* array */ ) {\n\n\tconsole.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );\n\n};\n\n//\n\nBufferGeometry.prototype.addIndex = function ( index ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\tthis.setIndex( index );\n\n};\n\nBufferGeometry.prototype.addAttribute = function ( name, attribute ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );\n\n\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\treturn this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t}\n\n\tif ( name === 'index' ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\tthis.setIndex( attribute );\n\n\t\treturn this;\n\n\t}\n\n\treturn this.setAttribute( name, attribute );\n\n};\n\nBufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {\n\n\tif ( indexOffset !== undefined ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\n\t}\n\n\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\tthis.addGroup( start, count );\n\n};\n\nBufferGeometry.prototype.clearDrawCalls = function () {\n\n\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\tthis.clearGroups();\n\n};\n\nBufferGeometry.prototype.computeOffsets = function () {\n\n\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\n};\n\nBufferGeometry.prototype.removeAttribute = function ( name ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );\n\n\treturn this.deleteAttribute( name );\n\n};\n\nBufferGeometry.prototype.applyMatrix = function ( matrix ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );\n\treturn this.applyMatrix4( matrix );\n\n};\n\nObject.defineProperties( BufferGeometry.prototype, {\n\n\tdrawcalls: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t}\n\n} );\n\nInterleavedBuffer.prototype.setDynamic = function ( value ) {\n\n\tconsole.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );\n\tthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );\n\treturn this;\n\n};\n\nInterleavedBuffer.prototype.setArray = function ( /* array */ ) {\n\n\tconsole.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );\n\n};\n\n//\n\nExtrudeGeometry.prototype.getArrays = function () {\n\n\tconsole.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );\n\n};\n\nExtrudeGeometry.prototype.addShapeList = function () {\n\n\tconsole.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );\n\n};\n\nExtrudeGeometry.prototype.addShape = function () {\n\n\tconsole.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );\n\n};\n\n//\n\nScene.prototype.dispose = function () {\n\n\tconsole.error( 'THREE.Scene: .dispose() has been removed.' );\n\n};\n\n//\n\nUniform.prototype.onUpdate = function () {\n\n\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\treturn this;\n\n};\n\n//\n\nObject.defineProperties( Material.prototype, {\n\n\twrapAround: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t}\n\t},\n\n\toverdraw: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t}\n\t},\n\n\twrapRGB: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\n\t\t\treturn new Color();\n\n\t\t}\n\t},\n\n\tshading: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\tthis.flatShading = ( value === FlatShading );\n\n\t\t}\n\t},\n\n\tstencilMask: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );\n\t\t\treturn this.stencilFuncMask;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );\n\t\t\tthis.stencilFuncMask = value;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( ShaderMaterial.prototype, {\n\n\tderivatives: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nWebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );\n\tthis.setRenderTarget( renderTarget );\n\tthis.clear( color, depth, stencil );\n\n};\n\nWebGLRenderer.prototype.animate = function ( callback ) {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );\n\tthis.setAnimationLoop( callback );\n\n};\n\nWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\n\treturn this.getRenderTarget();\n\n};\n\nWebGLRenderer.prototype.getMaxAnisotropy = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\n\treturn this.capabilities.getMaxAnisotropy();\n\n};\n\nWebGLRenderer.prototype.getPrecision = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\n\treturn this.capabilities.precision;\n\n};\n\nWebGLRenderer.prototype.resetGLState = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\n\treturn this.state.reset();\n\n};\n\nWebGLRenderer.prototype.supportsFloatTextures = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\treturn this.extensions.get( 'OES_texture_float' );\n\n};\n\nWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\treturn this.extensions.get( 'OES_texture_half_float' );\n\n};\n\nWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\treturn this.extensions.get( 'OES_standard_derivatives' );\n\n};\n\nWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n};\n\nWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n};\n\nWebGLRenderer.prototype.supportsBlendMinMax = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\treturn this.extensions.get( 'EXT_blend_minmax' );\n\n};\n\nWebGLRenderer.prototype.supportsVertexTextures = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n\treturn this.capabilities.vertexTextures;\n\n};\n\nWebGLRenderer.prototype.supportsInstancedArrays = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\n};\n\nWebGLRenderer.prototype.enableScissorTest = function ( boolean ) {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\tthis.setScissorTest( boolean );\n\n};\n\nWebGLRenderer.prototype.initMaterial = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.addPrePlugin = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.addPostPlugin = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.updateShadowMap = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setFaceCulling = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.allocTextureUnit = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setTexture = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setTexture2D = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setTextureCube = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );\n\treturn this.getActiveMipmapLevel();\n\n};\n\nObject.defineProperties( WebGLRenderer.prototype, {\n\n\tshadowMapEnabled: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.enabled;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\tcontext: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );\n\t\t\treturn this.getContext();\n\n\t\t}\n\t},\n\tvr: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );\n\t\t\treturn this.xr;\n\n\t\t}\n\t},\n\tgammaInput: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );\n\t\t\treturn false;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );\n\n\t\t}\n\t},\n\tgammaOutput: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );\n\t\t\treturn false;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );\n\t\t\tthis.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;\n\n\t\t}\n\t},\n\ttoneMappingWhitePoint: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );\n\t\t\treturn 1.0;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );\n\n\t\t}\n\t},\n\n} );\n\nObject.defineProperties( WebGLShadowMap.prototype, {\n\n\tcullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* cullFace */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderReverseSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderSingleSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t}\n\n} );\n\nfunction WebGLRenderTargetCube( width, height, options ) {\n\n\tconsole.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );\n\treturn new WebGLCubeRenderTarget( width, options );\n\n}\n\n//\n\nObject.defineProperties( WebGLRenderTarget.prototype, {\n\n\twrapS: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nAudio.prototype.load = function ( file ) {\n\n\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n\tconst scope = this;\n\tconst audioLoader = new AudioLoader();\n\taudioLoader.load( file, function ( buffer ) {\n\n\t\tscope.setBuffer( buffer );\n\n\t} );\n\treturn this;\n\n};\n\n\nAudioAnalyser.prototype.getData = function () {\n\n\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\treturn this.getFrequencyData();\n\n};\n\n//\n\nCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\n\n\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\n\treturn this.update( renderer, scene );\n\n};\n\nCubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {\n\n\tconsole.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );\n\treturn this.renderTarget.clear( renderer, color, depth, stencil );\n\n};\n\nImageUtils.crossOrigin = undefined;\n\nImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\tconst loader = new TextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tconst texture = loader.load( url, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\tconst loader = new CubeTextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tconst texture = loader.load( urls, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadCompressedTexture = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\nImageUtils.loadCompressedTextureCube = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\n//\n\nfunction CanvasRenderer() {\n\n\tconsole.error( 'THREE.CanvasRenderer has been removed' );\n\n}\n\n//\n\nfunction JSONLoader() {\n\n\tconsole.error( 'THREE.JSONLoader has been removed.' );\n\n}\n\n//\n\nconst SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\n\n\t},\n\n\tdetach: function ( /* child, parent, scene */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\n\n\t},\n\n\tattach: function ( /* child, scene, parent */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\n\n\t}\n\n};\n\n//\n\nfunction LensFlare() {\n\n\tconsole.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t/* eslint-disable no-undef */\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\t/* eslint-enable no-undef */\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack://vrm-test/./node_modules/three/build/three.module.js?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/OrbitControls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/OrbitControls.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OrbitControls\": () => (/* binding */ OrbitControls),\n/* harmony export */   \"MapControls\": () => (/* binding */ MapControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nclass OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tif ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tif ( domElement === document ) console.error( 'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.' );\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE, MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY, RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tconst lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update() {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerCancel );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );\n\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n\t\tconst sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tlet zoomChanged = false;\n\n\t\tconst rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tconst panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tconst dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( /*event*/ ) {\n\n\t\t\t// no-op\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly() {\n\n\t\t\tconst dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;\n\t\t\tconst dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan();\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate();\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchEnd( /*event*/ ) {\n\n\t\t\t// no-op\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchEnd();\n\n\t\t\t} else {\n\n\t\t\t\tonMouseUp( event );\n\n\t\t\t}\n\n\t\t\tremovePointer( event );\n\n\t\t\t//\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerCancel( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointer.pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerCancel );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper( object, domElement );\n\n\t\tthis.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n\t\tthis.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n\t\tthis.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n\n\t\tthis.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n\t\tthis.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack://vrm-test/./node_modules/three/examples/jsm/controls/OrbitControls.js?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/BVHLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/BVHLoader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BVHLoader\": () => (/* binding */ BVHLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.animateBonePositions = true;\n\t\tthis.animateBoneRotations = true;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\t/*\n\t\t\treads a string array (lines) from a BVH file\n\t\t\tand outputs a skeleton structure including motion data\n\n\t\t\treturns thee root node:\n\t\t\t{ name: '', channels: [], children: [] }\n\t\t*/\n\t\tfunction readBvh( lines ) {\n\n\t\t\t// read model structure\n\n\t\t\tif ( nextLine( lines ) !== 'HIERARCHY' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: HIERARCHY expected.' );\n\n\t\t\t}\n\n\t\t\tconst list = []; // collects flat array of all bones\n\t\t\tconst root = readNode( lines, nextLine( lines ), list );\n\n\t\t\t// read motion data\n\n\t\t\tif ( nextLine( lines ) !== 'MOTION' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: MOTION expected.' );\n\n\t\t\t}\n\n\t\t\t// number of frames\n\n\t\t\tlet tokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst numFrames = parseInt( tokens[ 1 ] );\n\n\t\t\tif ( isNaN( numFrames ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read number of frames.' );\n\n\t\t\t}\n\n\t\t\t// frame time\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst frameTime = parseFloat( tokens[ 2 ] );\n\n\t\t\tif ( isNaN( frameTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read frame time.' );\n\n\t\t\t}\n\n\t\t\t// read frame data line by line\n\n\t\t\tfor ( let i = 0; i < numFrames; i ++ ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\treadFrameData( tokens, i * frameTime, root );\n\n\t\t\t}\n\n\t\t\treturn list;\n\n\t\t}\n\n\t\t/*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n\t\tfunction readFrameData( data, frameTime, bone ) {\n\n\t\t\t// end sites have no motion data\n\n\t\t\tif ( bone.type === 'ENDSITE' ) return;\n\n\t\t\t// add keyframe\n\n\t\t\tconst keyframe = {\n\t\t\t\ttime: frameTime,\n\t\t\t\tposition: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\trotation: new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion()\n\t\t\t};\n\n\t\t\tbone.frames.push( keyframe );\n\n\t\t\tconst quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\n\t\t\tconst vx = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 0, 0 );\n\t\t\tconst vy = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 );\n\t\t\tconst vz = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 1 );\n\n\t\t\t// parse values for each channel in node\n\n\t\t\tfor ( let i = 0; i < bone.channels.length; i ++ ) {\n\n\t\t\t\tswitch ( bone.channels[ i ] ) {\n\n\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\tkeyframe.position.x = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\tkeyframe.position.y = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\tkeyframe.position.z = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.BVHLoader: Invalid channel type.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse child nodes\n\n\t\t\tfor ( let i = 0; i < bone.children.length; i ++ ) {\n\n\t\t\t\treadFrameData( data, frameTime, bone.children[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t Recursively parses the HIERACHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n\t\tfunction readNode( lines, firstline, list ) {\n\n\t\t\tconst node = { name: '', type: '', frames: [] };\n\t\t\tlist.push( node );\n\n\t\t\t// parse node type and name\n\n\t\t\tlet tokens = firstline.split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {\n\n\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\n\t\t\t} else {\n\n\t\t\t\tnode.name = tokens[ 1 ];\n\t\t\t\tnode.type = tokens[ 0 ].toUpperCase();\n\n\t\t\t}\n\n\t\t\tif ( nextLine( lines ) !== '{' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected opening { after type & name' );\n\n\t\t\t}\n\n\t\t\t// parse OFFSET\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ] !== 'OFFSET' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( tokens.length !== 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );\n\n\t\t\t}\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(\n\t\t\t\tparseFloat( tokens[ 1 ] ),\n\t\t\t\tparseFloat( tokens[ 2 ] ),\n\t\t\t\tparseFloat( tokens[ 3 ] )\n\t\t\t);\n\n\t\t\tif ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );\n\n\t\t\t}\n\n\t\t\tnode.offset = offset;\n\n\t\t\t// parse CHANNELS definitions\n\n\t\t\tif ( node.type !== 'ENDSITE' ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\t\tif ( tokens[ 0 ] !== 'CHANNELS' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst numChannels = parseInt( tokens[ 1 ] );\n\t\t\t\tnode.channels = tokens.splice( 2, numChannels );\n\t\t\t\tnode.children = [];\n\n\t\t\t}\n\n\t\t\t// read children\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tconst line = nextLine( lines );\n\n\t\t\t\tif ( line === '}' ) {\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.children.push( readNode( lines, line, list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n\t\tfunction toTHREEBone( source, list ) {\n\n\t\t\tconst bone = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n\t\t\tlist.push( bone );\n\n\t\t\tbone.position.add( source.offset );\n\t\t\tbone.name = source.name;\n\n\t\t\tif ( source.type !== 'ENDSITE' ) {\n\n\t\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tbone.add( toTHREEBone( source.children[ i ], list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\t/*\n\t\t\tbuilds a AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: a AnimationClip containing position and quaternion tracks\n\t\t*/\n\t\tfunction toTHREEAnimation( bones ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\tconst bone = bones[ i ];\n\n\t\t\t\tif ( bone.type === 'ENDSITE' )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// track data\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst positions = [];\n\t\t\t\tconst rotations = [];\n\n\t\t\t\tfor ( let j = 0; j < bone.frames.length; j ++ ) {\n\n\t\t\t\t\tconst frame = bone.frames[ j ];\n\n\t\t\t\t\ttimes.push( frame.time );\n\n\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\tpositions.push( frame.position.x + bone.offset.x );\n\t\t\t\t\tpositions.push( frame.position.y + bone.offset.y );\n\t\t\t\t\tpositions.push( frame.position.z + bone.offset.z );\n\n\t\t\t\t\trotations.push( frame.rotation.x );\n\t\t\t\t\trotations.push( frame.rotation.y );\n\t\t\t\t\trotations.push( frame.rotation.z );\n\t\t\t\t\trotations.push( frame.rotation.w );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBonePositions ) {\n\n\t\t\t\t\ttracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack( '.bones[' + bone.name + '].position', times, positions ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBoneRotations ) {\n\n\t\t\t\t\ttracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack( '.bones[' + bone.name + '].quaternion', times, rotations ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( 'animation', - 1, tracks );\n\n\t\t}\n\n\t\t/*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n\t\tfunction nextLine( lines ) {\n\n\t\t\tlet line;\n\t\t\t// skip empty lines\n\t\t\twhile ( ( line = lines.shift().trim() ).length === 0 ) { }\n\n\t\t\treturn line;\n\n\t\t}\n\n\t\tconst scope = this;\n\n\t\tconst lines = text.split( /[\\r\\n]+/g );\n\n\t\tconst bones = readBvh( lines );\n\n\t\tconst threeBones = [];\n\t\ttoTHREEBone( bones[ 0 ], threeBones );\n\n\t\tconst threeClip = toTHREEAnimation( bones );\n\n\t\treturn {\n\t\t\tskeleton: new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( threeBones ),\n\t\t\tclip: threeClip\n\t\t};\n\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack://vrm-test/./node_modules/three/examples/jsm/loaders/BVHLoader.js?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFLoader\": () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet content;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tcontent = data;\n\n\t\t} else {\n\n\t\t\tconst magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t} else {\n\n\t\t\t\tcontent = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst json = JSON.parse( content );\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tmaterialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scale, - scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst source = json.images[ extension.source ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\tconst source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\n\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\treturn result;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\tif ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\nclass GLTFMeshStandardSGMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper();\n\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t//various chunks that need replacing\n\t\tconst specularMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst glossinessMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst specularMapFragmentChunk = [\n\t\t\t'vec3 specularFactor = specular;',\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst glossinessMapFragmentChunk = [\n\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst lightPhysicalFragmentChunk = [\n\t\t\t'PhysicalMaterial material;',\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t'material.specularColor = specularFactor;',\n\t\t].join( '\\n' );\n\n\t\tconst uniforms = {\n\t\t\tspecular: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Color().setHex( 0xffffff ) },\n\t\t\tglossiness: { value: 1 },\n\t\t\tspecularMap: { value: null },\n\t\t\tglossinessMap: { value: null }\n\t\t};\n\n\t\tthis._extraUniforms = uniforms;\n\n\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\tfor ( const uniformName in uniforms ) {\n\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t}\n\n\t\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t};\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tspecular: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specular.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specular.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tspecularMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specularMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specularMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossiness: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossiness.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossiness.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossinessMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossinessMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossinessMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\tthis.defines.USE_UV = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\t\t\t\t\t\tdelete this.defines.USE_UV;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.specularMap = source.specularMap;\n\t\tthis.specular.copy( source.specular );\n\t\tthis.glossinessMap = source.glossinessMap;\n\t\tthis.glossiness = source.glossiness;\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\n\t\tthis.specularGlossinessParams = [\n\t\t\t'color',\n\t\t\t'map',\n\t\t\t'lightMap',\n\t\t\t'lightMapIntensity',\n\t\t\t'aoMap',\n\t\t\t'aoMapIntensity',\n\t\t\t'emissive',\n\t\t\t'emissiveIntensity',\n\t\t\t'emissiveMap',\n\t\t\t'bumpMap',\n\t\t\t'bumpScale',\n\t\t\t'normalMap',\n\t\t\t'normalMapType',\n\t\t\t'displacementMap',\n\t\t\t'displacementScale',\n\t\t\t'displacementBias',\n\t\t\t'specularMap',\n\t\t\t'specular',\n\t\t\t'glossinessMap',\n\t\t\t'glossiness',\n\t\t\t'alphaMap',\n\t\t\t'envMap',\n\t\t\t'envMapIntensity',\n\t\t\t'refractionRatio',\n\t\t];\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn GLTFMeshStandardSGMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst pending = [];\n\n\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\tconst array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\tmaterialParams.color.fromArray( array );\n\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t}\n\n\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0.0, 0.0, 0.0 );\n\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\tmaterialParams.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\n\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t}\n\n\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\tconst specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\tcreateMaterial( materialParams ) {\n\n\t\tconst material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\tmaterial.fog = true;\n\n\t\tmaterial.color = materialParams.color;\n\n\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\tmaterial.lightMap = null;\n\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\tmaterial.emissive = materialParams.emissive;\n\t\tmaterial.emissiveIntensity = 1.0;\n\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\tmaterial.bumpScale = 1;\n\n\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\tmaterial.normalMapType = three__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap;\n\n\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\tmaterial.displacementMap = null;\n\t\tmaterial.displacementScale = 1;\n\t\tmaterial.displacementBias = 0;\n\n\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\tmaterial.specular = materialParams.specular;\n\n\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\tmaterial.alphaMap = null;\n\n\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\tmaterial.envMapIntensity = 1.0;\n\n\t\tmaterial.refractionRatio = 0.98;\n\n\t\treturn material;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\tconst result = this.resultBuffer;\n\tconst values = this.sampleValues;\n\tconst stride = this.valueSize;\n\n\tconst stride2 = stride * 2;\n\tconst stride3 = stride * 3;\n\n\tconst td = t1 - t0;\n\n\tconst p = ( t - t0 ) / td;\n\tconst pp = p * p;\n\tconst ppp = pp * p;\n\n\tconst offset1 = i1 * stride3;\n\tconst offset0 = offset1 - stride3;\n\n\tconst s2 = - 2 * ppp + 3 * pp;\n\tconst s3 = ppp - pp;\n\tconst s0 = 1 - s2;\n\tconst s1 = s3 - pp + p;\n\n\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t}\n\n\treturn result;\n\n};\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n\t9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n\t9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n\t9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n\t9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n\t9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n\t33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n\t10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv2',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n\tSTEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/* UTILITY FUNCTIONS */\n\nfunction resolveURL( url, path ) {\n\n\t// Invalid URL\n\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t// Host Relative URL\n\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t}\n\n\t// Absolute URL http://,https://,//\n\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t// Data URI\n\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t// Blob URL\n\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t// Relative URL\n\treturn path + url;\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\tlet geometryKey;\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\n\n\t\t\tthis.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst source = json.images[ textureDef.source ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, source, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tconst cacheKey = ( source.uri || source.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = source.uri || '';\n\t\tlet isObjectURL = false;\n\t\tlet hasAlpha = true;\n\n\t\tconst isJPEG = sourceURI.search( /\\.jpe?g($|\\?)/i ) > 0 || sourceURI.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\tif ( source.mimeType === 'image/jpeg' || isJPEG ) hasAlpha = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\n\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n\t\t\t\t\t// alpha channel. This check is conservative  the image could have an alpha\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\n\t\t\t\t\t// sometimes contains alpha.\n\t\t\t\t\t//\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n\t\t\t\t\tconst colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n\n\t\t\t\t}\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( source.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\t\t\tif ( ! hasAlpha ) texture.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBFormat;\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, {\n\t\t\t\ttype: 'textures',\n\t\t\t\tindex: textureIndex\n\t\t\t} );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise}\n\t */\n\tassignTexture( materialParams, mapName, mapDef ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\t\tconst useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\tconst useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useMorphTargets ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\tif ( useVertexTangents ) {\n\n\t\t\t\t\tcachedMaterial.vertexTangents = true;\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tconst sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tmaterialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1, - 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tlet material;\n\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tlet name = sanitizedName;\n\n\t\tfor ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tlet TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tconst targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n\n\t\t\t\tconst targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t// Node may be a Group (glTF mesh with several primitives) or a Mesh.\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tlet outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\treturn ( function () {\n\n\t\t\tconst pending = [];\n\n\t\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t\t} );\n\n\t\t\tif ( meshPromise ) {\n\n\t\t\t\tpending.push( meshPromise );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t\t} ).forEach( function ( promise ) {\n\n\t\t\t\tpending.push( promise );\n\n\t\t\t} );\n\n\t\t\treturn Promise.all( pending );\n\n\t\t}() ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n}\n\nfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\tconst nodeDef = json.nodes[ nodeId ];\n\n\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t// build skeleton here as well\n\n\t\tlet skinEntry;\n\n\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\tskinEntry = skin;\n\n\t\t\tconst pendingJoints = [];\n\n\t\t\tfor ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pendingJoints );\n\n\t\t} ).then( function ( jointNodes ) {\n\n\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\tconst bones = [];\n\t\t\t\tconst boneInverses = [];\n\n\t\t\t\tfor ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst jointNode = jointNodes[ j ];\n\n\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\tconst mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.bind( new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t} );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t} ).then( function ( node ) {\n\n\t\t// build node hierachy\n\n\t\tparentObject.add( node );\n\n\t\tconst pending = [];\n\n\t\tif ( nodeDef.children ) {\n\n\t\t\tconst children = nodeDef.children;\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t} );\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tlet index = geometry.getIndex();\n\n\t// generate index if not present\n\n\tif ( index === null ) {\n\n\t\tconst indices = [];\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\tindices.push( i );\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\t\t\tindex = geometry.getIndex();\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tconst numberOfTriangles = index.count - 2;\n\tconst newIndices = [];\n\n\tif ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode ) {\n\n\t\t// gl.TRIANGLE_FAN\n\n\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t}\n\n\t} else {\n\n\t\t// gl.TRIANGLE_STRIP\n\n\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t} else {\n\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t}\n\n\t// build final geometry\n\n\tconst newGeometry = geometry.clone();\n\tnewGeometry.setIndex( newIndices );\n\n\treturn newGeometry;\n\n}\n\n\n\n\n//# sourceURL=webpack://vrm-test/./node_modules/three/examples/jsm/loaders/GLTFLoader.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_BVHLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/loaders/BVHLoader.js */ \"./node_modules/three/examples/jsm/loaders/BVHLoader.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n/* harmony import */ var _pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixiv/three-vrm */ \"./node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js\");\n\r\n\r\n\r\n\r\n\r\nvar faceExpressions = __webpack_require__(/*! ../lib/jeelizFaceExpressions.module.js */ \"./lib/jeelizFaceExpressions.module.js\");\r\nvar neuralNetworkModel = __webpack_require__(/*! ../lib/jeelizFaceExpressionsNNC.json */ \"./lib/jeelizFaceExpressionsNNC.json\");\r\nwindow.addEventListener(\"DOMContentLoaded\", function () {\r\n    var scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\r\n    var camera = new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n    camera.position.set(0, 1.1, -2);\r\n    var renderer = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\r\n        antialias: true\r\n    });\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    renderer.setClearColor(0x000000, 1.0);\r\n    document.body.appendChild(renderer.domElement);\r\n    var controls = new three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_2__.OrbitControls(camera, renderer.domElement);\r\n    controls.target.set(0, 0.85, 0);\r\n    controls.screenSpacePanning = true;\r\n    controls.update();\r\n    var light = new three__WEBPACK_IMPORTED_MODULE_4__.DirectionalLight(0xffffff);\r\n    light.position.set(-1, 1, -1).normalize();\r\n    scene.add(light);\r\n    var gridHelper = new three__WEBPACK_IMPORTED_MODULE_4__.GridHelper(50, 50);\r\n    scene.add(gridHelper);\r\n    var axesHelper = new three__WEBPACK_IMPORTED_MODULE_4__.AxesHelper(5);\r\n    scene.add(axesHelper);\r\n    var clock = new three__WEBPACK_IMPORTED_MODULE_4__.Clock();\r\n    var texture_loader = new three__WEBPACK_IMPORTED_MODULE_4__.CubeTextureLoader();\r\n    texture_loader.setPath('./asset/skybox/');\r\n    var textureCube = texture_loader.load([\r\n        'right.jpg',\r\n        'left.jpg',\r\n        'top.jpg',\r\n        'bottom.jpg',\r\n        'front.jpg',\r\n        'back.jpg'\r\n    ]);\r\n    scene.background = textureCube;\r\n    var BVHloader = new three_examples_jsm_loaders_BVHLoader_js__WEBPACK_IMPORTED_MODULE_1__.BVHLoader();\r\n    BVHloader.load(\"./pirouette.bvh\", function (result) {\r\n        var skeletonHelper = new three__WEBPACK_IMPORTED_MODULE_4__.SkeletonHelper(result.skeleton.bones[0]);\r\n        console.log(result.skeleton);\r\n        console.log(result.clip);\r\n    });\r\n    var mixer;\r\n    var currentVRM;\r\n    var head;\r\n    var neck;\r\n    var spine;\r\n    var loader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader();\r\n    loader.load('./AvatarSample_A.vrm', function (gltf) {\r\n        _pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRM.from(gltf).then(function (vrm) {\r\n            var _a;\r\n            console.log(vrm);\r\n            console.log(vrm.humanoid.humanBones[_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.Hips]);\r\n            currentVRM = vrm;\r\n            scene.add(vrm.scene);\r\n            vrm.lookAt.target = camera;\r\n            head = vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.Head);\r\n            neck = vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.Neck);\r\n            spine = vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.Spine);\r\n            vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.LeftUpperArm).rotation.x = 0.6;\r\n            vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.LeftLowerArm).rotation.x = 1.0;\r\n            vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.LeftLowerArm).rotation.y = -1.;\r\n            vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.LeftLowerArm).rotation.z = 0.1;\r\n            vrm.humanoid.getBoneNode(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.LeftHand).rotation.y = -0.5;\r\n            (_a = vrm.springBoneManager) === null || _a === void 0 ? void 0 : _a.colliderGroups;\r\n            var bones = [\r\n                _pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.HumanoidBoneName.LeftUpperArm\r\n            ].map(function (boneName) {\r\n                var _a;\r\n                return (_a = vrm.humanoid) === null || _a === void 0 ? void 0 : _a.getBoneNode(boneName);\r\n            });\r\n            var clip = three__WEBPACK_IMPORTED_MODULE_4__.AnimationClip.parseAnimation({\r\n                hierarchy: [\r\n                    {\r\n                        keys: [\r\n                            {\r\n                                rot: new three__WEBPACK_IMPORTED_MODULE_4__.Quaternion().setFromEuler(new three__WEBPACK_IMPORTED_MODULE_4__.Euler(0, 0, 0)).toArray(),\r\n                                time: 0\r\n                            },\r\n                            {\r\n                                rot: new three__WEBPACK_IMPORTED_MODULE_4__.Quaternion().setFromEuler(new three__WEBPACK_IMPORTED_MODULE_4__.Euler(0, 0, 45 * Math.PI / 180)).toArray(),\r\n                                time: 1000\r\n                            },\r\n                            {\r\n                                rot: new three__WEBPACK_IMPORTED_MODULE_4__.Quaternion().setFromEuler(new three__WEBPACK_IMPORTED_MODULE_4__.Euler(0, 0, 0)).toArray(),\r\n                                time: 2000\r\n                            }\r\n                        ]\r\n                    }\r\n                ]\r\n            }, bones);\r\n            console.log(clip);\r\n            clip.tracks.some(function (track) {\r\n                track.name = track.name.replace(/^.bones\\[([^\\]]+)\\].(position|quaternion|scale)$/, '$1.$2');\r\n            });\r\n            mixer = new three__WEBPACK_IMPORTED_MODULE_4__.AnimationMixer(vrm.scene);\r\n            var action = mixer.clipAction(clip);\r\n            action.play();\r\n        });\r\n    });\r\n    var jeelizCanvas = document.createElement('canvas');\r\n    jeelizCanvas.id = \"jeelizCanvas\";\r\n    document.body.appendChild(jeelizCanvas).style.display = 'none';\r\n    faceExpressions.init({\r\n        canvasId: \"jeelizCanvas\",\r\n        NNC: neuralNetworkModel,\r\n        callbackReady: function (errCode) {\r\n            if (errCode) {\r\n                console.log('ERROR CODE =', errCode);\r\n                return;\r\n            }\r\n            faceExpressions.switch_displayVideo(true);\r\n            console.log(\"Jeeliz is Ready\");\r\n        }\r\n    });\r\n    window.addEventListener('resize', onWindowResize, false);\r\n    function onWindowResize() {\r\n        camera.aspect = window.innerWidth / window.innerHeight;\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n    var update = function () {\r\n        requestAnimationFrame(update);\r\n        var delta = clock.getDelta();\r\n        if (currentVRM) {\r\n            currentVRM.update(delta);\r\n            if (faceExpressions.ready) {\r\n                var faceRotation = faceExpressions.get_rotationStabilized();\r\n                var faceExpression = faceExpressions.get_morphTargetInfluencesStabilized();\r\n                head.rotation.x = faceRotation[0] * 0.7 * -1;\r\n                head.rotation.y = -faceRotation[1] * 0.7;\r\n                head.rotation.z = -faceRotation[2] * 0.7 * -1;\r\n                neck.rotation.x = faceRotation[0] * 0.2;\r\n                neck.rotation.y = -faceRotation[1] * 0.2;\r\n                neck.rotation.z = -faceRotation[2] * 0.2;\r\n                spine.rotation.x = faceRotation[0] * 0.1 * -1;\r\n                spine.rotation.y = -faceRotation[1] * 0.1;\r\n                spine.rotation.z = -faceRotation[2] * 0.1 * -1;\r\n                currentVRM.blendShapeProxy.setValue(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.BlendShapePresetName.A, faceExpression[6]);\r\n                currentVRM.blendShapeProxy.setValue(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.BlendShapePresetName.U, faceExpression[7]);\r\n                currentVRM.blendShapeProxy.setValue(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.BlendShapePresetName.I, faceExpression[10]);\r\n                currentVRM.blendShapeProxy.setValue(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.BlendShapePresetName.BlinkL, faceExpression[8]);\r\n                currentVRM.blendShapeProxy.setValue(_pixiv_three_vrm__WEBPACK_IMPORTED_MODULE_3__.VRMSchema.BlendShapePresetName.BlinkR, faceExpression[9]);\r\n                console.log(faceExpression[9]);\r\n                currentVRM.blendShapeProxy.update();\r\n            }\r\n        }\r\n        if (mixer) {\r\n            mixer.update(delta * 1000);\r\n        }\r\n        controls.update();\r\n        renderer.render(scene, camera);\r\n    };\r\n    update();\r\n});\r\n\n\n//# sourceURL=webpack://vrm-test/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;